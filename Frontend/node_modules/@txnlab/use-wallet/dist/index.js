var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __require = /* @__PURE__ */ ((x3) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x3, {
  get: (a2, b3) => (typeof require !== "undefined" ? require : a2)[b3]
}) : x3)(function(x3) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x3 + '" is not supported');
});
var __esm = (fn2, res) => function __init() {
  return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// ../../node_modules/.pnpm/@magic-sdk+types@24.18.1/node_modules/@magic-sdk/types/dist/es/index.mjs
var l, m, v, u, _, f, M, g, E, x, y, A, R, I, N, h, T, O, S, b, C, F, U, k, w, L, D, V, G, H, q, W, J, Y, B, P, j, Q, X;
var init_es = __esm({
  "../../node_modules/.pnpm/@magic-sdk+types@24.18.1/node_modules/@magic-sdk/types/dist/es/index.mjs"() {
    "use strict";
    l = ((p) => (p.MissingApiKey = "MISSING_API_KEY", p.ModalNotReady = "MODAL_NOT_READY", p.ConnectionLost = "CONNECTION_WAS_LOST", p.MalformedResponse = "MALFORMED_RESPONSE", p.InvalidArgument = "INVALID_ARGUMENT", p.ExtensionNotInitialized = "EXTENSION_NOT_INITIALIZED", p.IncompatibleExtensions = "INCOMPATIBLE_EXTENSIONS", p))(l || {});
    m = ((o) => (o.SyncWeb3Method = "SYNC_WEB3_METHOD", o.DuplicateIframe = "DUPLICATE_IFRAME", o.ReactNativeEndpointConfiguration = "REACT_NATIVE_ENDPOINT_CONFIGURATION", o.DeprecationNotice = "DEPRECATION_NOTICE", o.ProductAnnouncement = "ANNOUNCEMENT", o))(m || {});
    v = ((i) => (i[i.ParseError = -32700] = "ParseError", i[i.InvalidRequest = -32600] = "InvalidRequest", i[i.MethodNotFound = -32601] = "MethodNotFound", i[i.InvalidParams = -32602] = "InvalidParams", i[i.InternalError = -32603] = "InternalError", i[i.MagicLinkFailedVerification = -1e4] = "MagicLinkFailedVerification", i[i.MagicLinkExpired = -10001] = "MagicLinkExpired", i[i.MagicLinkRateLimited = -10002] = "MagicLinkRateLimited", i[i.MagicLinkInvalidRedirectURL = -10006] = "MagicLinkInvalidRedirectURL", i[i.UserAlreadyLoggedIn = -10003] = "UserAlreadyLoggedIn", i[i.UpdateEmailFailed = -10004] = "UpdateEmailFailed", i[i.UserRequestEditEmail = -10005] = "UserRequestEditEmail", i[i.InactiveRecipient = -10010] = "InactiveRecipient", i[i.AccessDeniedToUser = -10011] = "AccessDeniedToUser", i[i.RedirectLoginComplete = -10015] = "RedirectLoginComplete", i))(v || {});
    u = ((t) => (t.PROVIDER = "magic_3pw_provider", t.ADDRESS = "magic_3pw_address", t.CHAIN_ID = "magic_3pw_chainId", t))(u || {});
    _ = ((t) => (t.WalletConnected = "wallet_connected", t.WalletRejected = "wallet_rejected", t.Web3ModalSelected = "web3modal_selected", t))(_ || {});
    f = ((e) => (e.LoginWithSms = "magic_auth_login_with_sms", e.LoginWithEmailOTP = "magic_auth_login_with_email_otp", e.LoginWithMagicLink = "magic_auth_login_with_magic_link", e.LoginWithCredential = "magic_auth_login_with_credential", e.SetAuthorizationToken = "magic_auth_set_authorization_token", e.GetIdToken = "magic_auth_get_id_token", e.GenerateIdToken = "magic_auth_generate_id_token", e.GetMetadata = "magic_auth_get_metadata", e.IsLoggedIn = "magic_is_logged_in", e.Logout = "magic_auth_logout", e.UpdateEmail = "magic_auth_update_email", e.UserSettings = "magic_auth_settings", e.UserSettingsTestMode = "magic_auth_settings_testing_mode", e.LoginWithSmsTestMode = "magic_auth_login_with_sms_testing_mode", e.LoginWithEmailOTPTestMode = "magic_auth_login_with_email_otp_testing_mode", e.LoginWithMagicLinkTestMode = "magic_login_with_magic_link_testing_mode", e.LoginWithCredentialTestMode = "magic_auth_login_with_credential_testing_mode", e.GetIdTokenTestMode = "magic_auth_get_id_token_testing_mode", e.GenerateIdTokenTestMode = "magic_auth_generate_id_token_testing_mode", e.GetMetadataTestMode = "magic_auth_get_metadata_testing_mode", e.IsLoggedInTestMode = "magic_auth_is_logged_in_testing_mode", e.LogoutTestMode = "magic_auth_logout_testing_mode", e.UpdateEmailTestMode = "magic_auth_update_email_testing_mode", e.IntermediaryEvent = "magic_intermediary_event", e.RequestAccounts = "eth_requestAccounts", e.GetInfo = "magic_get_info", e.ShowUI = "magic_wallet", e.NFTPurchase = "magic_nft_purchase", e.NFTCheckout = "magic_nft_checkout", e.NFTTransfer = "magic_nft_transfer", e.RequestUserInfoWithUI = "mc_request_user_info", e.Disconnect = "mc_disconnect", e.RecoverAccount = "magic_auth_recover_account", e.RecoverAccountTestMode = "magic_auth_recover_account_testing_mode", e.MagicBoxHeartBeat = "magic_box_heart_beat", e.AutoConnect = "mc_auto_connect", e.Login = "mc_login", e.EncryptV1 = "magic_auth_encrypt_v1", e.DecryptV1 = "magic_auth_decrypt_v1", e.ShowNFTs = "magic_show_nfts", e.ShowOnRamp = "magic_show_fiat_onramp", e.ShowSendTokensUI = "magic_show_send_tokens_ui", e.ShowAddress = "magic_show_address", e.ShowBalances = "magic_show_balances", e.SendGaslessTransaction = "eth_sendGaslessTransaction", e.RevealPK = "magic_reveal_key", e.EnableMFA = "magic_auth_enable_mfa_flow", e.DisableMFA = "magic_auth_disable_mfa_flow", e))(f || {});
    M = ["magic_intermediary_event", "magic_nft_checkout", "mc_login"];
    g = ((c2) => (c2.MAGIC_HANDLE_RESPONSE = "MAGIC_HANDLE_RESPONSE", c2.MAGIC_OVERLAY_READY = "MAGIC_OVERLAY_READY", c2.MAGIC_SHOW_OVERLAY = "MAGIC_SHOW_OVERLAY", c2.MAGIC_HIDE_OVERLAY = "MAGIC_HIDE_OVERLAY", c2.MAGIC_HANDLE_EVENT = "MAGIC_HANDLE_EVENT", c2.MAGIC_MG_BOX_SEND_RECEIPT = "MAGIC_MG_BOX_SEND_RECEIPT", c2.MAGIC_SEND_PRODUCT_ANNOUNCEMENT = "MAGIC_SEND_PRODUCT_ANNOUNCEMENT", c2.MAGIC_PONG = "MAGIC_PONG", c2.MAGIC_POPUP_RESPONSE = "MAGIC_POPUP_RESPONSE", c2.MAGIC_POPUP_OAUTH_VERIFY_RESPONSE = "MAGIC_POPUP_OAUTH_VERIFY_RESPONSE", c2))(g || {});
    E = ((d) => (d.MAGIC_HANDLE_REQUEST = "MAGIC_HANDLE_REQUEST", d.MAGIC_PING = "MAGIC_PING", d))(E || {});
    x = ((t) => (t.UpdateEmail = "update-email", t.MFA = "mfa", t.Recovery = "recovery", t))(x || {});
    y = ((r) => (r.Retry = "retry", r))(y || {});
    A = ((d) => (d.EmailSent = "email-sent", d.EmailNotDeliverable = "email-not-deliverable", d))(A || {});
    R = ((o) => (o.VerifyEmailOtp = "verify-email-otp", o.VerifyMFACode = "verify-mfa-code", o.LostDevice = "lost-device", o.VerifyRecoveryCode = "verify-recovery-code", o.Cancel = "cancel", o))(R || {});
    I = ((t) => (t.VerifySmsOtp = "verify-sms-otp", t.Cancel = "cancel", t.Retry = "retry", t))(I || {});
    N = ((t) => (t.SmsOTPSent = "sms-otp-sent", t.InvalidSmsOtp = "invalid-sms-otp", t.ExpiredSmsOtp = "expired-sms-otp", t))(N || {});
    h = ((a2) => (a2.EmailOTPSent = "email-otp-sent", a2.InvalidEmailOtp = "invalid-email-otp", a2.InvalidMfaOtp = "invalid-mfa-otp", a2.ExpiredEmailOtp = "expired-email-otp", a2.MfaSentHandle = "mfa-sent-handle", a2.RecoveryCodeSentHandle = "recovery-code-sent-handle", a2.InvalidRecoveryCode = "invalid-recovery-code", a2.RecoveryCodeSuccess = "recovery-code-success", a2))(h || {});
    T = ((r) => (r.Retry = "device-retry", r))(T || {});
    O = ((n) => (n.DeviceApproved = "device-approved", n.DeviceNeedsApproval = "device-needs-approval", n.DeviceVerificationLinkExpired = "device-verification-link-expired", n.DeviceVerificationEmailSent = "device-verification-email-sent", n))(O || {});
    S = ((n) => (n.Retry = "Recency/auth-factor-retry", n.Cancel = "Recency/auth-factor-verification-cancel", n.VerifyEmailOtp = "Recency/auth-factor-verify-email-otp", n.VerifyMFACode = "Recency/verify-mfa-code", n))(S || {});
    b = ((s) => (s.PrimaryAuthFactorNeedsVerification = "Recency/auth-factor-needs-verification", s.PrimaryAuthFactorVerified = "Recency/auth-factor-verified", s.InvalidEmailOtp = "Recency/auth-factor-invalid-email-otp", s.EmailExpired = "Recency/auth-factor-verification-email-expired", s.EmailSent = "Recency/auth-factor-verification-email-sent", s.EmailNotDeliverable = "Recency/auth-factor-verification-email-not-deliverable", s))(b || {});
    C = ((t) => (t.RetryWithNewEmail = "UpdateEmail/retry-with-new-email", t.Cancel = "UpdateEmail/new-email-verification-cancel", t.VerifyEmailOtp = "UpdateEmail/new-email-verify-otp", t))(C || {});
    F = ((a2) => (a2.NewAuthFactorNeedsVerification = "UpdateEmail/new-email-needs-verification", a2.EmailUpdated = "UpdateEmail/email-updated", a2.InvalidEmailOtp = "UpdateEmail/new-email-invalid-email-otp", a2.EmailExpired = "UpdateEmail/new-email-verification-email-expired", a2.EmailSent = "UpdateEmail/new-email-verification-email-sent", a2.EmailNotDeliverable = "UpdateEmail/new-email-verification-email-not-deliverable", a2.InvalidEmail = "UpdateEmail/new-email-invalid", a2.EmailAlreadyExists = "UpdateEmail/new-email-already-exists", a2))(F || {});
    U = ((r) => (r.IDTokenCreated = "Auth/id-token-created", r))(U || {});
    k = ((r) => (r.Cancel = "Farcaster/cancel", r))(k || {});
    w = ((t) => (t.MFASecretGenerated = "mfa-secret-generated", t.InvalidMFAOtp = "invalid-mfa-otp", t.MFARecoveryCodes = "mfa-recovery-codes", t))(w || {});
    L = ((d) => (d.VerifyMFACode = "verify-mfa-code", d.Cancel = "cancel-mfa-setup", d))(L || {});
    D = ((t) => (t.MFACodeRequested = "mfa-code-requested", t.InvalidMFAOtp = "invalid-mfa-otp", t.InvalidRecoveryCode = "invalid-recovery-code", t))(D || {});
    V = ((t) => (t.VerifyMFACode = "verify-mfa-code", t.LostDevice = "lost-device", t.Cancel = "cancel-mfa-disable", t))(V || {});
    G = ((r) => (r.Harmony = "HARMONY", r))(G || {});
    H = ((r) => (r.ClosedByUser = "closed-by-user", r))(H || {});
    q = ((r) => (r.ClosedByUser = "closed-by-user-on-received", r))(q || {});
    W = ((o) => (o.EnterNewPhoneNumber = "enter-new-phone-number", o.EnterOtpCode = "enter-otp-code", o.RecoveryFactorAlreadyExists = "recovery-factor-already-exists", o.MalformedPhoneNumber = "malformed-phone-number", o.InvalidOtpCode = "invalid-otp-code", o))(W || {});
    J = ((n) => (n.SendNewPhoneNumber = "send-new-phone-number", n.SendOtpCode = "send-otp-code", n.Cancel = "cancel", n.StartEditPhoneNumber = "start-edit-phone-number", n))(J || {});
    Y = ((r) => (r.PhoneNumber = "phone_number", r))(Y || {});
    B = ((s) => (s.SmsOtpSent = "sms-otp-sent", s.LoginThrottled = "login-throttled", s.InvalidSmsOtp = "invalid-sms-otp", s.SmsVerified = "sms-verified", s.AccountRecovered = "account-recovered", s.UpdateEmailRequired = "update-email-required", s))(B || {});
    P = ((n) => (n.Cancel = "cancel", n.VerifyOtp = "verify-otp-code", n.ResendSms = "resend-sms-otp", n.UpdateEmail = "update-email", n))(P || {});
    j = ((n) => (n.Success = "nft-checkout-success", n.Failure = "nft-checkout-failure", n.Initiated = "nft-checkout-initiated", n.Disconnect = "disconnect", n))(j || {});
    Q = ((r) => (r.WalletInfoFetched = "Wallet/wallet-info-fetched", r))(Q || {});
    X = ((r) => (r.CloseMagicWindow = "close-magic-window", r))(X || {});
  }
});

// ../../node_modules/.pnpm/@magic-sdk+provider@28.20.0_localforage@1.10.0/node_modules/@magic-sdk/provider/dist/es/index.mjs
function lr(r) {
  let e = { exports: {} };
  return r(e, e.exports), e.exports;
}
function jr(r) {
  return String.fromCharCode(parseInt(r.slice(1), 16));
}
function Vr(r) {
  return `%${`00${r.charCodeAt(0).toString(16)}`.slice(-2)}`;
}
function Hr(r) {
  return btoa(encodeURIComponent(r).replace(/%[0-9A-F]{2}/g, jr));
}
function Br(r) {
  return decodeURIComponent(Array.from(atob(r), Vr).join(""));
}
function Re(r) {
  return Hr(JSON.stringify(r));
}
function gt(r) {
  return JSON.parse(Br(r));
}
function O2(r) {
  return typeof r == "undefined";
}
function Yr(r) {
  return r === null;
}
function ve(r) {
  return Yr(r) || O2(r);
}
function yt(r) {
  return ve(r) ? false : !O2(r.jsonrpc) && !O2(r.id) && (!O2(r.result) || !O2(r.error));
}
function Rt(r) {
  return ve(r) ? false : typeof r == "number" && Object.values(v).includes(r);
}
function ce(r) {
  if (!r) return true;
  for (let e in r) if (Object.hasOwnProperty.call(r, e)) return false;
  return true;
}
function Qr(r, e) {
  return Object.assign(m2, e), r;
}
function It() {
  return new C2(l.MissingApiKey, "Please provide an API key that you acquired from the Magic developer dashboard.");
}
function Tt() {
  return new C2(l.ModalNotReady, "Modal is not ready.");
}
function bt() {
  return new C2(l.MalformedResponse, "Response from the Magic iframe is malformed.");
}
function Pt(r) {
  return new C2(l.ExtensionNotInitialized, `Extensions must be initialized with a Magic SDK instance before \`Extension.${r}\` can be accessed. Do not invoke \`Extension.${r}\` inside an extension constructor.`);
}
function wt(r) {
  let e = `Some extensions are incompatible with \`${m2.sdkName}@${m2.version}\`:`;
  return r.filter((t) => typeof t.compat != "undefined" && t.compat !== null).forEach((t) => {
    let n = t.compat[m2.sdkName];
    typeof n == "string" ? e += `
  - Extension \`${t.name}\` supports version(s) \`${n}\`` : n || (e += `
  - Extension \`${t.name}\` does not support ${m2.platform} environments.`);
  }), new C2(l.IncompatibleExtensions, e);
}
function xt(r) {
  let e = (t) => {
    let n = t + 1, o = n % 10, s = n % 100;
    return o === 1 && s !== 11 ? `${n}st` : o === 2 && s !== 12 ? `${n}nd` : o === 3 && s !== 13 ? `${n}rd` : `${n}th`;
  };
  return new C2(l.InvalidArgument, `Invalid ${e(r.argument)} argument given to \`${r.procedure}\`.
  Expected: \`${r.expected}\`
  Received: \`${r.received}\``);
}
function Xn() {
  return new F2(m.DuplicateIframe, "Duplicate iframes found.");
}
function Mt() {
  return new F2(m.SyncWeb3Method, "Non-async web3 methods are deprecated in web3 > 1.0 and are not supported by the Magic web3 provider. Please use an async method instead.");
}
function St() {
  return new F2(m.ReactNativeEndpointConfiguration, `CUSTOM DOMAINS ARE NOT SUPPORTED WHEN USING MAGIC SDK WITH REACT NATIVE! The \`endpoint\` parameter SHOULD NOT be provided. The Magic \`<iframe>\` is automatically wrapped by a WebView pointed at \`${m2.defaultEndpoint}\`. Changing this default behavior will lead to unexpected results and potentially security-threatening bugs.`);
}
function W2(r) {
  let { method: e, removalVersions: t, useInstead: n } = r, o = t[m2.sdkName], s = n ? ` Use \`${n}\` instead.` : "", i = `\`${e}\` will be removed from \`${m2.sdkName}\` in version \`${o}\`.${s}`;
  return new F2(m.DeprecationNotice, i);
}
function* en() {
  let r = 0;
  for (; ; ) r < Number.MAX_SAFE_INTEGER ? yield ++r : r = 0;
}
function We() {
  return tn.next().value;
}
function At(r) {
  return Object.defineProperty(r, Nt, { value: true, enumerable: false }), r;
}
function rn(r) {
  return !!r[Nt];
}
function H2(r) {
  var e, t, n;
  return rn(r) || (r.jsonrpc = (e = r.jsonrpc) != null ? e : "2.0", r.id = We(), r.method = (t = r.method) != null ? t : "noop", r.params = (n = r.params) != null ? n : [], At(r)), r;
}
function u2(r, e = []) {
  return At({ params: e, method: r, jsonrpc: "2.0", id: We() });
}
function be() {
  let r = new Ge();
  return { emitter: r, createChainingEmitterMethod: (n, o) => (...s) => (r[n].apply(r, s), o), createBoundEmitterMethod: (n) => (...o) => r[n].apply(r, o) };
}
function _t(r) {
  return !!r[Ot];
}
function x2(r) {
  let e = Ke(r), { createBoundEmitterMethod: t, createChainingEmitterMethod: n } = be(), o = Symbol("Promise.then"), s = Symbol("Promise.catch"), i = Symbol("Promise.finally"), a2 = (d, p) => (...M2) => {
    let v2 = p[d].apply(p, M2);
    return c2(v2);
  }, c2 = (d) => Object.assign(d, { [Ot]: true, [o]: d[o] || d.then, [s]: d[s] || d.catch, [i]: d[i] || d.finally, then: a2(o, d), catch: a2(s, d), finally: a2(i, d), on: n("on", d), once: n("once", d), addListener: n("addListener", d), off: n("off", d), removeListener: n("removeListener", d), removeAllListeners: n("removeAllListeners", d), emit: t("emit"), eventNames: t("eventNames"), listeners: t("listeners"), listenerCount: t("listenerCount") }), l2 = c2(e.then((d) => (l2.emit("done", d), l2.emit("settled"), d), (d) => {
    throw l2.emit("error", d), l2.emit("settled"), d;
  }));
  return l2.on(q.ClosedByUser, () => {
    l2.emit(H.ClosedByUser);
  }), l2;
}
function Ke(r) {
  return new Promise((e, t) => {
    let n = r(e, t);
    Promise.resolve(n).catch(t);
  });
}
function kt(r, e) {
  let [t] = r.split(".").map(Number);
  return t >= e;
}
function K(r) {
  return (...e) => f2(this, null, function* () {
    return xe || (xe = yield m2.configureStorage()), yield xe.ready(), xe[r](...e);
  });
}
function qt() {
  let r = window.crypto.getRandomValues(new Uint8Array(16));
  r[6] = r[6] & 15 | 64, r[8] = r[8] & 191 | 128;
  let e = "";
  return e += r[0].toString(16), e += r[1].toString(16), e += r[2].toString(16), e += r[3].toString(16), e += "-", e += r[4].toString(16), e += r[5].toString(16), e += "-", e += r[6].toString(16), e += r[7].toString(16), e += "-", e += r[8].toString(16), e += r[9].toString(16), e += "-", e += r[10].toString(16), e += r[11].toString(16), e += r[12].toString(16), e += r[13].toString(16), e += r[14].toString(16), e += r[15].toString(16), e;
}
function pe() {
  let r = typeof window != "undefined" && !!window.crypto, e = r && !!window.crypto.subtle;
  return r && e;
}
function Wt() {
  return f2(this, null, function* () {
    let r = yield yn();
    if (!r) {
      console.info("unable to create public key or webcrypto is unsupported");
      return;
    }
    let { subtle: e } = window.crypto, t = yield b2(Ve);
    if (!t || !e) {
      console.info("unable to find private key or webcrypto unsupported");
      return;
    }
    let n = { iat: Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3), jti: qt() }, o = { typ: "dpop+jwt", alg: "ES256", jwk: r }, s = { protected: Ut(JSON.stringify(o)), claims: Ut(JSON.stringify(n)) }, i = vn(`${s.protected}.${s.claims}`), a2 = { name: Ft, hash: { name: "SHA-256" } }, c2 = Tn(new Uint8Array(yield e.sign(a2, t, i)));
    return `${s.protected}.${s.claims}.${c2}`;
  });
}
function yn() {
  return f2(this, null, function* () {
    if (!pe()) {
      console.info("webcrypto is not supported");
      return;
    }
    return (yield b2(Me)) || (yield Rn()), b2(Me);
  });
}
function Rn() {
  return f2(this, null, function* () {
    let { subtle: r } = window.crypto, e = yield r.generateKey(gn, false, ["sign"]), t = yield r.exportKey("jwk", e.publicKey);
    yield S2(Ve, e.privateKey), yield S2(Me, t);
  });
}
function Ut(r) {
  return Jt(In(r));
}
function vn(r) {
  return new TextEncoder().encode(r);
}
function Jt(r) {
  return btoa(r).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+/g, "");
}
function In(r) {
  return encodeURIComponent(r).replace(/%([0-9A-F]{2})/g, (t, n) => String.fromCharCode(parseInt(n, 16)));
}
function Tn(r) {
  let e = "";
  return r.forEach((t) => {
    e += String.fromCharCode(t);
  }), Jt(e);
}
function te() {
  return f2(this, null, function* () {
    let r = [];
    yield je((e, t, n) => {
      t.startsWith(`${He}_`) && r.push(t);
    });
    for (let e of r) yield k2(e);
  });
}
function Gt(r) {
  let e = "", t = new Uint8Array(r), n = t.byteLength;
  for (let o = 0; o < n; o++) e += String.fromCharCode(t[o]);
  return window.btoa(e);
}
function Kt(r) {
  let e = window.atob(r), t = e.length, n = new Uint8Array(t);
  for (let o = 0; o < t; o++) n[o] = e.charCodeAt(o);
  return n.buffer;
}
function Pn() {
  return f2(this, null, function* () {
    if (!pe()) {
      console.info("webcrypto is not supported");
      return;
    }
    let { crypto: r } = window, e = yield b2(Xe);
    return e || r.getRandomValues(new Uint8Array(12));
  });
}
function wn() {
  return f2(this, null, function* () {
    if (!pe()) {
      console.info("webcrypto is not supported");
      return;
    }
    let { subtle: r } = window.crypto, e = yield b2(Be);
    return e || (yield r.generateKey({ name: ze, length: bn }, false, ["encrypt", "decrypt"]));
  });
}
function jt(r, e) {
  return f2(this, null, function* () {
    let t = yield Pn(), n = yield wn();
    if (!t || !n || !r) return;
    let o = Kt(r), { subtle: s } = window.crypto, i = yield s.encrypt({ name: ze, iv: t }, n, o), a2 = Gt(i);
    yield S2(`${He}_${e}`, a2), yield S2(Be, n), yield S2(Xe, t);
  });
}
function Vt(r) {
  return f2(this, null, function* () {
    let e = yield b2(`${He}_${r}`), t = yield b2(Xe), n = yield b2(Be);
    if (!t || !e || !n || !pe()) return;
    let { subtle: o } = window.crypto, s = yield o.decrypt({ name: ze, iv: t }, n, Kt(e));
    return Gt(s);
  });
}
function Ye(r, e) {
  return e ? new URL(r, e) : new URL(r);
}
function Mn(r) {
  let e = Object.getPrototypeOf(r), t = [e];
  for (; e !== R2.prototype; ) e = Object.getPrototypeOf(e), t.push(e);
  return t;
}
function zt(r) {
  return r.compat && r.compat[m2.sdkName] != null ? typeof r.compat[m2.sdkName] == "string" ? ft(Et(m2.version), r.compat[m2.sdkName]) : !!r.compat[m2.sdkName] : true;
}
function Sn(r, e, t) {
  return !e && !t ? `${r}_eth_mainnet` : t ? `${r}_${JSON.stringify(t)}` : e ? typeof e == "string" ? `${r}_eth_${e}` : `${r}_${e.rpcUrl}_${e.chainId}_${e.chainType}` : `${r}_unknown`;
}
function Nn(r) {
  var o;
  let e = (o = r == null ? void 0 : r.extensions) != null ? o : [], t = {}, n = [];
  if (Array.isArray(e) ? e.forEach((s) => {
    zt(s) ? (s.init(this), (s.name || s.name !== D2.Anonymous) && (this[s.name] = s), s instanceof D2.Internal && (ce(s.config) || (t[s.name] = s.config))) : n.push(s);
  }) : Object.keys(e).forEach((s) => {
    if (zt(e[s])) {
      e[s].init(this);
      let i = e[s];
      this[s] = i, i instanceof D2.Internal && (ce(i.config) || (t[e[s].name] = i.config));
    } else n.push(e[s]);
  }), n.length) throw wt(n);
  return t;
}
function Cn(r, e) {
  return e && Array.isArray(r) ? r.find((t) => t.id === e) : r;
}
function $n(r, e) {
  var o;
  let t = (o = e.data.response) == null ? void 0 : o.id, n = Cn(r, t);
  if (t && n) {
    let s = new J2(n).applyResult(e.data.response.result).applyError(e.data.response.error);
    return { id: t, response: s };
  }
  return {};
}
function Ln(r, e, t) {
  return f2(this, null, function* () {
    var a2;
    let n = yield b2("rt"), o;
    if (m2.platform === "web") try {
      o = (a2 = yield b2("jwt")) != null ? a2 : yield Wt();
    } catch (c2) {
      console.error("webcrypto error", c2);
    }
    let s = { msgType: r, payload: e };
    o && (s.jwt = o), o && n && (s.rt = n);
    let i = yield Vt(t);
    return i && (s.deviceShare = i), s;
  });
}
function On(r) {
  return f2(this, null, function* () {
    !r.data.rt || (yield S2("rt", r.data.rt));
  });
}
var Qt, fe, Zt, er, tr, rr, rt, nr, st, sr, nt, q2, z, or, ir, ar, cr, f2, $t, dr, Fe, ur, h2, ae, ot, ht, pr, mr, it, Ee, at, ct, oe, E2, hr, Y2, fr, Er, gr, yr, Rr, vr, Ir, Tr, br, Pr, wr, xr, Mr, Ue, ie, U2, lt, dt, L2, I2, y2, Sr, Nr, Ar, ut, Cr, P2, $r, Lr, Or, _r, kr, Dr, qr, Ur, Fr, Wr, ft, Jr, pt, mt, Gr, Kr, ge, ye, Et, m2, vt, C2, _2, F2, Q2, le, tn, Nt, J2, Lt, Ge, Ot, R2, B2, we, ue, xe, b2, S2, k2, pn, mn, hn, fn, je, Ve, Me, Ft, En, gn, He, Be, Xe, ze, bn, Ne, Ae, $e, Le, se, Oe, Xt, _e, Qe, D2, De, me, qe, et;
var init_es2 = __esm({
  "../../node_modules/.pnpm/@magic-sdk+provider@28.20.0_localforage@1.10.0/node_modules/@magic-sdk/provider/dist/es/index.mjs"() {
    "use strict";
    init_es();
    init_es();
    init_es();
    init_es();
    init_es();
    init_es();
    init_es();
    init_es();
    init_es();
    init_es();
    init_es();
    Qt = Object.create;
    fe = Object.defineProperty;
    Zt = Object.defineProperties;
    er = Object.getOwnPropertyDescriptor;
    tr = Object.getOwnPropertyDescriptors;
    rr = Object.getOwnPropertyNames;
    rt = Object.getOwnPropertySymbols;
    nr = Object.getPrototypeOf;
    st = Object.prototype.hasOwnProperty;
    sr = Object.prototype.propertyIsEnumerable;
    nt = (r, e, t) => e in r ? fe(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
    q2 = (r, e) => {
      for (var t in e || (e = {})) st.call(e, t) && nt(r, t, e[t]);
      if (rt) for (var t of rt(e)) sr.call(e, t) && nt(r, t, e[t]);
      return r;
    };
    z = (r, e) => Zt(r, tr(e));
    or = (r, e) => () => (e || r((e = { exports: {} }).exports, e), e.exports);
    ir = (r, e) => {
      for (var t in e) fe(r, t, { get: e[t], enumerable: true });
    };
    ar = (r, e, t, n) => {
      if (e && typeof e == "object" || typeof e == "function") for (let o of rr(e)) !st.call(r, o) && o !== t && fe(r, o, { get: () => e[o], enumerable: !(n = er(e, o)) || n.enumerable });
      return r;
    };
    cr = (r, e, t) => (t = r != null ? Qt(nr(r)) : {}, ar(e || !r || !r.__esModule ? fe(t, "default", { value: r, enumerable: true }) : t, r));
    f2 = (r, e, t) => new Promise((n, o) => {
      var s = (c2) => {
        try {
          a2(t.next(c2));
        } catch (l2) {
          o(l2);
        }
      }, i = (c2) => {
        try {
          a2(t.throw(c2));
        } catch (l2) {
          o(l2);
        }
      }, a2 = (c2) => c2.done ? n(c2.value) : Promise.resolve(c2.value).then(s, i);
      a2((t = t.apply(r, e)).next());
    });
    $t = or((ts, Je2) => {
      "use strict";
      var nn = Object.prototype.hasOwnProperty, w2 = "~";
      function de() {
      }
      Object.create && (de.prototype = /* @__PURE__ */ Object.create(null), new de().__proto__ || (w2 = false));
      function sn(r, e, t) {
        this.fn = r, this.context = e, this.once = t || false;
      }
      function Ct(r, e, t, n, o) {
        if (typeof t != "function") throw new TypeError("The listener must be a function");
        var s = new sn(t, n || r, o), i = w2 ? w2 + e : e;
        return r._events[i] ? r._events[i].fn ? r._events[i] = [r._events[i], s] : r._events[i].push(s) : (r._events[i] = s, r._eventsCount++), r;
      }
      function Te(r, e) {
        --r._eventsCount === 0 ? r._events = new de() : delete r._events[e];
      }
      function T2() {
        this._events = new de(), this._eventsCount = 0;
      }
      T2.prototype.eventNames = function() {
        var e = [], t, n;
        if (this._eventsCount === 0) return e;
        for (n in t = this._events) nn.call(t, n) && e.push(w2 ? n.slice(1) : n);
        return Object.getOwnPropertySymbols ? e.concat(Object.getOwnPropertySymbols(t)) : e;
      };
      T2.prototype.listeners = function(e) {
        var t = w2 ? w2 + e : e, n = this._events[t];
        if (!n) return [];
        if (n.fn) return [n.fn];
        for (var o = 0, s = n.length, i = new Array(s); o < s; o++) i[o] = n[o].fn;
        return i;
      };
      T2.prototype.listenerCount = function(e) {
        var t = w2 ? w2 + e : e, n = this._events[t];
        return n ? n.fn ? 1 : n.length : 0;
      };
      T2.prototype.emit = function(e, t, n, o, s, i) {
        var a2 = w2 ? w2 + e : e;
        if (!this._events[a2]) return false;
        var c2 = this._events[a2], l2 = arguments.length, d, p;
        if (c2.fn) {
          switch (c2.once && this.removeListener(e, c2.fn, void 0, true), l2) {
            case 1:
              return c2.fn.call(c2.context), true;
            case 2:
              return c2.fn.call(c2.context, t), true;
            case 3:
              return c2.fn.call(c2.context, t, n), true;
            case 4:
              return c2.fn.call(c2.context, t, n, o), true;
            case 5:
              return c2.fn.call(c2.context, t, n, o, s), true;
            case 6:
              return c2.fn.call(c2.context, t, n, o, s, i), true;
          }
          for (p = 1, d = new Array(l2 - 1); p < l2; p++) d[p - 1] = arguments[p];
          c2.fn.apply(c2.context, d);
        } else {
          var M2 = c2.length, v2;
          for (p = 0; p < M2; p++) switch (c2[p].once && this.removeListener(e, c2[p].fn, void 0, true), l2) {
            case 1:
              c2[p].fn.call(c2[p].context);
              break;
            case 2:
              c2[p].fn.call(c2[p].context, t);
              break;
            case 3:
              c2[p].fn.call(c2[p].context, t, n);
              break;
            case 4:
              c2[p].fn.call(c2[p].context, t, n, o);
              break;
            default:
              if (!d) for (v2 = 1, d = new Array(l2 - 1); v2 < l2; v2++) d[v2 - 1] = arguments[v2];
              c2[p].fn.apply(c2[p].context, d);
          }
        }
        return true;
      };
      T2.prototype.on = function(e, t, n) {
        return Ct(this, e, t, n, false);
      };
      T2.prototype.once = function(e, t, n) {
        return Ct(this, e, t, n, true);
      };
      T2.prototype.removeListener = function(e, t, n, o) {
        var s = w2 ? w2 + e : e;
        if (!this._events[s]) return this;
        if (!t) return Te(this, s), this;
        var i = this._events[s];
        if (i.fn) i.fn === t && (!o || i.once) && (!n || i.context === n) && Te(this, s);
        else {
          for (var a2 = 0, c2 = [], l2 = i.length; a2 < l2; a2++) (i[a2].fn !== t || o && !i[a2].once || n && i[a2].context !== n) && c2.push(i[a2]);
          c2.length ? this._events[s] = c2.length === 1 ? c2[0] : c2 : Te(this, s);
        }
        return this;
      };
      T2.prototype.removeAllListeners = function(e) {
        var t;
        return e ? (t = w2 ? w2 + e : e, this._events[t] && Te(this, t)) : (this._events = new de(), this._eventsCount = 0), this;
      };
      T2.prototype.off = T2.prototype.removeListener;
      T2.prototype.addListener = T2.prototype.on;
      T2.prefixed = w2;
      T2.EventEmitter = T2;
      typeof Je2 < "u" && (Je2.exports = T2);
    });
    dr = Number.MAX_SAFE_INTEGER || 9007199254740991;
    Fe = { SEMVER_SPEC_VERSION: "2.0.0", MAX_LENGTH: 256, MAX_SAFE_INTEGER: dr, MAX_SAFE_COMPONENT_LENGTH: 16 };
    ur = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...r) => console.error("SEMVER", ...r) : () => {
    };
    h2 = ur;
    ae = lr(function(r, e) {
      let { MAX_SAFE_COMPONENT_LENGTH: t } = Fe, n = (e = r.exports = {}).re = [], o = e.src = [], s = e.t = {}, i = 0, a2 = (c2, l2, d) => {
        let p = i++;
        h2(p, l2), s[c2] = p, o[p] = l2, n[p] = new RegExp(l2, d ? "g" : void 0);
      };
      a2("NUMERICIDENTIFIER", "0|[1-9]\\d*"), a2("NUMERICIDENTIFIERLOOSE", "[0-9]+"), a2("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), a2("MAINVERSION", `(${o[s.NUMERICIDENTIFIER]})\\.(${o[s.NUMERICIDENTIFIER]})\\.(${o[s.NUMERICIDENTIFIER]})`), a2("MAINVERSIONLOOSE", `(${o[s.NUMERICIDENTIFIERLOOSE]})\\.(${o[s.NUMERICIDENTIFIERLOOSE]})\\.(${o[s.NUMERICIDENTIFIERLOOSE]})`), a2("PRERELEASEIDENTIFIER", `(?:${o[s.NUMERICIDENTIFIER]}|${o[s.NONNUMERICIDENTIFIER]})`), a2("PRERELEASEIDENTIFIERLOOSE", `(?:${o[s.NUMERICIDENTIFIERLOOSE]}|${o[s.NONNUMERICIDENTIFIER]})`), a2("PRERELEASE", `(?:-(${o[s.PRERELEASEIDENTIFIER]}(?:\\.${o[s.PRERELEASEIDENTIFIER]})*))`), a2("PRERELEASELOOSE", `(?:-?(${o[s.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${o[s.PRERELEASEIDENTIFIERLOOSE]})*))`), a2("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), a2("BUILD", `(?:\\+(${o[s.BUILDIDENTIFIER]}(?:\\.${o[s.BUILDIDENTIFIER]})*))`), a2("FULLPLAIN", `v?${o[s.MAINVERSION]}${o[s.PRERELEASE]}?${o[s.BUILD]}?`), a2("FULL", `^${o[s.FULLPLAIN]}$`), a2("LOOSEPLAIN", `[v=\\s]*${o[s.MAINVERSIONLOOSE]}${o[s.PRERELEASELOOSE]}?${o[s.BUILD]}?`), a2("LOOSE", `^${o[s.LOOSEPLAIN]}$`), a2("GTLT", "((?:<|>)?=?)"), a2("XRANGEIDENTIFIERLOOSE", `${o[s.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), a2("XRANGEIDENTIFIER", `${o[s.NUMERICIDENTIFIER]}|x|X|\\*`), a2("XRANGEPLAIN", `[v=\\s]*(${o[s.XRANGEIDENTIFIER]})(?:\\.(${o[s.XRANGEIDENTIFIER]})(?:\\.(${o[s.XRANGEIDENTIFIER]})(?:${o[s.PRERELEASE]})?${o[s.BUILD]}?)?)?`), a2("XRANGEPLAINLOOSE", `[v=\\s]*(${o[s.XRANGEIDENTIFIERLOOSE]})(?:\\.(${o[s.XRANGEIDENTIFIERLOOSE]})(?:\\.(${o[s.XRANGEIDENTIFIERLOOSE]})(?:${o[s.PRERELEASELOOSE]})?${o[s.BUILD]}?)?)?`), a2("XRANGE", `^${o[s.GTLT]}\\s*${o[s.XRANGEPLAIN]}$`), a2("XRANGELOOSE", `^${o[s.GTLT]}\\s*${o[s.XRANGEPLAINLOOSE]}$`), a2("COERCE", `(^|[^\\d])(\\d{1,${t}})(?:\\.(\\d{1,${t}}))?(?:\\.(\\d{1,${t}}))?(?:$|[^\\d])`), a2("COERCERTL", o[s.COERCE], true), a2("LONETILDE", "(?:~>?)"), a2("TILDETRIM", `(\\s*)${o[s.LONETILDE]}\\s+`, true), e.tildeTrimReplace = "$1~", a2("TILDE", `^${o[s.LONETILDE]}${o[s.XRANGEPLAIN]}$`), a2("TILDELOOSE", `^${o[s.LONETILDE]}${o[s.XRANGEPLAINLOOSE]}$`), a2("LONECARET", "(?:\\^)"), a2("CARETTRIM", `(\\s*)${o[s.LONECARET]}\\s+`, true), e.caretTrimReplace = "$1^", a2("CARET", `^${o[s.LONECARET]}${o[s.XRANGEPLAIN]}$`), a2("CARETLOOSE", `^${o[s.LONECARET]}${o[s.XRANGEPLAINLOOSE]}$`), a2("COMPARATORLOOSE", `^${o[s.GTLT]}\\s*(${o[s.LOOSEPLAIN]})$|^$`), a2("COMPARATOR", `^${o[s.GTLT]}\\s*(${o[s.FULLPLAIN]})$|^$`), a2("COMPARATORTRIM", `(\\s*)${o[s.GTLT]}\\s*(${o[s.LOOSEPLAIN]}|${o[s.XRANGEPLAIN]})`, true), e.comparatorTrimReplace = "$1$2$3", a2("HYPHENRANGE", `^\\s*(${o[s.XRANGEPLAIN]})\\s+-\\s+(${o[s.XRANGEPLAIN]})\\s*$`), a2("HYPHENRANGELOOSE", `^\\s*(${o[s.XRANGEPLAINLOOSE]})\\s+-\\s+(${o[s.XRANGEPLAINLOOSE]})\\s*$`), a2("STAR", "(<|>)?=?\\s*\\*"), a2("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), a2("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
    });
    ot = /^[0-9]+$/;
    ht = (r, e) => {
      let t = ot.test(r), n = ot.test(e);
      return t && n && (r = +r, e = +e), r === e ? 0 : t && !n ? -1 : n && !t ? 1 : r < e ? -1 : 1;
    };
    pr = (r, e) => ht(e, r);
    mr = { compareIdentifiers: ht, rcompareIdentifiers: pr };
    ({ MAX_LENGTH: it, MAX_SAFE_INTEGER: Ee } = Fe);
    ({ re: at, t: ct } = ae);
    ({ compareIdentifiers: oe } = mr);
    E2 = class {
      constructor(e, t) {
        if (t && typeof t == "object" || (t = { loose: !!t, includePrerelease: false }), e instanceof E2) {
          if (e.loose === !!t.loose && e.includePrerelease === !!t.includePrerelease) return e;
          e = e.version;
        } else if (typeof e != "string") throw new TypeError(`Invalid Version: ${e}`);
        if (e.length > it) throw new TypeError(`version is longer than ${it} characters`);
        h2("SemVer", e, t), this.options = t, this.loose = !!t.loose, this.includePrerelease = !!t.includePrerelease;
        let n = e.trim().match(t.loose ? at[ct.LOOSE] : at[ct.FULL]);
        if (!n) throw new TypeError(`Invalid Version: ${e}`);
        if (this.raw = e, this.major = +n[1], this.minor = +n[2], this.patch = +n[3], this.major > Ee || this.major < 0) throw new TypeError("Invalid major version");
        if (this.minor > Ee || this.minor < 0) throw new TypeError("Invalid minor version");
        if (this.patch > Ee || this.patch < 0) throw new TypeError("Invalid patch version");
        n[4] ? this.prerelease = n[4].split(".").map((o) => {
          if (/^[0-9]+$/.test(o)) {
            let s = +o;
            if (s >= 0 && s < Ee) return s;
          }
          return o;
        }) : this.prerelease = [], this.build = n[5] ? n[5].split(".") : [], this.format();
      }
      format() {
        return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
      }
      toString() {
        return this.version;
      }
      compare(e) {
        if (h2("SemVer.compare", this.version, this.options, e), !(e instanceof E2)) {
          if (typeof e == "string" && e === this.version) return 0;
          e = new E2(e, this.options);
        }
        return e.version === this.version ? 0 : this.compareMain(e) || this.comparePre(e);
      }
      compareMain(e) {
        return e instanceof E2 || (e = new E2(e, this.options)), oe(this.major, e.major) || oe(this.minor, e.minor) || oe(this.patch, e.patch);
      }
      comparePre(e) {
        if (e instanceof E2 || (e = new E2(e, this.options)), this.prerelease.length && !e.prerelease.length) return -1;
        if (!this.prerelease.length && e.prerelease.length) return 1;
        if (!this.prerelease.length && !e.prerelease.length) return 0;
        let t = 0;
        do {
          let n = this.prerelease[t], o = e.prerelease[t];
          if (h2("prerelease compare", t, n, o), n === void 0 && o === void 0) return 0;
          if (o === void 0) return 1;
          if (n === void 0) return -1;
          if (n !== o) return oe(n, o);
        } while (++t);
      }
      compareBuild(e) {
        e instanceof E2 || (e = new E2(e, this.options));
        let t = 0;
        do {
          let n = this.build[t], o = e.build[t];
          if (h2("prerelease compare", t, n, o), n === void 0 && o === void 0) return 0;
          if (o === void 0) return 1;
          if (n === void 0) return -1;
          if (n !== o) return oe(n, o);
        } while (++t);
      }
      inc(e, t) {
        switch (e) {
          case "premajor":
            this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t);
            break;
          case "preminor":
            this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t);
            break;
          case "prepatch":
            this.prerelease.length = 0, this.inc("patch", t), this.inc("pre", t);
            break;
          case "prerelease":
            this.prerelease.length === 0 && this.inc("patch", t), this.inc("pre", t);
            break;
          case "major":
            this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
            break;
          case "minor":
            this.patch === 0 && this.prerelease.length !== 0 || this.minor++, this.patch = 0, this.prerelease = [];
            break;
          case "patch":
            this.prerelease.length === 0 && this.patch++, this.prerelease = [];
            break;
          case "pre":
            if (this.prerelease.length === 0) this.prerelease = [0];
            else {
              let n = this.prerelease.length;
              for (; --n >= 0; ) typeof this.prerelease[n] == "number" && (this.prerelease[n]++, n = -2);
              n === -1 && this.prerelease.push(0);
            }
            t && (this.prerelease[0] === t ? isNaN(this.prerelease[1]) && (this.prerelease = [t, 0]) : this.prerelease = [t, 0]);
            break;
          default:
            throw new Error(`invalid increment argument: ${e}`);
        }
        return this.format(), this.raw = this.version, this;
      }
    };
    hr = (r, e, t) => new E2(r, t).compare(new E2(e, t));
    Y2 = hr;
    fr = (r, e, t) => Y2(r, e, t) === 0;
    Er = fr;
    gr = (r, e, t) => Y2(r, e, t) !== 0;
    yr = gr;
    Rr = (r, e, t) => Y2(r, e, t) > 0;
    vr = Rr;
    Ir = (r, e, t) => Y2(r, e, t) >= 0;
    Tr = Ir;
    br = (r, e, t) => Y2(r, e, t) < 0;
    Pr = br;
    wr = (r, e, t) => Y2(r, e, t) <= 0;
    xr = wr;
    Mr = (r, e, t, n) => {
      switch (e) {
        case "===":
          return typeof r == "object" && (r = r.version), typeof t == "object" && (t = t.version), r === t;
        case "!==":
          return typeof r == "object" && (r = r.version), typeof t == "object" && (t = t.version), r !== t;
        case "":
        case "=":
        case "==":
          return Er(r, t, n);
        case "!=":
          return yr(r, t, n);
        case ">":
          return vr(r, t, n);
        case ">=":
          return Tr(r, t, n);
        case "<":
          return Pr(r, t, n);
        case "<=":
          return xr(r, t, n);
        default:
          throw new TypeError(`Invalid operator: ${e}`);
      }
    };
    Ue = Mr;
    ie = Symbol("SemVer ANY");
    U2 = class {
      static get ANY() {
        return ie;
      }
      constructor(e, t) {
        if (t && typeof t == "object" || (t = { loose: !!t, includePrerelease: false }), e instanceof U2) {
          if (e.loose === !!t.loose) return e;
          e = e.value;
        }
        h2("comparator", e, t), this.options = t, this.loose = !!t.loose, this.parse(e), this.semver === ie ? this.value = "" : this.value = this.operator + this.semver.version, h2("comp", this);
      }
      parse(e) {
        let t = this.options.loose ? lt[dt.COMPARATORLOOSE] : lt[dt.COMPARATOR], n = e.match(t);
        if (!n) throw new TypeError(`Invalid comparator: ${e}`);
        this.operator = n[1] !== void 0 ? n[1] : "", this.operator === "=" && (this.operator = ""), n[2] ? this.semver = new E2(n[2], this.options.loose) : this.semver = ie;
      }
      toString() {
        return this.value;
      }
      test(e) {
        if (h2("Comparator.test", e, this.options.loose), this.semver === ie || e === ie) return true;
        if (typeof e == "string") try {
          e = new E2(e, this.options);
        } catch (t) {
          return false;
        }
        return Ue(e, this.operator, this.semver, this.options);
      }
      intersects(e, t) {
        if (!(e instanceof U2)) throw new TypeError("a Comparator is required");
        if (t && typeof t == "object" || (t = { loose: !!t, includePrerelease: false }), this.operator === "") return this.value === "" || new L2(e.value, t).test(this.value);
        if (e.operator === "") return e.value === "" || new L2(this.value, t).test(e.semver);
        let n = !(this.operator !== ">=" && this.operator !== ">" || e.operator !== ">=" && e.operator !== ">"), o = !(this.operator !== "<=" && this.operator !== "<" || e.operator !== "<=" && e.operator !== "<"), s = this.semver.version === e.semver.version, i = !(this.operator !== ">=" && this.operator !== "<=" || e.operator !== ">=" && e.operator !== "<="), a2 = Ue(this.semver, "<", e.semver, t) && (this.operator === ">=" || this.operator === ">") && (e.operator === "<=" || e.operator === "<"), c2 = Ue(this.semver, ">", e.semver, t) && (this.operator === "<=" || this.operator === "<") && (e.operator === ">=" || e.operator === ">");
        return n || o || s && i || a2 || c2;
      }
    };
    ({ re: lt, t: dt } = ae);
    L2 = class {
      constructor(e, t) {
        if (t && typeof t == "object" || (t = { loose: !!t, includePrerelease: false }), e instanceof L2) return e.loose === !!t.loose && e.includePrerelease === !!t.includePrerelease ? e : new L2(e.raw, t);
        if (e instanceof U2) return this.raw = e.value, this.set = [[e]], this.format(), this;
        if (this.options = t, this.loose = !!t.loose, this.includePrerelease = !!t.includePrerelease, this.raw = e, this.set = e.split(/\s*\|\|\s*/).map((n) => this.parseRange(n.trim())).filter((n) => n.length), !this.set.length) throw new TypeError(`Invalid SemVer Range: ${e}`);
        this.format();
      }
      format() {
        return this.range = this.set.map((e) => e.join(" ").trim()).join("||").trim(), this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(e) {
        let { loose: t } = this.options;
        e = e.trim();
        let n = t ? I2[y2.HYPHENRANGELOOSE] : I2[y2.HYPHENRANGE];
        e = e.replace(n, Fr(this.options.includePrerelease)), h2("hyphen replace", e), e = e.replace(I2[y2.COMPARATORTRIM], Sr), h2("comparator trim", e, I2[y2.COMPARATORTRIM]), e = (e = (e = e.replace(I2[y2.TILDETRIM], Nr)).replace(I2[y2.CARETTRIM], Ar)).split(/\s+/).join(" ");
        let o = t ? I2[y2.COMPARATORLOOSE] : I2[y2.COMPARATOR];
        return e.split(" ").map((s) => Cr(s, this.options)).join(" ").split(/\s+/).map((s) => Ur(s, this.options)).filter(this.options.loose ? (s) => !!s.match(o) : () => true).map((s) => new U2(s, this.options));
      }
      intersects(e, t) {
        if (!(e instanceof L2)) throw new TypeError("a Range is required");
        return this.set.some((n) => ut(n, t) && e.set.some((o) => ut(o, t) && n.every((s) => o.every((i) => s.intersects(i, t)))));
      }
      test(e) {
        if (!e) return false;
        if (typeof e == "string") try {
          e = new E2(e, this.options);
        } catch (t) {
          return false;
        }
        for (let t = 0; t < this.set.length; t++) if (Wr(this.set[t], e, this.options)) return true;
        return false;
      }
    };
    ({ re: I2, t: y2, comparatorTrimReplace: Sr, tildeTrimReplace: Nr, caretTrimReplace: Ar } = ae);
    ut = (r, e) => {
      let t = true, n = r.slice(), o = n.pop();
      for (; t && n.length; ) t = n.every((s) => o.intersects(s, e)), o = n.pop();
      return t;
    };
    Cr = (r, e) => (h2("comp", r, e), r = Or(r, e), h2("caret", r), r = $r(r, e), h2("tildes", r), r = kr(r, e), h2("xrange", r), r = qr(r, e), h2("stars", r), r);
    P2 = (r) => !r || r.toLowerCase() === "x" || r === "*";
    $r = (r, e) => r.trim().split(/\s+/).map((t) => Lr(t, e)).join(" ");
    Lr = (r, e) => {
      let t = e.loose ? I2[y2.TILDELOOSE] : I2[y2.TILDE];
      return r.replace(t, (n, o, s, i, a2) => {
        let c2;
        return h2("tilde", r, n, o, s, i, a2), P2(o) ? c2 = "" : P2(s) ? c2 = `>=${o}.0.0 <${+o + 1}.0.0-0` : P2(i) ? c2 = `>=${o}.${s}.0 <${o}.${+s + 1}.0-0` : a2 ? (h2("replaceTilde pr", a2), c2 = `>=${o}.${s}.${i}-${a2} <${o}.${+s + 1}.0-0`) : c2 = `>=${o}.${s}.${i} <${o}.${+s + 1}.0-0`, h2("tilde return", c2), c2;
      });
    };
    Or = (r, e) => r.trim().split(/\s+/).map((t) => _r(t, e)).join(" ");
    _r = (r, e) => {
      h2("caret", r, e);
      let t = e.loose ? I2[y2.CARETLOOSE] : I2[y2.CARET], n = e.includePrerelease ? "-0" : "";
      return r.replace(t, (o, s, i, a2, c2) => {
        let l2;
        return h2("caret", r, o, s, i, a2, c2), P2(s) ? l2 = "" : P2(i) ? l2 = `>=${s}.0.0${n} <${+s + 1}.0.0-0` : P2(a2) ? l2 = s === "0" ? `>=${s}.${i}.0${n} <${s}.${+i + 1}.0-0` : `>=${s}.${i}.0${n} <${+s + 1}.0.0-0` : c2 ? (h2("replaceCaret pr", c2), l2 = s === "0" ? i === "0" ? `>=${s}.${i}.${a2}-${c2} <${s}.${i}.${+a2 + 1}-0` : `>=${s}.${i}.${a2}-${c2} <${s}.${+i + 1}.0-0` : `>=${s}.${i}.${a2}-${c2} <${+s + 1}.0.0-0`) : (h2("no pr"), l2 = s === "0" ? i === "0" ? `>=${s}.${i}.${a2}${n} <${s}.${i}.${+a2 + 1}-0` : `>=${s}.${i}.${a2}${n} <${s}.${+i + 1}.0-0` : `>=${s}.${i}.${a2} <${+s + 1}.0.0-0`), h2("caret return", l2), l2;
      });
    };
    kr = (r, e) => (h2("replaceXRanges", r, e), r.split(/\s+/).map((t) => Dr(t, e)).join(" "));
    Dr = (r, e) => {
      r = r.trim();
      let t = e.loose ? I2[y2.XRANGELOOSE] : I2[y2.XRANGE];
      return r.replace(t, (n, o, s, i, a2, c2) => {
        h2("xRange", r, n, o, s, i, a2, c2);
        let l2 = P2(s), d = l2 || P2(i), p = d || P2(a2), M2 = p;
        return o === "=" && M2 && (o = ""), c2 = e.includePrerelease ? "-0" : "", l2 ? n = o === ">" || o === "<" ? "<0.0.0-0" : "*" : o && M2 ? (d && (i = 0), a2 = 0, o === ">" ? (o = ">=", d ? (s = +s + 1, i = 0, a2 = 0) : (i = +i + 1, a2 = 0)) : o === "<=" && (o = "<", d ? s = +s + 1 : i = +i + 1), o === "<" && (c2 = "-0"), n = `${o + s}.${i}.${a2}${c2}`) : d ? n = `>=${s}.0.0${c2} <${+s + 1}.0.0-0` : p && (n = `>=${s}.${i}.0${c2} <${s}.${+i + 1}.0-0`), h2("xRange return", n), n;
      });
    };
    qr = (r, e) => (h2("replaceStars", r, e), r.trim().replace(I2[y2.STAR], ""));
    Ur = (r, e) => (h2("replaceGTE0", r, e), r.trim().replace(I2[e.includePrerelease ? y2.GTE0PRE : y2.GTE0], ""));
    Fr = (r) => (e, t, n, o, s, i, a2, c2, l2, d, p, M2, v2) => `${t = P2(n) ? "" : P2(o) ? `>=${n}.0.0${r ? "-0" : ""}` : P2(s) ? `>=${n}.${o}.0${r ? "-0" : ""}` : i ? `>=${t}` : `>=${t}${r ? "-0" : ""}`} ${c2 = P2(l2) ? "" : P2(d) ? `<${+l2 + 1}.0.0-0` : P2(p) ? `<${l2}.${+d + 1}.0-0` : M2 ? `<=${l2}.${d}.${p}-${M2}` : r ? `<${l2}.${d}.${+p + 1}-0` : `<=${c2}`}`.trim();
    Wr = (r, e, t) => {
      for (let n = 0; n < r.length; n++) if (!r[n].test(e)) return false;
      if (e.prerelease.length && !t.includePrerelease) {
        for (let n = 0; n < r.length; n++) if (h2(r[n].semver), r[n].semver !== U2.ANY && r[n].semver.prerelease.length > 0) {
          let o = r[n].semver;
          if (o.major === e.major && o.minor === e.minor && o.patch === e.patch) return true;
        }
        return false;
      }
      return true;
    };
    ft = (r, e, t) => {
      try {
        e = new L2(e, t);
      } catch (n) {
        return false;
      }
      return e.test(r);
    };
    ({ MAX_LENGTH: Jr } = Fe);
    ({ re: pt, t: mt } = ae);
    Gr = (r, e) => {
      if (e && typeof e == "object" || (e = { loose: !!e, includePrerelease: false }), r instanceof E2) return r;
      if (typeof r != "string" || r.length > Jr || !(e.loose ? pt[mt.LOOSE] : pt[mt.FULL]).test(r)) return null;
      try {
        return new E2(r, e);
      } catch (t) {
        return null;
      }
    };
    Kr = Gr;
    ({ re: ge, t: ye } = ae);
    Et = (r, e) => {
      if (r instanceof E2) return r;
      if (typeof r == "number" && (r = String(r)), typeof r != "string") return null;
      let t = null;
      if ((e = e || {}).rtl) {
        let n;
        for (; (n = ge[ye.COERCERTL].exec(r)) && (!t || t.index + t[0].length !== r.length); ) t && n.index + n[0].length === t.index + t[0].length || (t = n), ge[ye.COERCERTL].lastIndex = n.index + n[1].length + n[2].length;
        ge[ye.COERCERTL].lastIndex = -1;
      } else t = r.match(ge[ye.COERCE]);
      return t === null ? null : Kr(`${t[2]}.${t[3] || "0"}.${t[4] || "0"}`, e);
    };
    m2 = {};
    vt = { "magic-sdk": "magic-sdk", "@magic-sdk/react-native": "magic-sdk-rn", "@magic-sdk/react-native-bare": "magic-sdk-rn-bare", "@magic-sdk/react-native-expo": "magic-sdk-rn-expo" };
    C2 = class extends Error {
      constructor(t, n) {
        super(`Magic SDK Error: [${t}] ${n}`);
        this.code = t;
        this.rawMessage = n;
        this.__proto__ = Error;
        Object.setPrototypeOf(this, C2.prototype);
      }
    };
    _2 = class extends Error {
      constructor(t) {
        super();
        this.__proto__ = Error;
        let n = Number(t == null ? void 0 : t.code);
        this.rawMessage = (t == null ? void 0 : t.message) || "Internal error", this.code = Rt(n) ? n : v.InternalError, this.message = `Magic RPC Error: [${this.code}] ${this.rawMessage}`, this.data = (t == null ? void 0 : t.data) || void 0, Object.setPrototypeOf(this, _2.prototype);
      }
    };
    F2 = class {
      constructor(e, t) {
        this.code = e;
        this.rawMessage = t;
        this.message = `Magic SDK Warning: [${e}] ${t}`;
      }
      log() {
        console.warn(this.message);
      }
    };
    Q2 = class extends Error {
      constructor(t, n, o, s) {
        super(`Magic Extension Error (${t.name}): [${n}] ${o}`);
        this.code = n;
        this.rawMessage = o;
        this.data = s;
        this.__proto__ = Error;
        Object.setPrototypeOf(this, Q2.prototype);
      }
    };
    le = class {
      constructor(e, t, n) {
        this.code = t;
        this.rawMessage = n;
        this.message = `Magic Extension Warning (${e.name}): [${t}] ${n}`;
      }
      log() {
        console.warn(this.message);
      }
    };
    tn = en();
    Nt = Symbol("Payload pre-processed by Magic SDK");
    J2 = class {
      constructor(e) {
        e instanceof J2 ? (this._jsonrpc = e.payload.jsonrpc, this._id = e.payload.id, this._result = e.payload.result, this._error = e.payload.error) : yt(e) ? (this._jsonrpc = e.jsonrpc, this._id = e.id, this._result = e.result, this._error = e.error) : (this._jsonrpc = e.jsonrpc, this._id = e.id, this._result = void 0, this._error = void 0);
      }
      applyError(e) {
        return this._error = e, this;
      }
      applyResult(e) {
        return this._result = e, this;
      }
      get hasError() {
        return typeof this._error != "undefined" && this._error !== null;
      }
      get hasResult() {
        return typeof this._result != "undefined";
      }
      get payload() {
        return { jsonrpc: this._jsonrpc, id: this._id, result: this._result, error: this._error };
      }
    };
    Lt = cr($t());
    Ge = class extends Lt.default {
    };
    Ot = Symbol("isPromiEvent");
    R2 = class {
      constructor(e) {
        this.sdk = e;
      }
      get overlay() {
        return this.sdk.overlay;
      }
      request(e) {
        if (this.sdk.thirdPartyWallets.isConnected && !M.includes(e.method)) return x2((i, a2) => {
          this.sdk.thirdPartyWallets.requestOverride(e).then(i).catch(a2);
        });
        let t = this.overlay.post(E.MAGIC_HANDLE_REQUEST, H2(e)), n = x2((s, i) => {
          t.then((a2) => {
            if (o(), a2.hasError) i(new _2(a2.payload.error));
            else if (a2.hasResult) s(a2.payload.result);
            else throw bt();
          }).catch((a2) => {
            o(), i(a2);
          });
        }), o = this.overlay.on(g.MAGIC_HANDLE_EVENT, (s) => {
          var a2;
          let { response: i } = s.data;
          if (i.id === e.id && ((a2 = i.result) == null ? void 0 : a2.event)) {
            let { event: c2, params: l2 = [] } = i.result;
            n.emit(c2, ...l2);
          }
        });
        return n;
      }
      createIntermediaryEvent(e, t) {
        return (o) => {
          let s = u2(f.IntermediaryEvent, [{ payloadId: t, eventType: e, args: o }]);
          this.request(s);
        };
      }
    };
    B2 = { "magic-sdk": "v18.0.0", "@magic-sdk/react-native": "v14.0.0", "@magic-sdk/react-native-bare": "v19.0.0", "@magic-sdk/react-native-expo": "v19.0.0" };
    we = class extends R2 {
      loginWithMagicLink(e) {
        let t = m2.sdkName === "@magic-sdk/react-native" || m2.sdkName === "@magic-sdk/react-native-bare" || m2.sdkName === "@magic-sdk/react-native-expo";
        if (t && kt(m2.version, 19)) throw new Error("loginWithMagicLink() is deprecated for this package, please utlize a passcode method like loginWithSMS or loginWithEmailOTP instead.");
        t && W2({ method: "auth.loginWithMagicLink()", removalVersions: B2, useInstead: "auth.loginWithEmailOTP()" }).log();
        let { email: n, showUI: o = true, redirectURI: s, overrides: i, lifespan: a2 } = e, c2 = u2(this.sdk.testMode ? f.LoginWithMagicLinkTestMode : f.LoginWithMagicLink, [{ email: n, showUI: o, redirectURI: s, overrides: i, lifespan: a2 }]);
        return this.request(c2);
      }
      loginWithSMS(e) {
        let { phoneNumber: t, showUI: n = true, lifespan: o } = e, s = u2(this.sdk.testMode ? f.LoginWithSmsTestMode : f.LoginWithSms, [{ phoneNumber: t, showUI: n, lifespan: o }]), i = this.request(s);
        return !n && i && (i.on(I.VerifySmsOtp, (a2) => {
          this.createIntermediaryEvent(I.VerifySmsOtp, s.id)(a2);
        }), i.on(I.Cancel, () => {
          this.createIntermediaryEvent(I.Cancel, s.id)();
        })), i;
      }
      loginWithEmailOTP(e) {
        let { email: t, showUI: n, deviceCheckUI: o, overrides: s, lifespan: i } = e, a2 = u2(this.sdk.testMode ? f.LoginWithEmailOTPTestMode : f.LoginWithEmailOTP, [{ email: t, showUI: n, deviceCheckUI: o, overrides: s, lifespan: i }]), c2 = this.request(a2);
        return !o && c2 && c2.on(T.Retry, () => {
          this.createIntermediaryEvent(T.Retry, a2.id)();
        }), !n && c2 && (c2.on(R.VerifyEmailOtp, (l2) => {
          this.createIntermediaryEvent(R.VerifyEmailOtp, a2.id)(l2);
        }), c2.on(R.VerifyMFACode, (l2) => {
          this.createIntermediaryEvent(R.VerifyMFACode, a2.id)(l2);
        }), c2.on(R.LostDevice, () => {
          this.createIntermediaryEvent(R.LostDevice, a2.id)();
        }), c2.on(R.VerifyRecoveryCode, (l2) => {
          this.createIntermediaryEvent(R.VerifyRecoveryCode, a2.id)(l2);
        }), c2.on(R.Cancel, () => {
          this.createIntermediaryEvent(R.Cancel, a2.id)();
        })), c2;
      }
      loginWithCredential(e) {
        let { credentialOrQueryString: t, lifespan: n } = e || {}, o = t != null ? t : "";
        if (!t && m2.platform === "web") {
          o = window.location.search;
          let i = window.location.origin + window.location.pathname;
          window.history.replaceState(null, "", i);
        }
        let s = u2(this.sdk.testMode ? f.LoginWithCredentialTestMode : f.LoginWithCredential, [o, n]);
        return this.request(s);
      }
      setAuthorizationToken(e) {
        let t = u2(f.SetAuthorizationToken, [{ jwt: e }]);
        return this.request(t);
      }
      updateEmailWithUI(e) {
        let { email: t, showUI: n = true } = e, o = u2(this.sdk.testMode ? f.UpdateEmailTestMode : f.UpdateEmail, [{ email: t, showUI: n }]), s = this.request(o);
        return n || (s.on(S.Retry, () => {
          this.createIntermediaryEvent(S.Retry, o.id)();
        }), s.on(S.Cancel, () => {
          this.createIntermediaryEvent(S.Cancel, o.id)();
        }), s.on(S.VerifyEmailOtp, (i) => {
          this.createIntermediaryEvent(S.VerifyEmailOtp, o.id)(i);
        }), s.on(S.VerifyMFACode, (i) => {
          this.createIntermediaryEvent(S.VerifyMFACode, o.id)(i);
        }), s.on(C.RetryWithNewEmail, (i) => {
          this.createIntermediaryEvent(C.RetryWithNewEmail, o.id)(i);
        }), s.on(C.Cancel, () => {
          this.createIntermediaryEvent(C.Cancel, o.id)();
        }), s.on(C.VerifyEmailOtp, (i) => {
          this.createIntermediaryEvent(C.VerifyEmailOtp, o.id)(i);
        })), s;
      }
    };
    ue = {};
    ir(ue, { clear: () => pn, getItem: () => b2, iterate: () => je, key: () => hn, keys: () => fn, length: () => mn, removeItem: () => k2, setItem: () => S2 });
    b2 = K("getItem");
    S2 = K("setItem");
    k2 = K("removeItem");
    pn = K("clear");
    mn = K("length");
    hn = K("key");
    fn = K("keys");
    je = K("iterate");
    Ve = "STORE_KEY_PRIVATE_KEY";
    Me = "STORE_KEY_PUBLIC_JWK";
    Ft = "ECDSA";
    En = "P-256";
    gn = { name: Ft, namedCurve: En };
    He = "ds";
    Be = "ek";
    Xe = "iv";
    ze = "AES-GCM";
    bn = 256;
    Ne = class extends R2 {
      constructor() {
        super(...arguments);
        this.localForageIsLoggedInKey = "magic_auth_is_logged_in";
        this.userLoggedOutCallbacks = [];
      }
      getIdToken(t) {
        let n = u2(this.sdk.testMode ? f.GetIdTokenTestMode : f.GetIdToken, [t]);
        return this.request(n);
      }
      generateIdToken(t) {
        let n = u2(this.sdk.testMode ? f.GenerateIdTokenTestMode : f.GenerateIdToken, [t]);
        return this.request(n);
      }
      getInfo() {
        let t = u2(f.GetInfo, []);
        return this.request(t);
      }
      isLoggedIn() {
        return x2((t, n) => f2(this, null, function* () {
          try {
            let o = false;
            this.sdk.useStorageCache && (o = (yield b2(this.localForageIsLoggedInKey)) === "true", o && t(true));
            let s = u2(this.sdk.testMode ? f.IsLoggedInTestMode : f.IsLoggedIn), i = yield this.request(s);
            this.sdk.useStorageCache && (i ? S2(this.localForageIsLoggedInKey, true) : k2(this.localForageIsLoggedInKey), o && !i && this.emitUserLoggedOut(true)), t(i);
          } catch (o) {
            n(o);
          }
        }));
      }
      logout() {
        return k2(this.localForageIsLoggedInKey), te(), x2((t, n) => f2(this, null, function* () {
          try {
            let o = u2(this.sdk.testMode ? f.LogoutTestMode : f.Logout), s = yield this.request(o);
            this.sdk.useStorageCache && this.emitUserLoggedOut(s), t(s);
          } catch (o) {
            n(o);
          }
        }));
      }
      requestInfoWithUI(t) {
        let n = u2(f.RequestUserInfoWithUI, t ? [t] : []);
        return this.request(n);
      }
      showSettings(t) {
        let { showUI: n = true } = t || {}, o = u2(this.sdk.testMode ? f.UserSettingsTestMode : f.UserSettings, [t]), s = this.request(o);
        return !n && s && (s.on(J.SendNewPhoneNumber, (i) => {
          this.createIntermediaryEvent(J.SendNewPhoneNumber, o.id)(i);
        }), s.on(J.SendOtpCode, (i) => {
          this.createIntermediaryEvent(J.SendOtpCode, o.id)(i);
        }), s.on(J.StartEditPhoneNumber, () => {
          this.createIntermediaryEvent(J.StartEditPhoneNumber, o.id)();
        }), s.on(J.Cancel, () => {
          this.createIntermediaryEvent(J.Cancel, o.id)();
        }), s.on(S.VerifyEmailOtp, (i) => {
          this.createIntermediaryEvent(S.VerifyEmailOtp, o.id)(i);
        })), s;
      }
      recoverAccount(t) {
        let { email: n, showUI: o } = t, s = u2(this.sdk.testMode ? f.RecoverAccountTestMode : f.RecoverAccount, [{ email: n, showUI: o }]), i = this.request(s);
        return !o && i && (i.on(P.Cancel, () => {
          this.createIntermediaryEvent(P.Cancel, s.id)();
        }), i.on(P.ResendSms, () => {
          this.createIntermediaryEvent(P.ResendSms, s.id)();
        }), i.on(P.VerifyOtp, (a2) => {
          this.createIntermediaryEvent(P.VerifyOtp, s.id)(a2);
        }), i.on(P.UpdateEmail, (a2) => {
          this.createIntermediaryEvent(P.UpdateEmail, s.id)(a2);
        }), i.on(C.Cancel, () => {
          this.createIntermediaryEvent(C.Cancel, s.id)();
        }), i.on(C.RetryWithNewEmail, (a2) => {
          this.createIntermediaryEvent(C.RetryWithNewEmail, s.id)(a2);
        }), i.on(C.VerifyEmailOtp, (a2) => {
          this.createIntermediaryEvent(C.VerifyEmailOtp, s.id)(a2);
        })), i;
      }
      revealPrivateKey() {
        let t = u2(f.RevealPK);
        return this.request(t);
      }
      getMetadata() {
        W2({ method: "user.getMetadata()", removalVersions: B2, useInstead: "user.getInfo()" }).log();
        let t = u2(this.sdk.testMode ? f.GetMetadataTestMode : f.GetMetadata);
        return this.request(t);
      }
      onUserLoggedOut(t) {
        this.userLoggedOutCallbacks.push(t);
      }
      enableMFA(t) {
        let { showUI: n = true } = t, o = u2(f.EnableMFA, [{ showUI: n }]), s = this.request(o);
        return !n && s && (s.on(L.VerifyMFACode, (i) => {
          this.createIntermediaryEvent(L.VerifyMFACode, o.id)(i);
        }), s.on(L.Cancel, () => {
          this.createIntermediaryEvent(L.Cancel, o.id)();
        })), s;
      }
      disableMFA(t) {
        let { showUI: n = true } = t, o = u2(f.DisableMFA, [{ showUI: n }]), s = this.request(o);
        return !n && s && (s.on(V.VerifyMFACode, (i) => {
          this.createIntermediaryEvent(V.VerifyMFACode, o.id)(i);
        }), s.on(V.LostDevice, (i) => {
          this.createIntermediaryEvent(V.LostDevice, o.id)(i);
        }), s.on(V.Cancel, () => {
          this.createIntermediaryEvent(V.Cancel, o.id)();
        })), s;
      }
      emitUserLoggedOut(t) {
        this.userLoggedOutCallbacks.forEach((n) => {
          n(t);
        });
      }
    };
    Ae = class extends R2 {
      connectWithUI(e) {
        let t = x2((n, o) => f2(this, null, function* () {
          try {
            let s = u2(f.Login, [q2({ enabledWallets: this.sdk.thirdPartyWallets.enabledWallets }, e)]), i = this.request(s);
            this.sdk.thirdPartyWallets.eventListeners.forEach(({ event: c2, callback: l2 }) => {
              i.on(c2, () => l2(s.id));
            }), i.on("id-token-created", (c2) => {
              t.emit("id-token-created", c2);
            });
            let a2 = yield i;
            a2.error && o(a2), n(a2);
          } catch (s) {
            o(s);
          }
        }));
        return t;
      }
      showUI(e) {
        return this.request(u2(f.ShowUI, [e]));
      }
      showAddress() {
        return this.request(u2(f.ShowAddress));
      }
      showSendTokensUI() {
        return this.request(u2(f.ShowSendTokensUI));
      }
      showOnRamp() {
        return this.request(u2(f.ShowOnRamp));
      }
      showNFTs() {
        return this.request(u2(f.ShowNFTs));
      }
      showBalances() {
        return this.request(u2(f.ShowBalances));
      }
      sendGaslessTransaction(e, t) {
        return this.request(u2(f.SendGaslessTransaction, [e, t]));
      }
      getInfo() {
        W2({ method: "wallet.getInfo()", removalVersions: B2, useInstead: "user.getInfo()" }).log();
        let e = u2(f.GetInfo, []);
        return this.request(e);
      }
      disconnect() {
        W2({ method: "wallet.disconnect()", removalVersions: B2, useInstead: "user.logout()" }).log(), te();
        let e = u2(f.Disconnect);
        return this.request(e);
      }
      requestUserInfoWithUI(e) {
        W2({ method: "wallet.requestUserInfoWithUI()", removalVersions: B2, useInstead: "user.requestUserInfoWithUI()" }).log();
        let t = u2(f.RequestUserInfoWithUI, e ? [e] : []);
        return this.request(t);
      }
    };
    $e = class extends R2 {
      constructor() {
        super(...arguments);
        this.eventListeners = [];
        this.enabledWallets = {};
        this.isConnected = false;
      }
      resetThirdPartyWalletState() {
        localStorage.removeItem(u.PROVIDER), localStorage.removeItem(u.ADDRESS), localStorage.removeItem(u.CHAIN_ID), this.isConnected = false;
      }
      requestOverride(t) {
        if (t.method === f.Login) return this.resetThirdPartyWalletState(), super.request(t);
        if (t.method === f.GetInfo) return this.getInfo(t);
        if (t.method === f.IsLoggedIn) return this.isLoggedIn(t);
        if (t.method === f.Logout) return this.logout(t);
        switch (localStorage.getItem(u.PROVIDER)) {
          case "web3modal":
            return this.web3modalRequest(t);
          default:
            return this.resetThirdPartyWalletState(), super.request(t);
        }
      }
      isLoggedIn(t) {
        switch (localStorage.getItem(u.PROVIDER)) {
          case "web3modal":
            return this.web3modalIsLoggedIn();
          default:
            return this.resetThirdPartyWalletState(), super.request(t);
        }
      }
      getInfo(t) {
        switch (localStorage.getItem(u.PROVIDER)) {
          case "web3modal":
            return this.web3modalGetInfo();
          default:
            return this.resetThirdPartyWalletState(), super.request(t);
        }
      }
      logout(t) {
        let n = localStorage.getItem(u.PROVIDER);
        switch (this.resetThirdPartyWalletState(), n) {
          case "web3modal":
            return this.web3modalLogout();
          default:
            return super.request(t);
        }
      }
      web3modalRequest(t) {
        return x2((n, o) => {
          this.sdk.web3modal.modal.getWalletProvider().request(t).then(n).catch(o);
        });
      }
      web3modalIsLoggedIn() {
        return x2((t) => {
          let n = this.sdk.web3modal.modal.getStatus();
          if (n === "connected" && t(true), n === "disconnected" && (this.resetThirdPartyWalletState(), t(false)), n === "reconnecting") {
            let o = this.sdk.web3modal.modal.subscribeProvider(({ status: s }) => {
              s === "connected" && (o(), t(true)), s === "disconnected" && (o(), this.resetThirdPartyWalletState(), t(false));
            });
          }
        });
      }
      formatWeb3modalGetInfoResponse() {
        var o;
        let t = (o = this.sdk.web3modal.modal.getWalletInfo()) == null ? void 0 : o.name, n = this.sdk.web3modal.modal.getAddress();
        return { publicAddress: n, email: null, issuer: `did:ethr:${n}`, phoneNumber: null, isMfaEnabled: false, recoveryFactors: [], walletType: t || "web3modal" };
      }
      web3modalGetInfo() {
        return x2((t, n) => {
          let o = this.sdk.web3modal.modal.getStatus();
          if (o === "connected" && t(this.formatWeb3modalGetInfoResponse()), o === "disconnected" && (this.resetThirdPartyWalletState(), n("Magic RPC Error: [-32603] Internal error: User denied account access.")), o === "reconnecting") {
            let s = this.sdk.web3modal.modal.subscribeProvider(({ status: i }) => {
              i === "connected" && (s(), t(this.formatWeb3modalGetInfoResponse())), i === "disconnected" && (s(), this.resetThirdPartyWalletState(), n("Magic RPC Error: [-32603] Internal error: User denied account access."));
            });
          }
        });
      }
      web3modalLogout() {
        return x2((t) => f2(this, null, function* () {
          try {
            yield this.sdk.web3modal.modal.disconnect();
          } catch (n) {
            console.error(n);
          }
          t(true);
        }));
      }
    };
    ({ createBoundEmitterMethod: Le, createChainingEmitterMethod: se } = be());
    Oe = class extends R2 {
      constructor() {
        super(...arguments);
        this.isMagic = true;
        this.on = se("on", this);
        this.once = se("once", this);
        this.addListener = se("addListener", this);
        this.off = se("off", this);
        this.removeListener = se("removeListener", this);
        this.removeAllListeners = se("removeAllListeners", this);
        this.emit = Le("emit");
        this.eventNames = Le("eventNames");
        this.listeners = Le("listeners");
        this.listenerCount = Le("listenerCount");
      }
      sendAsync(t, n) {
        if (!n) throw xt({ procedure: "Magic.rpcProvider.sendAsync", argument: 1, expected: "function", received: n === null ? "null" : typeof n });
        if (Array.isArray(t)) this.overlay.post(E.MAGIC_HANDLE_REQUEST, t.map((o) => {
          let s = H2(o);
          return this.prefixPayloadMethodForTestMode(s), s;
        })).then((o) => {
          n(null, o.map((s) => z(q2({}, s.payload), { error: s.hasError ? new _2(s.payload.error) : null })));
        });
        else {
          let o = H2(t);
          this.prefixPayloadMethodForTestMode(o), this.overlay.post(E.MAGIC_HANDLE_REQUEST, o).then((s) => {
            n(s.hasError ? new _2(s.payload.error) : null, s.payload);
          });
        }
      }
      send(t, n) {
        if (typeof t == "string") {
          let s = u2(t, Array.isArray(n) ? n : []);
          return this.request(s);
        }
        if (Array.isArray(t) || !!n) {
          this.sendAsync(t, n);
          return;
        }
        let o = Mt();
        return o.log(), new J2(t).applyError({ code: -32603, message: o.rawMessage }).payload;
      }
      enable() {
        let t = u2(f.Login);
        return this.request(t);
      }
      request(t) {
        return this.prefixPayloadMethodForTestMode(t), super.request(t);
      }
      prefixPayloadMethodForTestMode(t) {
        let n = "testMode/eth/";
        this.sdk.testMode && (t.method = `${n}${t.method}`);
      }
    };
    Xt = ["request", "overlay", "sdk"];
    _e = class extends R2 {
      constructor() {
        super(void 0);
        this.__sdk_access_field_descriptors__ = /* @__PURE__ */ new Map();
        this.__is_initialized__ = false;
        this.utils = { createPromiEvent: x2, isPromiEvent: _t, encodeJSON: Re, decodeJSON: gt, createJsonRpcRequestPayload: u2, standardizeJsonRpcRequestPayload: H2, storage: ue };
        let t = [this, ...Mn(this)];
        Xt.forEach((n) => {
          let o = t.map((c2) => Object.getOwnPropertyDescriptor(c2, n)), s = o.findIndex((c2) => !!c2), i = s > 0, a2 = o[s];
          a2 && (this.__sdk_access_field_descriptors__.set(n, { descriptor: a2, isPrototypeField: i }), Object.defineProperty(this, n, { configurable: true, get: () => {
            throw Pt(n);
          } }));
        });
      }
      init(t) {
        this.__is_initialized__ || (Xt.forEach((n) => {
          if (this.__sdk_access_field_descriptors__.has(n)) {
            let { descriptor: o, isPrototypeField: s } = this.__sdk_access_field_descriptors__.get(n);
            s ? delete this[n] : Object.defineProperty(this, n, o);
          }
        }), this.sdk = t, this.__is_initialized__ = true);
      }
      createDeprecationWarning(t) {
        let { method: n, removalVersion: o, useInstead: s } = t, i = s ? ` Use \`${s}\` instead.` : "", a2 = `\`${n}\` will be removed from this Extension in version \`${o}\`.${i}`;
        return new le(this, "DEPRECATION_NOTICE", a2);
      }
      createWarning(t, n) {
        return new le(this, t, n);
      }
      createError(t, n, o) {
        return new Q2(this, t, n, o);
      }
    };
    Qe = class extends _e {
    };
    D2 = class extends _e {
    };
    D2.Internal = Qe, D2.Anonymous = "anonymous extension";
    De = class extends R2 {
      purchase(e) {
        let t = u2(f.NFTPurchase, [e]);
        return this.request(t);
      }
      checkout(e) {
        let t = this.sdk.thirdPartyWallets.isConnected, n = u2(f.NFTCheckout, [z(q2({}, e), { walletProvider: t ? "web3modal" : "magic" })]), o = this.request(n);
        return t && (o.on(j.Initiated, (s) => f2(this, null, function* () {
          try {
            let i = yield this.request({ method: "eth_sendTransaction", params: [s] });
            this.createIntermediaryEvent(j.Success, n.id)(i);
          } catch (i) {
            this.createIntermediaryEvent(j.Failure, n.id)();
          }
        })), o.on(j.Disconnect, () => {
          this.sdk.thirdPartyWallets.resetThirdPartyWalletState(), o.emit("disconnect");
        })), o;
      }
      transfer(e) {
        let t = u2(f.NFTTransfer, [e]);
        return this.request(t);
      }
    };
    me = class {
      constructor(e, t) {
        this.apiKey = e;
        var i;
        if (!e) throw It();
        m2.platform === "react-native" && (t == null ? void 0 : t.endpoint) && St().log();
        let { defaultEndpoint: n, version: o } = m2;
        this.testMode = !!(t != null && t.testMode), this.useStorageCache = !!(t != null && t.useStorageCache), this.endpoint = Ye((i = t == null ? void 0 : t.endpoint) != null ? i : n).origin, this.auth = new we(this), this.user = new Ne(this), this.wallet = new Ae(this), this.nft = new De(this), this.thirdPartyWallets = new $e(this), this.rpcProvider = new Oe(this);
        let s = Nn.call(this, t);
        this.parameters = Re(z(q2({ API_KEY: this.apiKey, DOMAIN_ORIGIN: window.location ? window.location.origin : "", ETH_NETWORK: t == null ? void 0 : t.network, host: Ye(this.endpoint).host, sdk: vt[m2.sdkName], version: o, ext: ce(s) ? void 0 : s, locale: (t == null ? void 0 : t.locale) || "en_US" }, m2.bundleId ? { bundleId: m2.bundleId } : {}), { meta: t == null ? void 0 : t.meta })), this.networkHash = Sn(this.apiKey, t == null ? void 0 : t.network, ce(s) ? void 0 : s), t != null && t.deferPreload || this.preload();
      }
      get overlay() {
        if (!me.__overlays__.has(this.parameters)) {
          let e = new m2.ViewController(this.endpoint, this.parameters, this.networkHash);
          e.init(), me.__overlays__.set(this.parameters, e);
        }
        return me.__overlays__.get(this.parameters);
      }
      preload() {
        return f2(this, null, function* () {
          yield this.overlay.checkIsReadyForRequest;
        });
      }
    };
    qe = me;
    qe.__overlays__ = /* @__PURE__ */ new Map();
    et = class {
      constructor(e, t, n) {
        this.endpoint = e;
        this.parameters = t;
        this.networkHash = n;
        this.messageHandlers = /* @__PURE__ */ new Set();
        this.isConnectedToInternet = true;
        this.checkIsReadyForRequest = this.waitForReady(), this.isReadyForRequest = false, this.listen();
      }
      post(e, t) {
        return f2(this, null, function* () {
          return Ke((n, o) => f2(this, null, function* () {
            if (!this.isConnectedToInternet) {
              let d = Tt();
              o(d);
            }
            this.isReadyForRequest || (yield this.waitForReady());
            let s = [], i = Array.isArray(t) ? t.map((d) => d.id) : [], a2 = yield Ln(`${e}-${this.parameters}`, t, this.networkHash);
            yield this._post(a2);
            let c2 = (d) => (p) => {
              var tt2;
              let { id: M2, response: v2 } = $n(t, p);
              if (On(p), ((tt2 = v2 == null ? void 0 : v2.payload.error) == null ? void 0 : tt2.message) === "User denied account access.") te();
              else if (p.data.deviceShare) {
                let { deviceShare: Yt } = p.data;
                jt(Yt, this.networkHash);
              }
              M2 && v2 && Array.isArray(t) && i.includes(M2) ? (s.push(v2), s.length === t.length && (d(), n(s))) : M2 && v2 && !Array.isArray(t) && M2 === t.id && (d(), n(v2));
            }, l2 = this.on(g.MAGIC_HANDLE_RESPONSE, c2(() => l2()));
          }));
        });
      }
      on(e, t) {
        let n = t.bind(window), o = (s) => {
          s.data.msgType === `${e}-${this.parameters}` && n(s);
        };
        return this.messageHandlers.add(o), () => this.messageHandlers.delete(o);
      }
      waitForReady() {
        return new Promise((e) => {
          let t = this.on(g.MAGIC_OVERLAY_READY, () => {
            this.isReadyForRequest = true, e(), t();
          });
          setTimeout(() => {
            this.isReadyForRequest = true, e(), t();
          }, 15e3);
        });
      }
      listen() {
        this.on(g.MAGIC_HIDE_OVERLAY, () => {
          this.hideOverlay();
        }), this.on(g.MAGIC_SHOW_OVERLAY, () => {
          this.showOverlay();
        }), this.on(g.MAGIC_SEND_PRODUCT_ANNOUNCEMENT, (e) => {
          e.data.response.result.product_announcement && new F2(m.ProductAnnouncement, e.data.response.result.product_announcement).log();
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/@magic-sdk+commons@24.20.0_@magic-sdk+provider@28.20.0_localforage@1.10.0__@magic-sdk+types@24.18.1/node_modules/@magic-sdk/commons/dist/es/index.mjs
var init_es3 = __esm({
  "../../node_modules/.pnpm/@magic-sdk+commons@24.20.0_@magic-sdk+provider@28.20.0_localforage@1.10.0__@magic-sdk+types@24.18.1/node_modules/@magic-sdk/commons/dist/es/index.mjs"() {
    "use strict";
    init_es2();
    init_es();
  }
});

// ../../node_modules/.pnpm/magic-sdk@28.21.1/node_modules/magic-sdk/dist/es/index.mjs
var es_exports = {};
__export(es_exports, {
  AuthEventOnReceived: () => U,
  DeepLinkPage: () => x,
  DeviceVerificationEventEmit: () => T,
  DeviceVerificationEventOnReceived: () => O,
  DisableMFAEventEmit: () => V,
  DisableMFAEventOnReceived: () => D,
  EnableMFAEventEmit: () => L,
  EnableMFAEventOnReceived: () => w,
  EthChainType: () => G,
  Extension: () => D2,
  ExtensionError: () => Q2,
  ExtensionWarning: () => le,
  FarcasterLoginEventEmit: () => k,
  LocalStorageKeys: () => u,
  LoginWithEmailOTPEventEmit: () => R,
  LoginWithEmailOTPEventOnReceived: () => h,
  LoginWithMagicLinkEventEmit: () => y,
  LoginWithMagicLinkEventOnReceived: () => A,
  LoginWithSmsOTPEventEmit: () => I,
  LoginWithSmsOTPEventOnReceived: () => N,
  Magic: () => Rt2,
  MagicIncomingWindowMessage: () => g,
  MagicOutgoingWindowMessage: () => E,
  MagicPayloadMethod: () => f,
  NftCheckoutIntermediaryEvents: () => j,
  RPCError: () => _2,
  RPCErrorCode: () => v,
  RecencyCheckEventEmit: () => S,
  RecencyCheckEventOnReceived: () => b,
  RecoverAccountEventEmit: () => P,
  RecoverAccountEventOnReceived: () => B,
  RecoveryFactorEventEmit: () => J,
  RecoveryFactorEventOnReceived: () => W,
  RecoveryMethodType: () => Y,
  SDKError: () => C2,
  SDKErrorCode: () => l,
  SDKWarning: () => F2,
  SDKWarningCode: () => m,
  ThirdPartyWalletEvents: () => _,
  UiEventsEmit: () => X,
  UpdateEmailEventEmit: () => C,
  UpdateEmailEventOnReceived: () => F,
  UserEventsEmit: () => H,
  UserEventsOnReceived: () => q,
  WalletEventOnReceived: () => Q,
  isPromiEvent: () => _t,
  routeToMagicMethods: () => M
});
function lt2(b3) {
  for (let [T2, _3] of Object.entries(ct2)) b3.style[T2] = _3;
}
function dt2(b3) {
  let T2 = [].slice.call(document.querySelectorAll(".magic-iframe"));
  return Boolean(T2.find((_3) => _3.src.includes(b3)));
}
var et2, $e2, rt2, tt, nt2, it2, ve2, Je, ot2, Ze, re, ke, rr2, ge2, Ne2, ct2, ir2, or2, vt2, ht2, mt2, pe2, Rt2;
var init_es4 = __esm({
  "../../node_modules/.pnpm/magic-sdk@28.21.1/node_modules/magic-sdk/dist/es/index.mjs"() {
    "use strict";
    init_es2();
    init_es2();
    init_es();
    init_es3();
    et2 = Object.create;
    $e2 = Object.defineProperty;
    rt2 = Object.getOwnPropertyDescriptor;
    tt = Object.getOwnPropertyNames;
    nt2 = Object.getPrototypeOf;
    it2 = Object.prototype.hasOwnProperty;
    ve2 = ((b3) => typeof __require != "undefined" ? __require : typeof Proxy != "undefined" ? new Proxy(b3, { get: (T2, _3) => (typeof __require != "undefined" ? __require : T2)[_3] }) : b3)(function(b3) {
      if (typeof __require != "undefined") return __require.apply(this, arguments);
      throw new Error('Dynamic require of "' + b3 + '" is not supported');
    });
    Je = (b3, T2) => () => (T2 || b3((T2 = { exports: {} }).exports, T2), T2.exports);
    ot2 = (b3, T2, _3, O3) => {
      if (T2 && typeof T2 == "object" || typeof T2 == "function") for (let R3 of tt(T2)) !it2.call(b3, R3) && R3 !== _3 && $e2(b3, R3, { get: () => T2[R3], enumerable: !(O3 = rt2(T2, R3)) || O3.enumerable });
      return b3;
    };
    Ze = (b3, T2, _3) => (_3 = b3 != null ? et2(nt2(b3)) : {}, ot2(T2 || !b3 || !b3.__esModule ? $e2(_3, "default", { value: b3, enumerable: true }) : _3, b3));
    re = (b3, T2, _3) => new Promise((O3, R3) => {
      var j2 = (S3) => {
        try {
          Y3(_3.next(S3));
        } catch (M2) {
          R3(M2);
        }
      }, P3 = (S3) => {
        try {
          Y3(_3.throw(S3));
        } catch (M2) {
          R3(M2);
        }
      }, Y3 = (S3) => S3.done ? O3(S3.value) : Promise.resolve(S3.value).then(j2, P3);
      Y3((_3 = _3.apply(b3, T2)).next());
    });
    ke = Je((qe2, De2) => {
      (function(b3) {
        if (typeof qe2 == "object" && typeof De2 < "u") De2.exports = b3();
        else if (typeof define == "function" && define.amd) define([], b3);
        else {
          var T2;
          typeof window < "u" ? T2 = window : typeof global < "u" ? T2 = global : typeof self < "u" ? T2 = self : T2 = this, T2.localforage = b3();
        }
      })(function() {
        var b3, T2, _3;
        return function O3(R3, j2, P3) {
          function Y3(K2, J3) {
            if (!j2[K2]) {
              if (!R3[K2]) {
                var m3 = typeof ve2 == "function" && ve2;
                if (!J3 && m3) return m3(K2, true);
                if (S3) return S3(K2, true);
                var w2 = new Error("Cannot find module '" + K2 + "'");
                throw w2.code = "MODULE_NOT_FOUND", w2;
              }
              var B3 = j2[K2] = { exports: {} };
              R3[K2][0].call(B3.exports, function(z2) {
                var Z = R3[K2][1][z2];
                return Y3(Z || z2);
              }, B3, B3.exports, O3, R3, j2, P3);
            }
            return j2[K2].exports;
          }
          for (var S3 = typeof ve2 == "function" && ve2, M2 = 0; M2 < P3.length; M2++) Y3(P3[M2]);
          return Y3;
        }({ 1: [function(O3, R3, j2) {
          (function(P3) {
            "use strict";
            var Y3 = P3.MutationObserver || P3.WebKitMutationObserver, S3;
            if (Y3) {
              var M2 = 0, K2 = new Y3(z2), J3 = P3.document.createTextNode("");
              K2.observe(J3, { characterData: true }), S3 = function() {
                J3.data = M2 = ++M2 % 2;
              };
            } else if (!P3.setImmediate && typeof P3.MessageChannel < "u") {
              var m3 = new P3.MessageChannel();
              m3.port1.onmessage = z2, S3 = function() {
                m3.port2.postMessage(0);
              };
            } else "document" in P3 && "onreadystatechange" in P3.document.createElement("script") ? S3 = function() {
              var F3 = P3.document.createElement("script");
              F3.onreadystatechange = function() {
                z2(), F3.onreadystatechange = null, F3.parentNode.removeChild(F3), F3 = null;
              }, P3.document.documentElement.appendChild(F3);
            } : S3 = function() {
              setTimeout(z2, 0);
            };
            var w2, B3 = [];
            function z2() {
              w2 = true;
              for (var F3, k3, U3 = B3.length; U3; ) {
                for (k3 = B3, B3 = [], F3 = -1; ++F3 < U3; ) k3[F3]();
                U3 = B3.length;
              }
              w2 = false;
            }
            R3.exports = Z;
            function Z(F3) {
              B3.push(F3) === 1 && !w2 && S3();
            }
          }).call(this, typeof global < "u" ? global : typeof self < "u" ? self : typeof window < "u" ? window : {});
        }, {}], 2: [function(O3, R3, j2) {
          "use strict";
          var P3 = O3(1);
          function Y3() {
          }
          var S3 = {}, M2 = ["REJECTED"], K2 = ["FULFILLED"], J3 = ["PENDING"];
          R3.exports = m3;
          function m3(h3) {
            if (typeof h3 != "function") throw new TypeError("resolver must be a function");
            this.state = J3, this.queue = [], this.outcome = void 0, h3 !== Y3 && Z(this, h3);
          }
          m3.prototype.catch = function(h3) {
            return this.then(null, h3);
          }, m3.prototype.then = function(h3, D3) {
            if (typeof h3 != "function" && this.state === K2 || typeof D3 != "function" && this.state === M2) return this;
            var E3 = new this.constructor(Y3);
            if (this.state !== J3) {
              var C3 = this.state === K2 ? h3 : D3;
              B3(E3, C3, this.outcome);
            } else this.queue.push(new w2(E3, h3, D3));
            return E3;
          };
          function w2(h3, D3, E3) {
            this.promise = h3, typeof D3 == "function" && (this.onFulfilled = D3, this.callFulfilled = this.otherCallFulfilled), typeof E3 == "function" && (this.onRejected = E3, this.callRejected = this.otherCallRejected);
          }
          w2.prototype.callFulfilled = function(h3) {
            S3.resolve(this.promise, h3);
          }, w2.prototype.otherCallFulfilled = function(h3) {
            B3(this.promise, this.onFulfilled, h3);
          }, w2.prototype.callRejected = function(h3) {
            S3.reject(this.promise, h3);
          }, w2.prototype.otherCallRejected = function(h3) {
            B3(this.promise, this.onRejected, h3);
          };
          function B3(h3, D3, E3) {
            P3(function() {
              var C3;
              try {
                C3 = D3(E3);
              } catch (G2) {
                return S3.reject(h3, G2);
              }
              C3 === h3 ? S3.reject(h3, new TypeError("Cannot resolve promise with itself")) : S3.resolve(h3, C3);
            });
          }
          S3.resolve = function(h3, D3) {
            var E3 = F3(z2, D3);
            if (E3.status === "error") return S3.reject(h3, E3.value);
            var C3 = E3.value;
            if (C3) Z(h3, C3);
            else {
              h3.state = K2, h3.outcome = D3;
              for (var G2 = -1, X2 = h3.queue.length; ++G2 < X2; ) h3.queue[G2].callFulfilled(D3);
            }
            return h3;
          }, S3.reject = function(h3, D3) {
            h3.state = M2, h3.outcome = D3;
            for (var E3 = -1, C3 = h3.queue.length; ++E3 < C3; ) h3.queue[E3].callRejected(D3);
            return h3;
          };
          function z2(h3) {
            var D3 = h3 && h3.then;
            if (h3 && (typeof h3 == "object" || typeof h3 == "function") && typeof D3 == "function") return function() {
              D3.apply(h3, arguments);
            };
          }
          function Z(h3, D3) {
            var E3 = false;
            function C3($) {
              E3 || (E3 = true, S3.reject(h3, $));
            }
            function G2($) {
              E3 || (E3 = true, S3.resolve(h3, $));
            }
            function X2() {
              D3(G2, C3);
            }
            var Q3 = F3(X2);
            Q3.status === "error" && C3(Q3.value);
          }
          function F3(h3, D3) {
            var E3 = {};
            try {
              E3.value = h3(D3), E3.status = "success";
            } catch (C3) {
              E3.status = "error", E3.value = C3;
            }
            return E3;
          }
          m3.resolve = k3;
          function k3(h3) {
            return h3 instanceof this ? h3 : S3.resolve(new this(Y3), h3);
          }
          m3.reject = U3;
          function U3(h3) {
            var D3 = new this(Y3);
            return S3.reject(D3, h3);
          }
          m3.all = fe2;
          function fe2(h3) {
            var D3 = this;
            if (Object.prototype.toString.call(h3) !== "[object Array]") return this.reject(new TypeError("must be an array"));
            var E3 = h3.length, C3 = false;
            if (!E3) return this.resolve([]);
            for (var G2 = new Array(E3), X2 = 0, Q3 = -1, $ = new this(Y3); ++Q3 < E3; ) ee(h3[Q3], Q3);
            return $;
            function ee(oe2, a2) {
              D3.resolve(oe2).then(u3, function(v2) {
                C3 || (C3 = true, S3.reject($, v2));
              });
              function u3(v2) {
                G2[a2] = v2, ++X2 === E3 && !C3 && (C3 = true, S3.resolve($, G2));
              }
            }
          }
          m3.race = te2;
          function te2(h3) {
            var D3 = this;
            if (Object.prototype.toString.call(h3) !== "[object Array]") return this.reject(new TypeError("must be an array"));
            var E3 = h3.length, C3 = false;
            if (!E3) return this.resolve([]);
            for (var G2 = -1, X2 = new this(Y3); ++G2 < E3; ) Q3(h3[G2]);
            return X2;
            function Q3($) {
              D3.resolve($).then(function(ee) {
                C3 || (C3 = true, S3.resolve(X2, ee));
              }, function(ee) {
                C3 || (C3 = true, S3.reject(X2, ee));
              });
            }
          }
        }, { 1: 1 }], 3: [function(O3, R3, j2) {
          (function(P3) {
            "use strict";
            typeof P3.Promise != "function" && (P3.Promise = O3(2));
          }).call(this, typeof global < "u" ? global : typeof self < "u" ? self : typeof window < "u" ? window : {});
        }, { 2: 2 }], 4: [function(O3, R3, j2) {
          "use strict";
          var P3 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
            return typeof e;
          } : function(e) {
            return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
          };
          function Y3(e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
          }
          function S3() {
            try {
              if (typeof indexedDB < "u") return indexedDB;
              if (typeof webkitIndexedDB < "u") return webkitIndexedDB;
              if (typeof mozIndexedDB < "u") return mozIndexedDB;
              if (typeof OIndexedDB < "u") return OIndexedDB;
              if (typeof msIndexedDB < "u") return msIndexedDB;
            } catch {
              return;
            }
          }
          var M2 = S3();
          function K2() {
            try {
              if (!M2 || !M2.open) return false;
              var e = typeof openDatabase < "u" && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform), t = typeof fetch == "function" && fetch.toString().indexOf("[native code") !== -1;
              return (!e || t) && typeof indexedDB < "u" && typeof IDBKeyRange < "u";
            } catch {
              return false;
            }
          }
          function J3(e, t) {
            e = e || [], t = t || {};
            try {
              return new Blob(e, t);
            } catch (n) {
              if (n.name !== "TypeError") throw n;
              for (var r = typeof BlobBuilder < "u" ? BlobBuilder : typeof MSBlobBuilder < "u" ? MSBlobBuilder : typeof MozBlobBuilder < "u" ? MozBlobBuilder : WebKitBlobBuilder, i = new r(), o = 0; o < e.length; o += 1) i.append(e[o]);
              return i.getBlob(t.type);
            }
          }
          typeof Promise > "u" && O3(3);
          var m3 = Promise;
          function w2(e, t) {
            t && e.then(function(r) {
              t(null, r);
            }, function(r) {
              t(r);
            });
          }
          function B3(e, t, r) {
            typeof t == "function" && e.then(t), typeof r == "function" && e.catch(r);
          }
          function z2(e) {
            return typeof e != "string" && (console.warn(e + " used as a key, but it is not a string."), e = String(e)), e;
          }
          function Z() {
            if (arguments.length && typeof arguments[arguments.length - 1] == "function") return arguments[arguments.length - 1];
          }
          var F3 = "local-forage-detect-blob-support", k3 = void 0, U3 = {}, fe2 = Object.prototype.toString, te2 = "readonly", h3 = "readwrite";
          function D3(e) {
            for (var t = e.length, r = new ArrayBuffer(t), i = new Uint8Array(r), o = 0; o < t; o++) i[o] = e.charCodeAt(o);
            return r;
          }
          function E3(e) {
            return new m3(function(t) {
              var r = e.transaction(F3, h3), i = J3([""]);
              r.objectStore(F3).put(i, "key"), r.onabort = function(o) {
                o.preventDefault(), o.stopPropagation(), t(false);
              }, r.oncomplete = function() {
                var o = navigator.userAgent.match(/Chrome\/(\d+)/), n = navigator.userAgent.match(/Edge\//);
                t(n || !o || parseInt(o[1], 10) >= 43);
              };
            }).catch(function() {
              return false;
            });
          }
          function C3(e) {
            return typeof k3 == "boolean" ? m3.resolve(k3) : E3(e).then(function(t) {
              return k3 = t, k3;
            });
          }
          function G2(e) {
            var t = U3[e.name], r = {};
            r.promise = new m3(function(i, o) {
              r.resolve = i, r.reject = o;
            }), t.deferredOperations.push(r), t.dbReady ? t.dbReady = t.dbReady.then(function() {
              return r.promise;
            }) : t.dbReady = r.promise;
          }
          function X2(e) {
            var t = U3[e.name], r = t.deferredOperations.pop();
            if (r) return r.resolve(), r.promise;
          }
          function Q3(e, t) {
            var r = U3[e.name], i = r.deferredOperations.pop();
            if (i) return i.reject(t), i.promise;
          }
          function $(e, t) {
            return new m3(function(r, i) {
              if (U3[e.name] = U3[e.name] || V2(), e.db) if (t) G2(e), e.db.close();
              else return r(e.db);
              var o = [e.name];
              t && o.push(e.version);
              var n = M2.open.apply(M2, o);
              t && (n.onupgradeneeded = function(f3) {
                var s = n.result;
                try {
                  s.createObjectStore(e.storeName), f3.oldVersion <= 1 && s.createObjectStore(F3);
                } catch (c2) {
                  if (c2.name === "ConstraintError") console.warn('The database "' + e.name + '" has been upgraded from version ' + f3.oldVersion + " to version " + f3.newVersion + ', but the storage "' + e.storeName + '" already exists.');
                  else throw c2;
                }
              }), n.onerror = function(f3) {
                f3.preventDefault(), i(n.error);
              }, n.onsuccess = function() {
                var f3 = n.result;
                f3.onversionchange = function(s) {
                  s.target.close();
                }, r(f3), X2(e);
              };
            });
          }
          function ee(e) {
            return $(e, false);
          }
          function oe2(e) {
            return $(e, true);
          }
          function a2(e, t) {
            if (!e.db) return true;
            var r = !e.db.objectStoreNames.contains(e.storeName), i = e.version < e.db.version, o = e.version > e.db.version;
            if (i && (e.version !== t && console.warn('The database "' + e.name + `" can't be downgraded from version ` + e.db.version + " to version " + e.version + "."), e.version = e.db.version), o || r) {
              if (r) {
                var n = e.db.version + 1;
                n > e.version && (e.version = n);
              }
              return true;
            }
            return false;
          }
          function u3(e) {
            return new m3(function(t, r) {
              var i = new FileReader();
              i.onerror = r, i.onloadend = function(o) {
                var n = btoa(o.target.result || "");
                t({ __local_forage_encoded_blob: true, data: n, type: e.type });
              }, i.readAsBinaryString(e);
            });
          }
          function v2(e) {
            var t = D3(atob(e.data));
            return J3([t], { type: e.type });
          }
          function p(e) {
            return e && e.__local_forage_encoded_blob;
          }
          function g2(e) {
            var t = this, r = t._initReady().then(function() {
              var i = U3[t._dbInfo.name];
              if (i && i.dbReady) return i.dbReady;
            });
            return B3(r, e, e), r;
          }
          function I3(e) {
            G2(e);
            for (var t = U3[e.name], r = t.forages, i = 0; i < r.length; i++) {
              var o = r[i];
              o._dbInfo.db && (o._dbInfo.db.close(), o._dbInfo.db = null);
            }
            return e.db = null, ee(e).then(function(n) {
              return e.db = n, a2(e) ? oe2(e) : n;
            }).then(function(n) {
              e.db = t.db = n;
              for (var f3 = 0; f3 < r.length; f3++) r[f3]._dbInfo.db = n;
            }).catch(function(n) {
              throw Q3(e, n), n;
            });
          }
          function N2(e, t, r, i) {
            i === void 0 && (i = 1);
            try {
              var o = e.db.transaction(e.storeName, t);
              r(null, o);
            } catch (n) {
              if (i > 0 && (!e.db || n.name === "InvalidStateError" || n.name === "NotFoundError")) return m3.resolve().then(function() {
                if (!e.db || n.name === "NotFoundError" && !e.db.objectStoreNames.contains(e.storeName) && e.version <= e.db.version) return e.db && (e.version = e.db.version + 1), oe2(e);
              }).then(function() {
                return I3(e).then(function() {
                  N2(e, t, r, i - 1);
                });
              }).catch(r);
              r(n);
            }
          }
          function V2() {
            return { forages: [], db: null, dbReady: null, deferredOperations: [] };
          }
          function se2(e) {
            var t = this, r = { db: null };
            if (e) for (var i in e) r[i] = e[i];
            var o = U3[r.name];
            o || (o = V2(), U3[r.name] = o), o.forages.push(t), t._initReady || (t._initReady = t.ready, t.ready = g2);
            var n = [];
            function f3() {
              return m3.resolve();
            }
            for (var s = 0; s < o.forages.length; s++) {
              var c2 = o.forages[s];
              c2 !== t && n.push(c2._initReady().catch(f3));
            }
            var l2 = o.forages.slice(0);
            return m3.all(n).then(function() {
              return r.db = o.db, ee(r);
            }).then(function(d) {
              return r.db = d, a2(r, t._defaultConfig.version) ? oe2(r) : d;
            }).then(function(d) {
              r.db = o.db = d, t._dbInfo = r;
              for (var y3 = 0; y3 < l2.length; y3++) {
                var A2 = l2[y3];
                A2 !== t && (A2._dbInfo.db = r.db, A2._dbInfo.version = r.version);
              }
            });
          }
          function ae2(e, t) {
            var r = this;
            e = z2(e);
            var i = new m3(function(o, n) {
              r.ready().then(function() {
                N2(r._dbInfo, te2, function(f3, s) {
                  if (f3) return n(f3);
                  try {
                    var c2 = s.objectStore(r._dbInfo.storeName), l2 = c2.get(e);
                    l2.onsuccess = function() {
                      var d = l2.result;
                      d === void 0 && (d = null), p(d) && (d = v2(d)), o(d);
                    }, l2.onerror = function() {
                      n(l2.error);
                    };
                  } catch (d) {
                    n(d);
                  }
                });
              }).catch(n);
            });
            return w2(i, t), i;
          }
          function ce2(e, t) {
            var r = this, i = new m3(function(o, n) {
              r.ready().then(function() {
                N2(r._dbInfo, te2, function(f3, s) {
                  if (f3) return n(f3);
                  try {
                    var c2 = s.objectStore(r._dbInfo.storeName), l2 = c2.openCursor(), d = 1;
                    l2.onsuccess = function() {
                      var y3 = l2.result;
                      if (y3) {
                        var A2 = y3.value;
                        p(A2) && (A2 = v2(A2));
                        var x3 = e(A2, y3.key, d++);
                        x3 !== void 0 ? o(x3) : y3.continue();
                      } else o();
                    }, l2.onerror = function() {
                      n(l2.error);
                    };
                  } catch (y3) {
                    n(y3);
                  }
                });
              }).catch(n);
            });
            return w2(i, t), i;
          }
          function ar2(e, t, r) {
            var i = this;
            e = z2(e);
            var o = new m3(function(n, f3) {
              var s;
              i.ready().then(function() {
                return s = i._dbInfo, fe2.call(t) === "[object Blob]" ? C3(s.db).then(function(c2) {
                  return c2 ? t : u3(t);
                }) : t;
              }).then(function(c2) {
                N2(i._dbInfo, h3, function(l2, d) {
                  if (l2) return f3(l2);
                  try {
                    var y3 = d.objectStore(i._dbInfo.storeName);
                    c2 === null && (c2 = void 0);
                    var A2 = y3.put(c2, e);
                    d.oncomplete = function() {
                      c2 === void 0 && (c2 = null), n(c2);
                    }, d.onabort = d.onerror = function() {
                      var x3 = A2.error ? A2.error : A2.transaction.error;
                      f3(x3);
                    };
                  } catch (x3) {
                    f3(x3);
                  }
                });
              }).catch(f3);
            });
            return w2(o, r), o;
          }
          function fr2(e, t) {
            var r = this;
            e = z2(e);
            var i = new m3(function(o, n) {
              r.ready().then(function() {
                N2(r._dbInfo, h3, function(f3, s) {
                  if (f3) return n(f3);
                  try {
                    var c2 = s.objectStore(r._dbInfo.storeName), l2 = c2.delete(e);
                    s.oncomplete = function() {
                      o();
                    }, s.onerror = function() {
                      n(l2.error);
                    }, s.onabort = function() {
                      var d = l2.error ? l2.error : l2.transaction.error;
                      n(d);
                    };
                  } catch (d) {
                    n(d);
                  }
                });
              }).catch(n);
            });
            return w2(i, t), i;
          }
          function sr2(e) {
            var t = this, r = new m3(function(i, o) {
              t.ready().then(function() {
                N2(t._dbInfo, h3, function(n, f3) {
                  if (n) return o(n);
                  try {
                    var s = f3.objectStore(t._dbInfo.storeName), c2 = s.clear();
                    f3.oncomplete = function() {
                      i();
                    }, f3.onabort = f3.onerror = function() {
                      var l2 = c2.error ? c2.error : c2.transaction.error;
                      o(l2);
                    };
                  } catch (l2) {
                    o(l2);
                  }
                });
              }).catch(o);
            });
            return w2(r, e), r;
          }
          function ur2(e) {
            var t = this, r = new m3(function(i, o) {
              t.ready().then(function() {
                N2(t._dbInfo, te2, function(n, f3) {
                  if (n) return o(n);
                  try {
                    var s = f3.objectStore(t._dbInfo.storeName), c2 = s.count();
                    c2.onsuccess = function() {
                      i(c2.result);
                    }, c2.onerror = function() {
                      o(c2.error);
                    };
                  } catch (l2) {
                    o(l2);
                  }
                });
              }).catch(o);
            });
            return w2(r, e), r;
          }
          function cr2(e, t) {
            var r = this, i = new m3(function(o, n) {
              if (e < 0) {
                o(null);
                return;
              }
              r.ready().then(function() {
                N2(r._dbInfo, te2, function(f3, s) {
                  if (f3) return n(f3);
                  try {
                    var c2 = s.objectStore(r._dbInfo.storeName), l2 = false, d = c2.openKeyCursor();
                    d.onsuccess = function() {
                      var y3 = d.result;
                      if (!y3) {
                        o(null);
                        return;
                      }
                      e === 0 || l2 ? o(y3.key) : (l2 = true, y3.advance(e));
                    }, d.onerror = function() {
                      n(d.error);
                    };
                  } catch (y3) {
                    n(y3);
                  }
                });
              }).catch(n);
            });
            return w2(i, t), i;
          }
          function lr2(e) {
            var t = this, r = new m3(function(i, o) {
              t.ready().then(function() {
                N2(t._dbInfo, te2, function(n, f3) {
                  if (n) return o(n);
                  try {
                    var s = f3.objectStore(t._dbInfo.storeName), c2 = s.openKeyCursor(), l2 = [];
                    c2.onsuccess = function() {
                      var d = c2.result;
                      if (!d) {
                        i(l2);
                        return;
                      }
                      l2.push(d.key), d.continue();
                    }, c2.onerror = function() {
                      o(c2.error);
                    };
                  } catch (d) {
                    o(d);
                  }
                });
              }).catch(o);
            });
            return w2(r, e), r;
          }
          function dr2(e, t) {
            t = Z.apply(this, arguments);
            var r = this.config();
            e = typeof e != "function" && e || {}, e.name || (e.name = e.name || r.name, e.storeName = e.storeName || r.storeName);
            var i = this, o;
            if (!e.name) o = m3.reject("Invalid arguments");
            else {
              var n = e.name === r.name && i._dbInfo.db, f3 = n ? m3.resolve(i._dbInfo.db) : ee(e).then(function(s) {
                var c2 = U3[e.name], l2 = c2.forages;
                c2.db = s;
                for (var d = 0; d < l2.length; d++) l2[d]._dbInfo.db = s;
                return s;
              });
              e.storeName ? o = f3.then(function(s) {
                if (!!s.objectStoreNames.contains(e.storeName)) {
                  var c2 = s.version + 1;
                  G2(e);
                  var l2 = U3[e.name], d = l2.forages;
                  s.close();
                  for (var y3 = 0; y3 < d.length; y3++) {
                    var A2 = d[y3];
                    A2._dbInfo.db = null, A2._dbInfo.version = c2;
                  }
                  var x3 = new m3(function(L3, H3) {
                    var W3 = M2.open(e.name, c2);
                    W3.onerror = function(q3) {
                      var de = W3.result;
                      de.close(), H3(q3);
                    }, W3.onupgradeneeded = function() {
                      var q3 = W3.result;
                      q3.deleteObjectStore(e.storeName);
                    }, W3.onsuccess = function() {
                      var q3 = W3.result;
                      q3.close(), L3(q3);
                    };
                  });
                  return x3.then(function(L3) {
                    l2.db = L3;
                    for (var H3 = 0; H3 < d.length; H3++) {
                      var W3 = d[H3];
                      W3._dbInfo.db = L3, X2(W3._dbInfo);
                    }
                  }).catch(function(L3) {
                    throw (Q3(e, L3) || m3.resolve()).catch(function() {
                    }), L3;
                  });
                }
              }) : o = f3.then(function(s) {
                G2(e);
                var c2 = U3[e.name], l2 = c2.forages;
                s.close();
                for (var d = 0; d < l2.length; d++) {
                  var y3 = l2[d];
                  y3._dbInfo.db = null;
                }
                var A2 = new m3(function(x3, L3) {
                  var H3 = M2.deleteDatabase(e.name);
                  H3.onerror = function() {
                    var W3 = H3.result;
                    W3 && W3.close(), L3(H3.error);
                  }, H3.onblocked = function() {
                    console.warn('dropInstance blocked for database "' + e.name + '" until all open connections are closed');
                  }, H3.onsuccess = function() {
                    var W3 = H3.result;
                    W3 && W3.close(), x3(W3);
                  };
                });
                return A2.then(function(x3) {
                  c2.db = x3;
                  for (var L3 = 0; L3 < l2.length; L3++) {
                    var H3 = l2[L3];
                    X2(H3._dbInfo);
                  }
                }).catch(function(x3) {
                  throw (Q3(e, x3) || m3.resolve()).catch(function() {
                  }), x3;
                });
              });
            }
            return w2(o, t), o;
          }
          var vr2 = { _driver: "asyncStorage", _initStorage: se2, _support: K2(), iterate: ce2, getItem: ae2, setItem: ar2, removeItem: fr2, clear: sr2, length: ur2, key: cr2, keys: lr2, dropInstance: dr2 };
          function hr2() {
            return typeof openDatabase == "function";
          }
          var ne = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", mr2 = "~~local_forage_type~", Be2 = /^~~local_forage_type~([^~]+)~/, he = "__lfsc__:", be2 = he.length, _e2 = "arbf", we2 = "blob", xe2 = "si08", Oe2 = "ui08", Ce = "uic8", Le2 = "si16", Pe = "si32", Me2 = "ur16", Fe2 = "ui32", Ue2 = "fl32", Ye2 = "fl64", ze2 = be2 + _e2.length, We2 = Object.prototype.toString;
          function He2(e) {
            var t = e.length * 0.75, r = e.length, i, o = 0, n, f3, s, c2;
            e[e.length - 1] === "=" && (t--, e[e.length - 2] === "=" && t--);
            var l2 = new ArrayBuffer(t), d = new Uint8Array(l2);
            for (i = 0; i < r; i += 4) n = ne.indexOf(e[i]), f3 = ne.indexOf(e[i + 1]), s = ne.indexOf(e[i + 2]), c2 = ne.indexOf(e[i + 3]), d[o++] = n << 2 | f3 >> 4, d[o++] = (f3 & 15) << 4 | s >> 2, d[o++] = (s & 3) << 6 | c2 & 63;
            return l2;
          }
          function Ie(e) {
            var t = new Uint8Array(e), r = "", i;
            for (i = 0; i < t.length; i += 3) r += ne[t[i] >> 2], r += ne[(t[i] & 3) << 4 | t[i + 1] >> 4], r += ne[(t[i + 1] & 15) << 2 | t[i + 2] >> 6], r += ne[t[i + 2] & 63];
            return t.length % 3 === 2 ? r = r.substring(0, r.length - 1) + "=" : t.length % 3 === 1 && (r = r.substring(0, r.length - 2) + "=="), r;
          }
          function yr2(e, t) {
            var r = "";
            if (e && (r = We2.call(e)), e && (r === "[object ArrayBuffer]" || e.buffer && We2.call(e.buffer) === "[object ArrayBuffer]")) {
              var i, o = he;
              e instanceof ArrayBuffer ? (i = e, o += _e2) : (i = e.buffer, r === "[object Int8Array]" ? o += xe2 : r === "[object Uint8Array]" ? o += Oe2 : r === "[object Uint8ClampedArray]" ? o += Ce : r === "[object Int16Array]" ? o += Le2 : r === "[object Uint16Array]" ? o += Me2 : r === "[object Int32Array]" ? o += Pe : r === "[object Uint32Array]" ? o += Fe2 : r === "[object Float32Array]" ? o += Ue2 : r === "[object Float64Array]" ? o += Ye2 : t(new Error("Failed to get type for BinaryArray"))), t(o + Ie(i));
            } else if (r === "[object Blob]") {
              var n = new FileReader();
              n.onload = function() {
                var f3 = mr2 + e.type + "~" + Ie(this.result);
                t(he + we2 + f3);
              }, n.readAsArrayBuffer(e);
            } else try {
              t(JSON.stringify(e));
            } catch (f3) {
              console.error("Couldn't convert value into a JSON string: ", e), t(null, f3);
            }
          }
          function pr2(e) {
            if (e.substring(0, be2) !== he) return JSON.parse(e);
            var t = e.substring(ze2), r = e.substring(be2, ze2), i;
            if (r === we2 && Be2.test(t)) {
              var o = t.match(Be2);
              i = o[1], t = t.substring(o[0].length);
            }
            var n = He2(t);
            switch (r) {
              case _e2:
                return n;
              case we2:
                return J3([n], { type: i });
              case xe2:
                return new Int8Array(n);
              case Oe2:
                return new Uint8Array(n);
              case Ce:
                return new Uint8ClampedArray(n);
              case Le2:
                return new Int16Array(n);
              case Me2:
                return new Uint16Array(n);
              case Pe:
                return new Int32Array(n);
              case Fe2:
                return new Uint32Array(n);
              case Ue2:
                return new Float32Array(n);
              case Ye2:
                return new Float64Array(n);
              default:
                throw new Error("Unkown type: " + r);
            }
          }
          var Ee2 = { serialize: yr2, deserialize: pr2, stringToBuffer: He2, bufferToString: Ie };
          function Ke2(e, t, r, i) {
            e.executeSql("CREATE TABLE IF NOT EXISTS " + t.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], r, i);
          }
          function gr2(e) {
            var t = this, r = { db: null };
            if (e) for (var i in e) r[i] = typeof e[i] != "string" ? e[i].toString() : e[i];
            var o = new m3(function(n, f3) {
              try {
                r.db = openDatabase(r.name, String(r.version), r.description, r.size);
              } catch (s) {
                return f3(s);
              }
              r.db.transaction(function(s) {
                Ke2(s, r, function() {
                  t._dbInfo = r, n();
                }, function(c2, l2) {
                  f3(l2);
                });
              }, f3);
            });
            return r.serializer = Ee2, o;
          }
          function ie2(e, t, r, i, o, n) {
            e.executeSql(r, i, o, function(f3, s) {
              s.code === s.SYNTAX_ERR ? f3.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [t.storeName], function(c2, l2) {
                l2.rows.length ? n(c2, s) : Ke2(c2, t, function() {
                  c2.executeSql(r, i, o, n);
                }, n);
              }, n) : n(f3, s);
            }, n);
          }
          function br2(e, t) {
            var r = this;
            e = z2(e);
            var i = new m3(function(o, n) {
              r.ready().then(function() {
                var f3 = r._dbInfo;
                f3.db.transaction(function(s) {
                  ie2(s, f3, "SELECT * FROM " + f3.storeName + " WHERE key = ? LIMIT 1", [e], function(c2, l2) {
                    var d = l2.rows.length ? l2.rows.item(0).value : null;
                    d && (d = f3.serializer.deserialize(d)), o(d);
                  }, function(c2, l2) {
                    n(l2);
                  });
                });
              }).catch(n);
            });
            return w2(i, t), i;
          }
          function _r2(e, t) {
            var r = this, i = new m3(function(o, n) {
              r.ready().then(function() {
                var f3 = r._dbInfo;
                f3.db.transaction(function(s) {
                  ie2(s, f3, "SELECT * FROM " + f3.storeName, [], function(c2, l2) {
                    for (var d = l2.rows, y3 = d.length, A2 = 0; A2 < y3; A2++) {
                      var x3 = d.item(A2), L3 = x3.value;
                      if (L3 && (L3 = f3.serializer.deserialize(L3)), L3 = e(L3, x3.key, A2 + 1), L3 !== void 0) {
                        o(L3);
                        return;
                      }
                    }
                    o();
                  }, function(c2, l2) {
                    n(l2);
                  });
                });
              }).catch(n);
            });
            return w2(i, t), i;
          }
          function Ge2(e, t, r, i) {
            var o = this;
            e = z2(e);
            var n = new m3(function(f3, s) {
              o.ready().then(function() {
                t === void 0 && (t = null);
                var c2 = t, l2 = o._dbInfo;
                l2.serializer.serialize(t, function(d, y3) {
                  y3 ? s(y3) : l2.db.transaction(function(A2) {
                    ie2(A2, l2, "INSERT OR REPLACE INTO " + l2.storeName + " (key, value) VALUES (?, ?)", [e, d], function() {
                      f3(c2);
                    }, function(x3, L3) {
                      s(L3);
                    });
                  }, function(A2) {
                    if (A2.code === A2.QUOTA_ERR) {
                      if (i > 0) {
                        f3(Ge2.apply(o, [e, c2, r, i - 1]));
                        return;
                      }
                      s(A2);
                    }
                  });
                });
              }).catch(s);
            });
            return w2(n, r), n;
          }
          function wr2(e, t, r) {
            return Ge2.apply(this, [e, t, r, 1]);
          }
          function Ir2(e, t) {
            var r = this;
            e = z2(e);
            var i = new m3(function(o, n) {
              r.ready().then(function() {
                var f3 = r._dbInfo;
                f3.db.transaction(function(s) {
                  ie2(s, f3, "DELETE FROM " + f3.storeName + " WHERE key = ?", [e], function() {
                    o();
                  }, function(c2, l2) {
                    n(l2);
                  });
                });
              }).catch(n);
            });
            return w2(i, t), i;
          }
          function Er2(e) {
            var t = this, r = new m3(function(i, o) {
              t.ready().then(function() {
                var n = t._dbInfo;
                n.db.transaction(function(f3) {
                  ie2(f3, n, "DELETE FROM " + n.storeName, [], function() {
                    i();
                  }, function(s, c2) {
                    o(c2);
                  });
                });
              }).catch(o);
            });
            return w2(r, e), r;
          }
          function Sr2(e) {
            var t = this, r = new m3(function(i, o) {
              t.ready().then(function() {
                var n = t._dbInfo;
                n.db.transaction(function(f3) {
                  ie2(f3, n, "SELECT COUNT(key) as c FROM " + n.storeName, [], function(s, c2) {
                    var l2 = c2.rows.item(0).c;
                    i(l2);
                  }, function(s, c2) {
                    o(c2);
                  });
                });
              }).catch(o);
            });
            return w2(r, e), r;
          }
          function Ar2(e, t) {
            var r = this, i = new m3(function(o, n) {
              r.ready().then(function() {
                var f3 = r._dbInfo;
                f3.db.transaction(function(s) {
                  ie2(s, f3, "SELECT key FROM " + f3.storeName + " WHERE id = ? LIMIT 1", [e + 1], function(c2, l2) {
                    var d = l2.rows.length ? l2.rows.item(0).key : null;
                    o(d);
                  }, function(c2, l2) {
                    n(l2);
                  });
                });
              }).catch(n);
            });
            return w2(i, t), i;
          }
          function Tr2(e) {
            var t = this, r = new m3(function(i, o) {
              t.ready().then(function() {
                var n = t._dbInfo;
                n.db.transaction(function(f3) {
                  ie2(f3, n, "SELECT key FROM " + n.storeName, [], function(s, c2) {
                    for (var l2 = [], d = 0; d < c2.rows.length; d++) l2.push(c2.rows.item(d).key);
                    i(l2);
                  }, function(s, c2) {
                    o(c2);
                  });
                });
              }).catch(o);
            });
            return w2(r, e), r;
          }
          function Rr2(e) {
            return new m3(function(t, r) {
              e.transaction(function(i) {
                i.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function(o, n) {
                  for (var f3 = [], s = 0; s < n.rows.length; s++) f3.push(n.rows.item(s).name);
                  t({ db: e, storeNames: f3 });
                }, function(o, n) {
                  r(n);
                });
              }, function(i) {
                r(i);
              });
            });
          }
          function Dr2(e, t) {
            t = Z.apply(this, arguments);
            var r = this.config();
            e = typeof e != "function" && e || {}, e.name || (e.name = e.name || r.name, e.storeName = e.storeName || r.storeName);
            var i = this, o;
            return e.name ? o = new m3(function(n) {
              var f3;
              e.name === r.name ? f3 = i._dbInfo.db : f3 = openDatabase(e.name, "", "", 0), e.storeName ? n({ db: f3, storeNames: [e.storeName] }) : n(Rr2(f3));
            }).then(function(n) {
              return new m3(function(f3, s) {
                n.db.transaction(function(c2) {
                  function l2(x3) {
                    return new m3(function(L3, H3) {
                      c2.executeSql("DROP TABLE IF EXISTS " + x3, [], function() {
                        L3();
                      }, function(W3, q3) {
                        H3(q3);
                      });
                    });
                  }
                  for (var d = [], y3 = 0, A2 = n.storeNames.length; y3 < A2; y3++) d.push(l2(n.storeNames[y3]));
                  m3.all(d).then(function() {
                    f3();
                  }).catch(function(x3) {
                    s(x3);
                  });
                }, function(c2) {
                  s(c2);
                });
              });
            }) : o = m3.reject("Invalid arguments"), w2(o, t), o;
          }
          var Nr2 = { _driver: "webSQLStorage", _initStorage: gr2, _support: hr2(), iterate: _r2, getItem: br2, setItem: wr2, removeItem: Ir2, clear: Er2, length: Sr2, key: Ar2, keys: Tr2, dropInstance: Dr2 };
          function Br2() {
            try {
              return typeof localStorage < "u" && "setItem" in localStorage && !!localStorage.setItem;
            } catch {
              return false;
            }
          }
          function Ve2(e, t) {
            var r = e.name + "/";
            return e.storeName !== t.storeName && (r += e.storeName + "/"), r;
          }
          function xr2() {
            var e = "_localforage_support_test";
            try {
              return localStorage.setItem(e, true), localStorage.removeItem(e), false;
            } catch {
              return true;
            }
          }
          function Or2() {
            return !xr2() || localStorage.length > 0;
          }
          function Cr2(e) {
            var t = this, r = {};
            if (e) for (var i in e) r[i] = e[i];
            return r.keyPrefix = Ve2(e, t._defaultConfig), Or2() ? (t._dbInfo = r, r.serializer = Ee2, m3.resolve()) : m3.reject();
          }
          function Lr2(e) {
            var t = this, r = t.ready().then(function() {
              for (var i = t._dbInfo.keyPrefix, o = localStorage.length - 1; o >= 0; o--) {
                var n = localStorage.key(o);
                n.indexOf(i) === 0 && localStorage.removeItem(n);
              }
            });
            return w2(r, e), r;
          }
          function Pr2(e, t) {
            var r = this;
            e = z2(e);
            var i = r.ready().then(function() {
              var o = r._dbInfo, n = localStorage.getItem(o.keyPrefix + e);
              return n && (n = o.serializer.deserialize(n)), n;
            });
            return w2(i, t), i;
          }
          function Mr2(e, t) {
            var r = this, i = r.ready().then(function() {
              for (var o = r._dbInfo, n = o.keyPrefix, f3 = n.length, s = localStorage.length, c2 = 1, l2 = 0; l2 < s; l2++) {
                var d = localStorage.key(l2);
                if (d.indexOf(n) === 0) {
                  var y3 = localStorage.getItem(d);
                  if (y3 && (y3 = o.serializer.deserialize(y3)), y3 = e(y3, d.substring(f3), c2++), y3 !== void 0) return y3;
                }
              }
            });
            return w2(i, t), i;
          }
          function Fr2(e, t) {
            var r = this, i = r.ready().then(function() {
              var o = r._dbInfo, n;
              try {
                n = localStorage.key(e);
              } catch {
                n = null;
              }
              return n && (n = n.substring(o.keyPrefix.length)), n;
            });
            return w2(i, t), i;
          }
          function Ur2(e) {
            var t = this, r = t.ready().then(function() {
              for (var i = t._dbInfo, o = localStorage.length, n = [], f3 = 0; f3 < o; f3++) {
                var s = localStorage.key(f3);
                s.indexOf(i.keyPrefix) === 0 && n.push(s.substring(i.keyPrefix.length));
              }
              return n;
            });
            return w2(r, e), r;
          }
          function Yr2(e) {
            var t = this, r = t.keys().then(function(i) {
              return i.length;
            });
            return w2(r, e), r;
          }
          function zr(e, t) {
            var r = this;
            e = z2(e);
            var i = r.ready().then(function() {
              var o = r._dbInfo;
              localStorage.removeItem(o.keyPrefix + e);
            });
            return w2(i, t), i;
          }
          function Wr2(e, t, r) {
            var i = this;
            e = z2(e);
            var o = i.ready().then(function() {
              t === void 0 && (t = null);
              var n = t;
              return new m3(function(f3, s) {
                var c2 = i._dbInfo;
                c2.serializer.serialize(t, function(l2, d) {
                  if (d) s(d);
                  else try {
                    localStorage.setItem(c2.keyPrefix + e, l2), f3(n);
                  } catch (y3) {
                    (y3.name === "QuotaExceededError" || y3.name === "NS_ERROR_DOM_QUOTA_REACHED") && s(y3), s(y3);
                  }
                });
              });
            });
            return w2(o, r), o;
          }
          function Hr2(e, t) {
            if (t = Z.apply(this, arguments), e = typeof e != "function" && e || {}, !e.name) {
              var r = this.config();
              e.name = e.name || r.name, e.storeName = e.storeName || r.storeName;
            }
            var i = this, o;
            return e.name ? o = new m3(function(n) {
              e.storeName ? n(Ve2(e, i._defaultConfig)) : n(e.name + "/");
            }).then(function(n) {
              for (var f3 = localStorage.length - 1; f3 >= 0; f3--) {
                var s = localStorage.key(f3);
                s.indexOf(n) === 0 && localStorage.removeItem(s);
              }
            }) : o = m3.reject("Invalid arguments"), w2(o, t), o;
          }
          var Kr2 = { _driver: "localStorageWrapper", _initStorage: Cr2, _support: Br2(), iterate: Mr2, getItem: Pr2, setItem: Wr2, removeItem: zr, clear: Lr2, length: Yr2, key: Fr2, keys: Ur2, dropInstance: Hr2 }, Gr2 = function(t, r) {
            return t === r || typeof t == "number" && typeof r == "number" && isNaN(t) && isNaN(r);
          }, Vr2 = function(t, r) {
            for (var i = t.length, o = 0; o < i; ) {
              if (Gr2(t[o], r)) return true;
              o++;
            }
            return false;
          }, je2 = Array.isArray || function(e) {
            return Object.prototype.toString.call(e) === "[object Array]";
          }, le2 = {}, Xe2 = {}, ue2 = { INDEXEDDB: vr2, WEBSQL: Nr2, LOCALSTORAGE: Kr2 }, jr2 = [ue2.INDEXEDDB._driver, ue2.WEBSQL._driver, ue2.LOCALSTORAGE._driver], me2 = ["dropInstance"], Se = ["clear", "getItem", "iterate", "key", "keys", "length", "removeItem", "setItem"].concat(me2), Xr = { description: "", driver: jr2.slice(), name: "localforage", size: 4980736, storeName: "keyvaluepairs", version: 1 };
          function Qr2(e, t) {
            e[t] = function() {
              var r = arguments;
              return e.ready().then(function() {
                return e[t].apply(e, r);
              });
            };
          }
          function Ae2() {
            for (var e = 1; e < arguments.length; e++) {
              var t = arguments[e];
              if (t) for (var r in t) t.hasOwnProperty(r) && (je2(t[r]) ? arguments[0][r] = t[r].slice() : arguments[0][r] = t[r]);
            }
            return arguments[0];
          }
          var $r2 = function() {
            function e(t) {
              Y3(this, e);
              for (var r in ue2) if (ue2.hasOwnProperty(r)) {
                var i = ue2[r], o = i._driver;
                this[r] = o, le2[o] || this.defineDriver(i);
              }
              this._defaultConfig = Ae2({}, Xr), this._config = Ae2({}, this._defaultConfig, t), this._driverSet = null, this._initDriver = null, this._ready = false, this._dbInfo = null, this._wrapLibraryMethodsWithReady(), this.setDriver(this._config.driver).catch(function() {
              });
            }
            return e.prototype.config = function(r) {
              if ((typeof r > "u" ? "undefined" : P3(r)) === "object") {
                if (this._ready) return new Error("Can't call config() after localforage has been used.");
                for (var i in r) {
                  if (i === "storeName" && (r[i] = r[i].replace(/\W/g, "_")), i === "version" && typeof r[i] != "number") return new Error("Database version must be a number.");
                  this._config[i] = r[i];
                }
                return "driver" in r && r.driver ? this.setDriver(this._config.driver) : true;
              } else return typeof r == "string" ? this._config[r] : this._config;
            }, e.prototype.defineDriver = function(r, i, o) {
              var n = new m3(function(f3, s) {
                try {
                  var c2 = r._driver, l2 = new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");
                  if (!r._driver) {
                    s(l2);
                    return;
                  }
                  for (var d = Se.concat("_initStorage"), y3 = 0, A2 = d.length; y3 < A2; y3++) {
                    var x3 = d[y3], L3 = !Vr2(me2, x3);
                    if ((L3 || r[x3]) && typeof r[x3] != "function") {
                      s(l2);
                      return;
                    }
                  }
                  var H3 = function() {
                    for (var de = function(qr2) {
                      return function() {
                        var kr2 = new Error("Method " + qr2 + " is not implemented by the current driver"), Qe2 = m3.reject(kr2);
                        return w2(Qe2, arguments[arguments.length - 1]), Qe2;
                      };
                    }, Te = 0, Zr = me2.length; Te < Zr; Te++) {
                      var Re2 = me2[Te];
                      r[Re2] || (r[Re2] = de(Re2));
                    }
                  };
                  H3();
                  var W3 = function(de) {
                    le2[c2] && console.info("Redefining LocalForage driver: " + c2), le2[c2] = r, Xe2[c2] = de, f3();
                  };
                  "_support" in r ? r._support && typeof r._support == "function" ? r._support().then(W3, s) : W3(!!r._support) : W3(true);
                } catch (q3) {
                  s(q3);
                }
              });
              return B3(n, i, o), n;
            }, e.prototype.driver = function() {
              return this._driver || null;
            }, e.prototype.getDriver = function(r, i, o) {
              var n = le2[r] ? m3.resolve(le2[r]) : m3.reject(new Error("Driver not found."));
              return B3(n, i, o), n;
            }, e.prototype.getSerializer = function(r) {
              var i = m3.resolve(Ee2);
              return B3(i, r), i;
            }, e.prototype.ready = function(r) {
              var i = this, o = i._driverSet.then(function() {
                return i._ready === null && (i._ready = i._initDriver()), i._ready;
              });
              return B3(o, r, r), o;
            }, e.prototype.setDriver = function(r, i, o) {
              var n = this;
              je2(r) || (r = [r]);
              var f3 = this._getSupportedDrivers(r);
              function s() {
                n._config.driver = n.driver();
              }
              function c2(y3) {
                return n._extend(y3), s(), n._ready = n._initStorage(n._config), n._ready;
              }
              function l2(y3) {
                return function() {
                  var A2 = 0;
                  function x3() {
                    for (; A2 < y3.length; ) {
                      var L3 = y3[A2];
                      return A2++, n._dbInfo = null, n._ready = null, n.getDriver(L3).then(c2).catch(x3);
                    }
                    s();
                    var H3 = new Error("No available storage method found.");
                    return n._driverSet = m3.reject(H3), n._driverSet;
                  }
                  return x3();
                };
              }
              var d = this._driverSet !== null ? this._driverSet.catch(function() {
                return m3.resolve();
              }) : m3.resolve();
              return this._driverSet = d.then(function() {
                var y3 = f3[0];
                return n._dbInfo = null, n._ready = null, n.getDriver(y3).then(function(A2) {
                  n._driver = A2._driver, s(), n._wrapLibraryMethodsWithReady(), n._initDriver = l2(f3);
                });
              }).catch(function() {
                s();
                var y3 = new Error("No available storage method found.");
                return n._driverSet = m3.reject(y3), n._driverSet;
              }), B3(this._driverSet, i, o), this._driverSet;
            }, e.prototype.supports = function(r) {
              return !!Xe2[r];
            }, e.prototype._extend = function(r) {
              Ae2(this, r);
            }, e.prototype._getSupportedDrivers = function(r) {
              for (var i = [], o = 0, n = r.length; o < n; o++) {
                var f3 = r[o];
                this.supports(f3) && i.push(f3);
              }
              return i;
            }, e.prototype._wrapLibraryMethodsWithReady = function() {
              for (var r = 0, i = Se.length; r < i; r++) Qr2(this, Se[r]);
            }, e.prototype.createInstance = function(r) {
              return new e(r);
            }, e;
          }(), Jr2 = new $r2();
          R3.exports = Jr2;
        }, { 3: 3 }] }, {}, [4])(4);
      });
    });
    rr2 = Je((ye2, er2) => {
      (function(b3, T2) {
        typeof ye2 == "object" && typeof er2 < "u" ? T2(ye2) : typeof define == "function" && define.amd ? define("localforage-driver-memory", ["exports"], T2) : T2(b3.LocalforageDriverMemory = {});
      })(typeof self < "u" ? self : ye2, function(b3) {
        "use strict";
        var T2 = "localforage-driver-memory";
        function _3(a2) {
          var u3 = typeof Symbol == "function" && a2[Symbol.iterator], v2 = 0;
          return u3 ? u3.call(a2) : { next: function() {
            return a2 && v2 >= a2.length && (a2 = void 0), { value: a2 && a2[v2++], done: !a2 };
          } };
        }
        function O3(a2, u3) {
          a2 = a2 || [], u3 = u3 || {};
          try {
            return new Blob(a2, u3);
          } catch (I3) {
            if (I3.name !== "TypeError") throw I3;
            for (var v2 = typeof BlobBuilder < "u" ? BlobBuilder : typeof MSBlobBuilder < "u" ? MSBlobBuilder : typeof MozBlobBuilder < "u" ? MozBlobBuilder : WebKitBlobBuilder, p = new v2(), g2 = 0; g2 < a2.length; g2 += 1) p.append(a2[g2]);
            return p.getBlob(u3.type);
          }
        }
        var R3 = /^~~local_forage_type~([^~]+)~/, j2 = 9, P3 = j2 + 4, Y3 = Object.prototype.toString;
        function S3(a2) {
          var u3 = a2.length * 0.75, v2 = a2.length;
          a2[a2.length - 1] === "=" && (u3--, a2[a2.length - 2] === "=" && u3--);
          for (var p = new ArrayBuffer(u3), g2 = new Uint8Array(p), I3 = 0, N2 = 0; I3 < v2; I3 += 4) {
            var V2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(a2[I3]), se2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(a2[I3 + 1]), ae2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(a2[I3 + 2]), ce2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(a2[I3 + 3]);
            g2[N2++] = V2 << 2 | se2 >> 4, g2[N2++] = (se2 & 15) << 4 | ae2 >> 2, g2[N2++] = (ae2 & 3) << 6 | ce2 & 63;
          }
          return p;
        }
        function M2(a2) {
          for (var u3 = new Uint8Array(a2), v2 = "", p = 0; p < u3.length; p += 3) v2 += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[u3[p] >> 2], v2 += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[(u3[p] & 3) << 4 | u3[p + 1] >> 4], v2 += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[(u3[p + 1] & 15) << 2 | u3[p + 2] >> 6], v2 += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[u3[p + 2] & 63];
          return u3.length % 3 === 2 ? v2 = v2.substring(0, v2.length - 1) + "=" : u3.length % 3 === 1 && (v2 = v2.substring(0, v2.length - 2) + "=="), v2;
        }
        function K2(a2, u3) {
          var v2 = "";
          if (a2 && (v2 = Y3.call(a2)), a2 && (v2 === "[object ArrayBuffer]" || a2.buffer && Y3.call(a2.buffer) === "[object ArrayBuffer]")) {
            var p = void 0, g2 = "__lfsc__:";
            a2 instanceof ArrayBuffer ? (p = a2, g2 += "arbf") : (p = a2.buffer, v2 === "[object Int8Array]" ? g2 += "si08" : v2 === "[object Uint8Array]" ? g2 += "ui08" : v2 === "[object Uint8ClampedArray]" ? g2 += "uic8" : v2 === "[object Int16Array]" ? g2 += "si16" : v2 === "[object Uint16Array]" ? g2 += "ur16" : v2 === "[object Int32Array]" ? g2 += "si32" : v2 === "[object Uint32Array]" ? g2 += "ui32" : v2 === "[object Float32Array]" ? g2 += "fl32" : v2 === "[object Float64Array]" ? g2 += "fl64" : u3(new Error("Failed to get type for BinaryArray"))), u3(g2 + M2(p));
          } else if (v2 === "[object Blob]") {
            var I3 = new FileReader();
            I3.onload = function() {
              var N2 = "~~local_forage_type~" + a2.type + "~" + M2(this.result);
              u3("__lfsc__:blob" + N2);
            }, I3.readAsArrayBuffer(a2);
          } else try {
            u3(JSON.stringify(a2));
          } catch (N2) {
            console.error("Couldn't convert value into a JSON string: ", a2), u3(null, N2);
          }
        }
        function J3(a2) {
          if (a2.substring(0, j2) !== "__lfsc__:") return JSON.parse(a2);
          var u3 = a2.substring(P3), v2 = a2.substring(j2, P3), p;
          if (v2 === "blob" && R3.test(u3)) {
            var g2 = u3.match(R3);
            p = g2[1], u3 = u3.substring(g2[0].length);
          }
          var I3 = S3(u3);
          switch (v2) {
            case "arbf":
              return I3;
            case "blob":
              return O3([I3], { type: p });
            case "si08":
              return new Int8Array(I3);
            case "ui08":
              return new Uint8Array(I3);
            case "uic8":
              return new Uint8ClampedArray(I3);
            case "si16":
              return new Int16Array(I3);
            case "ur16":
              return new Uint16Array(I3);
            case "si32":
              return new Int32Array(I3);
            case "ui32":
              return new Uint32Array(I3);
            case "fl32":
              return new Float32Array(I3);
            case "fl64":
              return new Float64Array(I3);
            default:
              throw new Error("Unkown type: " + v2);
          }
        }
        function m3(a2) {
          var u3, v2;
          if (a2 === null || typeof a2 != "object" || "isActiveClone" in a2) return a2;
          var p = a2 instanceof Date ? new Date(a2) : a2.constructor();
          try {
            for (var g2 = _3(Object.keys(a2)), I3 = g2.next(); !I3.done; I3 = g2.next()) {
              var N2 = I3.value;
              Object.prototype.hasOwnProperty.call(a2, N2) && (a2.isActiveClone = null, p[N2] = m3(a2[N2]), delete a2.isActiveClone);
            }
          } catch (V2) {
            u3 = { error: V2 };
          } finally {
            try {
              I3 && !I3.done && (v2 = g2.return) && v2.call(g2);
            } finally {
              if (u3) throw u3.error;
            }
          }
          return p;
        }
        function w2(a2, u3) {
          return (a2.name || u3.name) + "/" + (a2.storeName || u3.storeName) + "/";
        }
        function B3(a2, u3) {
          u3 && a2.then(function(v2) {
            u3(null, v2);
          }, function(v2) {
            u3(v2);
          });
        }
        function z2() {
          for (var a2 = [], u3 = 0; u3 < arguments.length; u3++) a2[u3] = arguments[u3];
          if (arguments.length && typeof arguments[arguments.length - 1] == "function") return arguments[arguments.length - 1];
        }
        function Z(a2, u3) {
          var v2 = this;
          if (u3 = z2.apply(this, arguments), a2 = typeof a2 != "function" && a2 || {}, !a2.name) {
            var p = this.config();
            a2.name = a2.name || p.name, a2.storeName = a2.storeName || p.storeName;
          }
          var g2;
          return a2.name ? g2 = new Promise(function(I3) {
            a2.storeName ? I3(w2(a2, v2._defaultConfig)) : I3(a2.name + "/");
          }) : g2 = Promise.reject("Invalid arguments"), { promise: g2, callback: u3 };
        }
        function F3(a2) {
          return typeof a2 != "string" && (console.warn(a2 + " used as a key, but it is not a string."), a2 = String(a2)), a2;
        }
        var k3 = { bufferToString: M2, deserialize: J3, serialize: K2, stringToBuffer: S3 }, U3 = {}, fe2 = function() {
          function a2(u3) {
            this.kp = u3, this.data = {};
          }
          return a2.resolve = function(u3) {
            return U3[u3] || (U3[u3] = new a2(u3)), U3[u3];
          }, a2.prototype.clear = function() {
            this.data = {};
          }, a2.prototype.drop = function() {
            this.clear(), delete U3[this.kp];
          }, a2.prototype.get = function(u3) {
            return this.data[u3];
          }, a2.prototype.key = function(u3) {
            return this.keys()[u3];
          }, a2.prototype.keys = function() {
            return Object.keys(this.data);
          }, a2.prototype.rm = function(u3) {
            delete this.data[u3];
          }, a2.prototype.set = function(u3, v2) {
            this.data[u3] = v2;
          }, a2;
        }();
        function te2(a2) {
          var u3 = a2 ? m3(a2) : {}, v2 = w2(u3, this._defaultConfig), p = fe2.resolve(v2);
          return this._dbInfo = u3, this._dbInfo.serializer = k3, this._dbInfo.keyPrefix = v2, this._dbInfo.mStore = p, Promise.resolve();
        }
        function h3(a2) {
          var u3 = this, v2 = this.ready().then(function() {
            u3._dbInfo.mStore.clear();
          });
          return B3(v2, a2), v2;
        }
        function D3(a2, u3) {
          var v2 = Z.apply(this, arguments), p = v2.promise, g2 = v2.callback, I3 = p.then(function(N2) {
            fe2.resolve(N2).drop();
          });
          return B3(I3, g2), p;
        }
        function E3(a2, u3) {
          var v2 = this;
          a2 = F3(a2);
          var p = this.ready().then(function() {
            var g2 = v2._dbInfo.mStore.get(a2);
            return g2 == null ? null : v2._dbInfo.serializer.deserialize(g2);
          });
          return B3(p, u3), p;
        }
        function C3(a2, u3) {
          var v2 = this, p = this.ready().then(function() {
            for (var g2 = v2._dbInfo.mStore, I3 = g2.keys(), N2 = 0; N2 < I3.length; N2++) {
              var V2 = g2.get(I3[N2]);
              if (V2 && (V2 = v2._dbInfo.serializer.deserialize(V2)), V2 = a2(V2, I3[N2], N2 + 1), V2 !== void 0) return V2;
            }
          });
          return B3(p, u3), p;
        }
        function G2(a2, u3) {
          var v2 = this, p = this.ready().then(function() {
            var g2;
            try {
              g2 = v2._dbInfo.mStore.key(a2), g2 === void 0 && (g2 = null);
            } catch {
              g2 = null;
            }
            return g2;
          });
          return B3(p, u3), p;
        }
        function X2(a2) {
          var u3 = this, v2 = this.ready().then(function() {
            return u3._dbInfo.mStore.keys();
          });
          return B3(v2, a2), v2;
        }
        function Q3(a2) {
          var u3 = this.keys().then(function(v2) {
            return v2.length;
          });
          return B3(u3, a2), u3;
        }
        function $(a2, u3) {
          var v2 = this;
          a2 = F3(a2);
          var p = this.ready().then(function() {
            v2._dbInfo.mStore.rm(a2);
          });
          return B3(p, u3), p;
        }
        function ee(a2, u3, v2) {
          var p = this;
          a2 = F3(a2);
          var g2 = this.ready().then(function() {
            u3 === void 0 && (u3 = null);
            var I3 = u3;
            return new Promise(function(N2, V2) {
              p._dbInfo.serializer.serialize(u3, function(se2, ae2) {
                if (ae2) V2(ae2);
                else try {
                  p._dbInfo.mStore.set(a2, se2), N2(I3);
                } catch (ce2) {
                  V2(ce2);
                }
              });
            });
          });
          return B3(g2, v2), g2;
        }
        var oe2 = true;
        b3._support = oe2, b3._driver = T2, b3._initStorage = te2, b3.clear = h3, b3.dropInstance = D3, b3.getItem = E3, b3.iterate = C3, b3.key = G2, b3.keys = X2, b3.length = Q3, b3.removeItem = $, b3.setItem = ee, Object.defineProperty(b3, "__esModule", { value: true });
      });
    });
    ge2 = Ze(ke());
    Ne2 = Ze(rr2());
    ct2 = { display: "block", visibility: "hidden", position: "fixed", top: "0", right: "0", width: "100%", height: "100%", borderRadius: "0", border: "none", opacity: "0", zIndex: "-1" };
    ir2 = 1e3;
    or2 = 60 * ir2;
    vt2 = 15 * ir2;
    ht2 = 2 * or2;
    mt2 = 60 * or2;
    pe2 = class extends et {
      constructor() {
        super(...arguments);
        this.activeElement = null;
        this.lastPingTime = Date.now();
        this.intervalTimer = null;
        this.timeoutTimer = null;
      }
      getIframeSrc() {
        return Ye(`/send?params=${encodeURIComponent(this.parameters)}`, this.endpoint).href;
      }
      init() {
        this.test = "hello", this.iframe = new Promise((_3) => {
          let O3 = () => {
            if (dt2(encodeURIComponent(this.parameters))) Xn().log();
            else {
              let R3 = document.createElement("iframe");
              R3.classList.add("magic-iframe"), R3.dataset.magicIframeLabel = Ye(this.endpoint).host, R3.title = "Secure Modal", R3.src = this.getIframeSrc(), R3.allow = "clipboard-read; clipboard-write", lt2(R3), document.body.appendChild(R3), _3(R3);
            }
          };
          ["loaded", "interactive", "complete"].includes(document.readyState) ? O3() : window.addEventListener("load", O3, false);
        }), this.iframe.then((_3) => {
          _3 instanceof HTMLIFrameElement && _3.addEventListener("load", () => re(this, null, function* () {
            yield this.startHeartBeat();
          }));
        }), window.addEventListener("message", (_3) => {
          var O3;
          if (_3.origin === this.endpoint && _3.data && _3.data.msgType && this.messageHandlers.size) {
            _3.data.msgType.includes(g.MAGIC_PONG) && (this.lastPingTime = Date.now()), _3.data.response = (O3 = _3.data.response) != null ? O3 : {};
            for (let j2 of this.messageHandlers.values()) j2(_3);
          }
        }), window.addEventListener("beforeunload", () => {
          this.stopHeartBeat();
        });
      }
      showOverlay() {
        return re(this, null, function* () {
          let _3 = yield this.iframe;
          _3.style.visibility = "visible", _3.style.zIndex = "2147483647", _3.style.opacity = "1", this.activeElement = document.activeElement, _3.focus();
        });
      }
      hideOverlay() {
        return re(this, null, function* () {
          var O3;
          let _3 = yield this.iframe;
          _3.style.visibility = "hidden", _3.style.zIndex = "-1", _3.style.opacity = "0", (O3 = this.activeElement) != null && O3.focus && this.activeElement.focus(), this.activeElement = null;
        });
      }
      _post(_3) {
        return re(this, null, function* () {
          let O3 = yield this.iframe;
          if (O3 && O3.contentWindow) O3.contentWindow.postMessage(_3, this.endpoint);
          else throw Tt();
        });
      }
      heartBeatCheck() {
        this.intervalTimer = setInterval(() => re(this, null, function* () {
          let _3 = { msgType: `${E.MAGIC_PING}-${this.parameters}`, payload: [] };
          yield this._post(_3), Date.now() - this.lastPingTime > vt2 && (yield this.reloadIframe(), this.lastPingTime = Date.now());
        }), ht2);
      }
      startHeartBeat() {
        return re(this, null, function* () {
          (yield this.iframe) && (this.timeoutTimer = setTimeout(() => this.heartBeatCheck(), mt2));
        });
      }
      stopHeartBeat() {
        this.timeoutTimer && (clearTimeout(this.timeoutTimer), this.timeoutTimer = null), this.intervalTimer && (clearInterval(this.intervalTimer), this.intervalTimer = null);
      }
      reloadIframe() {
        return re(this, null, function* () {
          let _3 = yield this.iframe;
          if (_3) _3.src = this.getIframeSrc();
          else throw Tt();
        });
      }
    };
    Rt2 = Qr(qe, { platform: "web", sdkName: "magic-sdk", version: "28.21.1", defaultEndpoint: "https://auth.magic.link/", ViewController: pe2, configureStorage: () => re(void 0, null, function* () {
      let b3 = ge2.default.createInstance({ name: "MagicAuthLocalStorageDB", storeName: "MagicAuthLocalStorage" });
      return yield b3.defineDriver(Ne2), yield b3.setDriver([ge2.default.INDEXEDDB, ge2.default.LOCALSTORAGE, Ne2._driver]), b3;
    }) });
  }
});

// ../../node_modules/.pnpm/@magic-ext+algorand@23.20.0/node_modules/@magic-ext/algorand/dist/es/index.mjs
var es_exports2 = {};
__export(es_exports2, {
  AlgorandExtension: () => c
});
var a, c;
var init_es5 = __esm({
  "../../node_modules/.pnpm/@magic-ext+algorand@23.20.0/node_modules/@magic-ext/algorand/dist/es/index.mjs"() {
    "use strict";
    init_es3();
    a = (s, e, n) => new Promise((g2, o) => {
      var l2 = (r) => {
        try {
          i(n.next(r));
        } catch (t) {
          o(t);
        }
      }, u3 = (r) => {
        try {
          i(n.throw(r));
        } catch (t) {
          o(t);
        }
      }, i = (r) => r.done ? g2(r.value) : Promise.resolve(r.value).then(l2, u3);
      i((n = n.apply(s, e)).next());
    });
    c = class extends D2.Internal {
      constructor(n) {
        super();
        this.algorandConfig = n;
        this.name = "algod";
        this.config = {};
        this.config = { rpcUrl: n.rpcUrl, chainType: "ALOGD" };
      }
      signTransaction(n) {
        return a(this, null, function* () {
          return this.request(this.utils.createJsonRpcRequestPayload("algod_signTransaction", n));
        });
      }
      signBid(n) {
        return a(this, null, function* () {
          return this.request(this.utils.createJsonRpcRequestPayload("algod_signBid", n));
        });
      }
      getWallet() {
        return a(this, null, function* () {
          return this.request(this.utils.createJsonRpcRequestPayload("algod_getWallet", []));
        });
      }
      signGroupTransaction(n) {
        return a(this, null, function* () {
          return this.request(this.utils.createJsonRpcRequestPayload("algod_signGroupTransaction", n));
        });
      }
      signGroupTransactionV2(n) {
        return a(this, null, function* () {
          return this.request(this.utils.createJsonRpcRequestPayload("algod_signGroupTransactionV2", n));
        });
      }
    };
  }
});

// src/logger.ts
var LogLevel = /* @__PURE__ */ ((LogLevel2) => {
  LogLevel2[LogLevel2["DEBUG"] = 0] = "DEBUG";
  LogLevel2[LogLevel2["INFO"] = 1] = "INFO";
  LogLevel2[LogLevel2["WARN"] = 2] = "WARN";
  LogLevel2[LogLevel2["ERROR"] = 3] = "ERROR";
  return LogLevel2;
})(LogLevel || {});
var Logger = class _Logger {
  static instance = null;
  level;
  isClient;
  constructor() {
    this.level = 2 /* WARN */;
    this.isClient = typeof window !== "undefined";
  }
  static getInstance() {
    if (!_Logger.instance) {
      _Logger.instance = new _Logger();
    }
    return _Logger.instance;
  }
  static setLevel(level) {
    _Logger.getInstance().level = level;
  }
  log(level, scope, message, ...args) {
    if (level >= this.level && this.isClient) {
      const formattedMessage = scope ? `[${scope}] ${message}` : message;
      switch (level) {
        case 0 /* DEBUG */:
        case 1 /* INFO */:
          console.info(formattedMessage, ...args);
          break;
        case 2 /* WARN */:
          console.warn(formattedMessage, ...args);
          break;
        case 3 /* ERROR */:
          console.error(formattedMessage, ...args);
          break;
      }
    }
  }
  createScopedLogger(scope) {
    return {
      debug: (message, ...args) => this.log(0 /* DEBUG */, scope, message, ...args),
      info: (message, ...args) => this.log(1 /* INFO */, scope, message, ...args),
      warn: (message, ...args) => this.log(2 /* WARN */, scope, message, ...args),
      error: (message, ...args) => this.log(3 /* ERROR */, scope, message, ...args)
    };
  }
  debug(message, ...args) {
    this.log(0 /* DEBUG */, void 0, message, ...args);
  }
  info(message, ...args) {
    this.log(1 /* INFO */, void 0, message, ...args);
  }
  warn(message, ...args) {
    this.log(2 /* WARN */, void 0, message, ...args);
  }
  error(message, ...args) {
    this.log(3 /* ERROR */, void 0, message, ...args);
  }
  // For testing purposes
  setIsClient(isClient) {
    this.isClient = isClient;
  }
};
var logger = Logger.getInstance();

// src/manager.ts
import { Store } from "@tanstack/store";
import algosdk12 from "algosdk";

// src/network.ts
var DEFAULT_NETWORK_CONFIG = {
  mainnet: {
    algod: {
      token: "",
      baseServer: "https://mainnet-api.4160.nodely.dev",
      headers: {}
    },
    isTestnet: false,
    genesisHash: "wGHE2Pwdvd7S12BL5FaOP20EGYesN73ktiC1qzkkit8=",
    genesisId: "mainnet-v1.0",
    caipChainId: "algorand:wGHE2Pwdvd7S12BL5FaOP20EGYesN73k"
  },
  testnet: {
    algod: {
      token: "",
      baseServer: "https://testnet-api.4160.nodely.dev",
      headers: {}
    },
    isTestnet: true,
    genesisHash: "SGO1GKSzyE7IEPItTxCByw9x8FmnrCDexi9/cOUJOiI=",
    genesisId: "testnet-v1.0",
    caipChainId: "algorand:SGO1GKSzyE7IEPItTxCByw9x8FmnrCDe"
  },
  betanet: {
    algod: {
      token: "",
      baseServer: "https://betanet-api.4160.nodely.dev",
      headers: {}
    },
    isTestnet: true,
    genesisHash: "mFgazF-2uRS1tMiL9dsj01hJGySEmPN2OvOTQHJ6iQg=",
    genesisId: "betanet-v1.0",
    caipChainId: "algorand:mFgazF-2uRS1tMiL9dsj01hJGySEmPN2"
  },
  fnet: {
    algod: {
      token: "",
      baseServer: "https://fnet-api.4160.nodely.dev",
      headers: {}
    },
    isTestnet: true,
    genesisHash: "kUt08LxeVAAGHnh4JoAoAMM9ql_hBwSoRrQQKWSVgxk=",
    genesisId: "fnet-v1.0",
    caipChainId: "algorand:kUt08LxeVAAGHnh4JoAoAMM9ql_hBwSo"
  },
  localnet: {
    algod: {
      token: "a".repeat(64),
      baseServer: "http://localhost",
      port: 4001,
      headers: {}
    },
    isTestnet: true
  }
};
var NetworkConfigBuilder = class {
  networks;
  constructor() {
    this.networks = new Map(Object.entries(DEFAULT_NETWORK_CONFIG));
  }
  // Methods to customize default networks
  mainnet(config) {
    this.networks.set("mainnet", {
      ...DEFAULT_NETWORK_CONFIG.mainnet,
      ...config,
      genesisHash: DEFAULT_NETWORK_CONFIG.mainnet.genesisHash,
      genesisId: DEFAULT_NETWORK_CONFIG.mainnet.genesisId,
      caipChainId: DEFAULT_NETWORK_CONFIG.mainnet.caipChainId,
      algod: {
        ...DEFAULT_NETWORK_CONFIG.mainnet.algod,
        ...config.algod || {}
      }
    });
    return this;
  }
  testnet(config) {
    this.networks.set("testnet", {
      ...DEFAULT_NETWORK_CONFIG.testnet,
      ...config,
      genesisHash: DEFAULT_NETWORK_CONFIG.testnet.genesisHash,
      genesisId: DEFAULT_NETWORK_CONFIG.testnet.genesisId,
      caipChainId: DEFAULT_NETWORK_CONFIG.testnet.caipChainId,
      algod: {
        ...DEFAULT_NETWORK_CONFIG.testnet.algod,
        ...config.algod || {}
      }
    });
    return this;
  }
  betanet(config) {
    this.networks.set("betanet", {
      ...DEFAULT_NETWORK_CONFIG.betanet,
      ...config,
      genesisHash: DEFAULT_NETWORK_CONFIG.betanet.genesisHash,
      genesisId: DEFAULT_NETWORK_CONFIG.betanet.genesisId,
      caipChainId: DEFAULT_NETWORK_CONFIG.betanet.caipChainId,
      algod: {
        ...DEFAULT_NETWORK_CONFIG.betanet.algod,
        ...config.algod || {}
      }
    });
    return this;
  }
  fnet(config) {
    this.networks.set("fnet", {
      ...DEFAULT_NETWORK_CONFIG.fnet,
      ...config,
      genesisHash: DEFAULT_NETWORK_CONFIG.fnet.genesisHash,
      genesisId: DEFAULT_NETWORK_CONFIG.fnet.genesisId,
      caipChainId: DEFAULT_NETWORK_CONFIG.fnet.caipChainId,
      algod: {
        ...DEFAULT_NETWORK_CONFIG.fnet.algod,
        ...config.algod || {}
      }
    });
    return this;
  }
  localnet(config) {
    this.networks.set("localnet", {
      ...DEFAULT_NETWORK_CONFIG.localnet,
      ...config,
      algod: {
        ...DEFAULT_NETWORK_CONFIG.localnet.algod,
        ...config.algod || {}
      }
    });
    return this;
  }
  // Method to add custom networks (still needs full NetworkConfig)
  addNetwork(id, config) {
    if (DEFAULT_NETWORK_CONFIG[id]) {
      throw new Error(
        `Cannot add network with reserved id "${id}". Use the ${id}() method instead.`
      );
    }
    this.networks.set(id, config);
    return this;
  }
  build() {
    return Object.fromEntries(this.networks);
  }
};
var createNetworkConfig = () => new NetworkConfigBuilder().build();
function isValidToken(token) {
  if (typeof token === "string") return true;
  if (typeof token !== "object" || token === null) return false;
  if ("X-Algo-API-Token" in token && typeof token["X-Algo-API-Token"] === "string") return true;
  if ("get" in token && "post" in token && "delete" in token) return true;
  return Object.values(token).every((value) => typeof value === "string");
}
function isNetworkConfig(config) {
  if (typeof config !== "object" || config === null) return false;
  const { algod, isTestnet, genesisHash, genesisId, caipChainId } = config;
  const isValidAlgod = typeof algod === "object" && algod !== null && isValidToken(algod.token) && typeof algod.baseServer === "string";
  return isValidAlgod && (isTestnet === void 0 || typeof isTestnet === "boolean") && (genesisHash === void 0 || typeof genesisHash === "string") && (genesisId === void 0 || typeof genesisId === "string") && (caipChainId === void 0 || typeof caipChainId === "string");
}
var NetworkId = /* @__PURE__ */ ((NetworkId4) => {
  NetworkId4["MAINNET"] = "mainnet";
  NetworkId4["TESTNET"] = "testnet";
  NetworkId4["BETANET"] = "betanet";
  NetworkId4["FNET"] = "fnet";
  NetworkId4["LOCALNET"] = "localnet";
  return NetworkId4;
})(NetworkId || {});

// src/storage.ts
var StorageAdapter = class {
  static getItem(key) {
    if (typeof window === "undefined") {
      return null;
    }
    return localStorage.getItem(key);
  }
  static setItem(key, value) {
    if (typeof window === "undefined") {
      return;
    }
    localStorage.setItem(key, value);
  }
  static removeItem(key) {
    if (typeof window === "undefined") {
      return;
    }
    localStorage.removeItem(key);
  }
};

// src/store.ts
import algosdk from "algosdk";

// src/wallets/types.ts
var WalletId = /* @__PURE__ */ ((WalletId2) => {
  WalletId2["BIATEC"] = "biatec";
  WalletId2["DEFLY"] = "defly";
  WalletId2["DEFLY_WEB"] = "defly-web";
  WalletId2["CUSTOM"] = "custom";
  WalletId2["EXODUS"] = "exodus";
  WalletId2["KIBISIS"] = "kibisis";
  WalletId2["KMD"] = "kmd";
  WalletId2["LUTE"] = "lute";
  WalletId2["MAGIC"] = "magic";
  WalletId2["MNEMONIC"] = "mnemonic";
  WalletId2["PERA"] = "pera";
  WalletId2["WALLETCONNECT"] = "walletconnect";
  return WalletId2;
})(WalletId || {});
var SignTxnsError = class extends Error {
  code;
  data;
  constructor(message, code, data) {
    super(message);
    this.name = "SignTxnsError";
    this.code = code;
    this.data = data;
  }
};

// src/store.ts
var DEFAULT_STATE = {
  wallets: {},
  activeWallet: null,
  activeNetwork: "testnet",
  algodClient: new algosdk.Algodv2("", "https://testnet-api.4160.nodely.dev/"),
  managerStatus: "initializing",
  networkConfig: DEFAULT_NETWORK_CONFIG,
  customNetworkConfigs: {}
};
var LOCAL_STORAGE_KEY = "@txnlab/use-wallet:v4";
function addWallet(store, { walletId, wallet }) {
  store.setState((state) => {
    const updatedWallets = {
      ...state.wallets,
      [walletId]: {
        accounts: wallet.accounts.map((account) => ({ ...account })),
        activeAccount: wallet.activeAccount ? { ...wallet.activeAccount } : null
      }
    };
    return {
      ...state,
      wallets: updatedWallets,
      activeWallet: walletId
    };
  });
}
function removeWallet(store, { walletId }) {
  store.setState((state) => {
    const updatedWallets = { ...state.wallets };
    delete updatedWallets[walletId];
    return {
      ...state,
      wallets: updatedWallets,
      activeWallet: state.activeWallet === walletId ? null : state.activeWallet
    };
  });
}
function setActiveWallet(store, { walletId }) {
  store.setState((state) => ({
    ...state,
    activeWallet: walletId
  }));
}
function setActiveAccount(store, { walletId, address }) {
  store.setState((state) => {
    const wallet = state.wallets[walletId];
    if (!wallet) {
      logger.warn(`Wallet with id "${walletId}" not found`);
      return state;
    }
    const newActiveAccount = wallet.accounts.find((a2) => a2.address === address);
    if (!newActiveAccount) {
      logger.warn(`Account with address ${address} not found in wallet "${walletId}"`);
      return state;
    }
    const updatedWallet = {
      ...wallet,
      accounts: wallet.accounts.map((account) => ({ ...account })),
      activeAccount: { ...newActiveAccount }
    };
    const updatedWallets = {
      ...state.wallets,
      [walletId]: updatedWallet
    };
    return {
      ...state,
      wallets: updatedWallets
    };
  });
}
function setAccounts(store, { walletId, accounts }) {
  store.setState((state) => {
    const wallet = state.wallets[walletId];
    if (!wallet) {
      logger.warn(`Wallet with id "${walletId}" not found`);
      return state;
    }
    const newAccounts = accounts.map((account) => ({ ...account }));
    const isActiveAccountConnected = newAccounts.some(
      (account) => account.address === wallet.activeAccount?.address
    );
    const newActiveAccount = isActiveAccountConnected ? { ...wallet.activeAccount } : newAccounts[0] || null;
    const updatedWallet = {
      ...wallet,
      accounts: newAccounts,
      activeAccount: newActiveAccount
    };
    const updatedWallets = {
      ...state.wallets,
      [walletId]: updatedWallet
    };
    return {
      ...state,
      wallets: updatedWallets
    };
  });
}
function setActiveNetwork(store, { networkId, algodClient }) {
  store.setState((state) => ({
    ...state,
    activeNetwork: networkId,
    algodClient
  }));
}
function isValidPersistedState(state) {
  return typeof state === "object" && state !== null && "wallets" in state && "activeWallet" in state && "activeNetwork" in state && (!("customNetworkConfigs" in state) || typeof state.customNetworkConfigs === "object" && state.customNetworkConfigs !== null);
}

// src/utils.ts
import algosdk11 from "algosdk";

// src/wallets/walletconnect.ts
import algosdk2 from "algosdk";

// src/wallets/base.ts
var BaseWallet = class {
  id;
  metadata;
  store;
  getAlgodClient;
  subscribe;
  logger;
  constructor({
    id,
    metadata,
    store,
    subscribe,
    getAlgodClient
  }) {
    this.id = id;
    this.store = store;
    this.subscribe = subscribe;
    this.getAlgodClient = getAlgodClient;
    const ctor = this.constructor;
    this.metadata = { ...ctor.defaultMetadata, ...metadata };
    this.logger = logger.createScopedLogger(`Wallet:${this.id.toUpperCase()}`);
  }
  static defaultMetadata = { name: "Base Wallet", icon: "" };
  setActive = () => {
    this.logger.info(`Set active wallet: ${this.id}`);
    setActiveWallet(this.store, { walletId: this.id });
  };
  setActiveAccount = (account) => {
    this.logger.info(`Set active account: ${account}`);
    setActiveAccount(this.store, {
      walletId: this.id,
      address: account
    });
  };
  transactionSigner = async (txnGroup, indexesToSign) => {
    const signTxnsResult = await this.signTransactions(txnGroup, indexesToSign);
    const signedTxns = signTxnsResult.reduce((acc, value) => {
      if (value !== null) {
        acc.push(value);
      }
      return acc;
    }, []);
    return signedTxns;
  };
  // ---------- Derived Properties ------------------------------------ //
  get name() {
    return this.id.toUpperCase();
  }
  get accounts() {
    const state = this.store.state;
    const walletState = state.wallets[this.id];
    return walletState ? walletState.accounts : [];
  }
  get addresses() {
    return this.accounts.map((account) => account.address);
  }
  get activeAccount() {
    const state = this.store.state;
    const walletState = state.wallets[this.id];
    return walletState ? walletState.activeAccount : null;
  }
  get activeAddress() {
    return this.activeAccount?.address ?? null;
  }
  get activeNetwork() {
    const state = this.store.state;
    return state.activeNetwork;
  }
  get isConnected() {
    const state = this.store.state;
    const walletState = state.wallets[this.id];
    return walletState ? walletState.accounts.length > 0 : false;
  }
  get isActive() {
    const state = this.store.state;
    return state.activeWallet === this.id;
  }
  get activeNetworkConfig() {
    const { networkConfig, activeNetwork } = this.store.state;
    return networkConfig[activeNetwork];
  }
  // ---------- Protected Methods ------------------------------------- //
  onDisconnect = () => {
    this.logger.debug(`Removing wallet from store...`);
    removeWallet(this.store, { walletId: this.id });
  };
  manageWalletConnectSession = (action, targetWalletId) => {
    const walletId = targetWalletId || this.id;
    if (action === "backup") {
      const data = StorageAdapter.getItem("walletconnect");
      if (data) {
        StorageAdapter.setItem(`walletconnect-${walletId}`, data);
        StorageAdapter.removeItem("walletconnect");
        this.logger.debug(`Backed up WalletConnect session for ${walletId}`);
      }
    } else if (action === "restore") {
      const data = StorageAdapter.getItem(`walletconnect-${walletId}`);
      if (data) {
        StorageAdapter.setItem("walletconnect", data);
        StorageAdapter.removeItem(`walletconnect-${walletId}`);
        this.logger.debug(`Restored WalletConnect session for ${walletId}`);
      }
    }
  };
};

// src/wallets/walletconnect.ts
var SessionError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "SessionError";
  }
};
var ICON = `data:image/svg+xml;base64,${btoa(`
<svg viewBox="0 0 480 480" xmlns="http://www.w3.org/2000/svg">
  <rect width="480" height="480" fill="#FFFFFF" />
  <path fill="#3396FF" d="M126.6,168c62.6-61.3,164.2-61.3,226.8,0l7.5,7.4c3.1,3.1,3.1,8,0,11.1l-25.8,25.2c-1.6,1.5-4.1,1.5-5.7,0l-10.4-10.2c-43.7-42.8-114.5-42.8-158.2,0l-11.1,10.9c-1.6,1.5-4.1,1.5-5.7,0l-25.8-25.2c-3.1-3.1-3.1-8,0-11.1L126.6,168zM406.7,220.2l22.9,22.5c3.1,3.1,3.1,8,0,11.1L326.2,355.1c-3.1,3.1-8.2,3.1-11.3,0l-73.4-71.9c-0.8-0.8-2.1-0.8-2.8,0l-73.4,71.9c-3.1,3.1-8.2,3.1-11.3,0L50.3,253.8c-3.1-3.1-3.1-8,0-11.1l22.9-22.5c3.1-3.1,8.2-3.1,11.3,0l73.4,71.9c0.8,0.8,2.1,0.8,2.8,0 l73.4-71.9c3.1-3.1,8.2-3.1,11.3,0l73.4,71.9c0.8,0.8,2.1,0.8,2.8,0l73.4-71.9C398.5,217.1,403.6,217.1,406.7,220.2L406.7,220.2z" />
</svg>
`)}`;
var WalletConnect = class extends BaseWallet {
  client = null;
  options;
  modal = null;
  modalOptions;
  session = null;
  store;
  constructor({
    id,
    store,
    subscribe,
    getAlgodClient,
    options,
    metadata = {}
  }) {
    super({ id, metadata, getAlgodClient, store, subscribe });
    if (!options?.projectId) {
      this.logger.error("Missing required option: projectId");
      throw new Error("Missing required option: projectId");
    }
    const {
      projectId,
      relayUrl = "wss://relay.walletconnect.com",
      metadata: metadataOptions,
      ...modalOptions
    } = options;
    const clientMetadata = {
      ...this.getWindowMetadata(),
      ...metadataOptions
    };
    this.options = {
      projectId,
      relayUrl,
      metadata: clientMetadata
    };
    this.modalOptions = modalOptions;
    this.store = store;
  }
  static defaultMetadata = {
    name: "WalletConnect",
    icon: ICON
  };
  /**
   * Get metadata from the current window. This is adapted from the @walletconnect/utils
   * implementation, to avoid requiring the entire package as a dependency.
   * @see https://github.com/WalletConnect/walletconnect-utils/blob/master/browser/window-metadata/src/index.ts
   */
  getWindowMetadata() {
    let doc;
    let loc;
    const defaultMetadata = {
      name: "",
      description: "",
      url: "",
      icons: []
    };
    function getFromWindow(name2) {
      let res;
      if (typeof window !== "undefined" && typeof window[name2] !== "undefined") {
        res = window[name2];
      }
      return res;
    }
    function getFromWindowOrThrow(name2) {
      const res = getFromWindow(name2);
      if (!res) {
        throw new Error(`${name2} is not defined in Window`);
      }
      return res;
    }
    function getDocumentOrThrow() {
      return getFromWindowOrThrow("document");
    }
    function getLocationOrThrow() {
      return getFromWindowOrThrow("location");
    }
    try {
      doc = getDocumentOrThrow();
      loc = getLocationOrThrow();
    } catch (error) {
      this.logger.warn("Error getting window metadata:", error);
      return defaultMetadata;
    }
    function getIcons() {
      const links = doc.getElementsByTagName("link");
      const icons2 = [];
      for (let i = 0; i < links.length; i++) {
        const link = links[i];
        const rel = link.getAttribute("rel");
        if (rel) {
          if (rel.toLowerCase().indexOf("icon") > -1) {
            const href = link.getAttribute("href");
            if (href) {
              if (href.toLowerCase().indexOf("https:") === -1 && href.toLowerCase().indexOf("http:") === -1 && href.indexOf("//") !== 0) {
                let absoluteHref = loc.protocol + "//" + loc.host;
                if (href.indexOf("/") === 0) {
                  absoluteHref += href;
                } else {
                  const path = loc.pathname.split("/");
                  path.pop();
                  const finalPath = path.join("/");
                  absoluteHref += finalPath + "/" + href;
                }
                icons2.push(absoluteHref);
              } else if (href.indexOf("//") === 0) {
                const absoluteUrl = loc.protocol + href;
                icons2.push(absoluteUrl);
              } else {
                icons2.push(href);
              }
            }
          }
        }
      }
      return icons2;
    }
    function getWindowMetadataOfAny(...args) {
      const metaTags = doc.getElementsByTagName("meta");
      for (let i = 0; i < metaTags.length; i++) {
        const tag = metaTags[i];
        const attributes = ["itemprop", "property", "name"].map((target) => tag.getAttribute(target)).filter((attr) => {
          if (attr) {
            return args.includes(attr);
          }
          return false;
        });
        if (attributes.length && attributes) {
          const content = tag.getAttribute("content");
          if (content) {
            return content;
          }
        }
      }
      return "";
    }
    function getName() {
      let name2 = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");
      if (!name2) {
        name2 = doc.title;
      }
      return name2;
    }
    function getDescription() {
      const description2 = getWindowMetadataOfAny(
        "description",
        "og:description",
        "twitter:description",
        "keywords"
      );
      return description2;
    }
    const name = getName();
    const description = getDescription();
    const url = loc.origin;
    const icons = getIcons();
    const meta = {
      description,
      url,
      icons,
      name
    };
    return meta;
  }
  async initializeClient() {
    this.logger.info("Initializing client...");
    const SignClient = (await import("@walletconnect/sign-client")).SignClient;
    const client = await SignClient.init(this.options);
    client.on("session_event", (args) => {
      this.logger.info("EVENT: session_event", args);
    });
    client.on("session_update", ({ topic, params }) => {
      this.logger.info("EVENT: session_update", { topic, params });
      const { namespaces } = params;
      const session = client.session.get(topic);
      const updatedSession = { ...session, namespaces };
      this.onSessionConnected(updatedSession);
    });
    client.on("session_delete", () => {
      this.logger.info("EVENT: session_delete");
      this.session = null;
    });
    this.client = client;
    this.logger.info("Client initialized");
    return client;
  }
  async initializeModal() {
    this.logger.info("Initializing modal...");
    const WalletConnectModal = (await import("@walletconnect/modal")).WalletConnectModal;
    const modal = new WalletConnectModal({
      projectId: this.options.projectId,
      ...this.modalOptions
    });
    modal.subscribeModal((state) => this.logger.info(`Modal ${state.open ? "open" : "closed"}`));
    this.modal = modal;
    this.logger.info("Modal initialized");
    return modal;
  }
  onSessionConnected(session) {
    const caipAccounts = session.namespaces.algorand.accounts;
    if (!caipAccounts.length) {
      this.logger.error("No accounts found!");
      throw new Error("No accounts found!");
    }
    const accounts = [...new Set(caipAccounts.map((account) => account.split(":").pop()))];
    const walletAccounts = accounts.map((address, idx) => ({
      name: `${this.metadata.name} Account ${idx + 1}`,
      address
    }));
    const state = this.store.state;
    const walletState = state.wallets[this.id];
    if (!walletState) {
      const newWalletState = {
        accounts: walletAccounts,
        activeAccount: walletAccounts[0]
      };
      addWallet(this.store, {
        walletId: this.id,
        wallet: newWalletState
      });
      this.logger.info("Connected", newWalletState);
    } else {
      const match = compareAccounts(walletAccounts, walletState.accounts);
      if (!match) {
        this.logger.warn("Session accounts mismatch, updating accounts", {
          prev: walletState.accounts,
          current: walletAccounts
        });
        setAccounts(this.store, {
          walletId: this.id,
          accounts: walletAccounts
        });
      }
    }
    this.session = session;
    return walletAccounts;
  }
  get activeChainId() {
    const network = this.activeNetworkConfig;
    if (!network?.caipChainId) {
      this.logger.warn(`No CAIP-2 chain ID found for network: ${this.activeNetwork}`);
      return "";
    }
    return network.caipChainId;
  }
  connect = async () => {
    this.logger.info("Connecting...");
    try {
      const client = this.client || await this.initializeClient();
      const modal = this.modal || await this.initializeModal();
      const requiredNamespaces = {
        algorand: {
          chains: [this.activeChainId],
          methods: ["algo_signTxn"],
          events: []
        }
      };
      const { uri, approval } = await client.connect({ requiredNamespaces });
      if (!uri) {
        this.logger.error("No URI found");
        throw new Error("No URI found");
      }
      await modal.openModal({ uri });
      const session = await approval();
      const walletAccounts = this.onSessionConnected(session);
      this.logger.info("Connected successfully");
      return walletAccounts;
    } catch (error) {
      this.logger.error("Error connecting:", error.message);
      throw error;
    } finally {
      this.modal?.closeModal();
    }
  };
  disconnect = async () => {
    this.logger.info("Disconnecting...");
    try {
      this.onDisconnect();
      if (this.client && this.session) {
        await this.client.disconnect({
          topic: this.session.topic,
          reason: {
            message: "User disconnected.",
            code: 6e3
          }
        });
      }
      this.logger.info("Disconnected");
    } catch (error) {
      this.logger.error("Error disconnecting:", error.message);
      throw error;
    }
  };
  resumeSession = async () => {
    try {
      const state = this.store.state;
      const walletState = state.wallets[this.id];
      if (!walletState) {
        this.logger.info("No session to resume");
        return;
      }
      this.logger.info("Resuming session...");
      const client = this.client || await this.initializeClient();
      if (client.session.length) {
        const lastKeyIndex = client.session.keys.length - 1;
        const restoredSession = client.session.get(client.session.keys[lastKeyIndex]);
        this.onSessionConnected(restoredSession);
      }
      this.logger.info("Session resumed successfully");
    } catch (error) {
      this.logger.error("Error resuming session:", error.message);
      this.onDisconnect();
      throw error;
    }
  };
  processTxns(txnGroup, indexesToSign) {
    const txnsToSign = [];
    txnGroup.forEach((txn, index) => {
      const isIndexMatch = !indexesToSign || indexesToSign.includes(index);
      const signer = txn.sender.toString();
      const canSignTxn = this.addresses.includes(signer);
      const txnString = byteArrayToBase64(txn.toByte());
      if (isIndexMatch && canSignTxn) {
        txnsToSign.push({ txn: txnString });
      } else {
        txnsToSign.push({ txn: txnString, signers: [] });
      }
    });
    return txnsToSign;
  }
  processEncodedTxns(txnGroup, indexesToSign) {
    const txnsToSign = [];
    txnGroup.forEach((txnBuffer, index) => {
      const decodedObj = algosdk2.msgpackRawDecode(txnBuffer);
      const isSigned = isSignedTxn(decodedObj);
      const txn = isSigned ? algosdk2.decodeSignedTransaction(txnBuffer).txn : algosdk2.decodeUnsignedTransaction(txnBuffer);
      const isIndexMatch = !indexesToSign || indexesToSign.includes(index);
      const signer = txn.sender.toString();
      const canSignTxn = !isSigned && this.addresses.includes(signer);
      const txnString = byteArrayToBase64(txn.toByte());
      if (isIndexMatch && canSignTxn) {
        txnsToSign.push({ txn: txnString });
      } else {
        txnsToSign.push({ txn: txnString, signers: [] });
      }
    });
    return txnsToSign;
  }
  signTransactions = async (txnGroup, indexesToSign) => {
    try {
      if (!this.session) {
        this.logger.error("No session found!");
        throw new SessionError("No session found!");
      }
      this.logger.debug("Signing transactions...", { txnGroup, indexesToSign });
      let txnsToSign = [];
      if (isTransactionArray(txnGroup)) {
        const flatTxns = flattenTxnGroup(txnGroup);
        txnsToSign = this.processTxns(flatTxns, indexesToSign);
      } else {
        const flatTxns = flattenTxnGroup(txnGroup);
        txnsToSign = this.processEncodedTxns(flatTxns, indexesToSign);
      }
      const client = this.client || await this.initializeClient();
      this.logger.debug("Sending processed transactions to wallet...", [txnsToSign]);
      const request = formatJsonRpcRequest("algo_signTxn", [txnsToSign]);
      const signTxnsResult = await client.request({
        chainId: this.activeChainId,
        topic: this.session.topic,
        request
      });
      this.logger.debug("Received signed transactions from wallet", signTxnsResult);
      const signedTxns = signTxnsResult.reduce((acc, value) => {
        if (value) {
          let signedTxn;
          if (typeof value === "string") {
            signedTxn = base64ToByteArray(value);
          } else if (value instanceof Uint8Array) {
            signedTxn = value;
          } else if (Array.isArray(value)) {
            signedTxn = new Uint8Array(value);
          } else {
            this.logger.warn("Unexpected type in signTxnsResult", value);
            signedTxn = new Uint8Array();
          }
          acc.push(signedTxn);
        }
        return acc;
      }, []);
      const result = txnsToSign.reduce((acc, txn) => {
        if (txn.signers && txn.signers.length == 0) {
          acc.push(null);
        } else {
          const signedTxn = signedTxns.shift();
          if (signedTxn) {
            acc.push(signedTxn);
          }
        }
        return acc;
      }, []);
      this.logger.debug("Transactions signed successfully", result);
      return result;
    } catch (error) {
      this.logger.error("Error signing transactions:", error.message);
      throw error;
    }
  };
};

// src/wallets/biatec.ts
var ICON2 = `data:image/svg+xml;base64,${btoa(`
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 180"><path d="M94.27 151.629c-.861-.526-1.51-1.37-1.83-2.386-.197-.62-.18-.627 1.082-.437.705.105 1.6.356 1.988.557.696.36 1.815 1.876 1.815 2.459 0 .486-2.166.348-3.054-.193m23.953-.263c-.788-.419-2.095-2.123-2.108-2.75-.01-.433 2.467-.182 3.403.345.955.536 2.148 1.97 2.148 2.582 0 .503-2.397.38-3.443-.177m-9.024-1.165c-1.567-1.193-2.38-2.74-2.55-4.849-.075-.933-.054-1.697.045-1.697.866 0 2.714 1.67 3.439 3.107.398.789.657 3.888.351 4.195-.07.07-.648-.27-1.285-.756m-8.906-1.354c-.63-.684-1.21-1.648-1.387-2.305-.318-1.18-.136-3.416.278-3.416.555 0 2.108 1.697 2.505 2.737.472 1.237.457 3.905-.023 4.063-.16.053-.777-.433-1.373-1.08m-6.805-1.775c-2.764-.612-5.223-1.425-5.357-1.772-.08-.21.169-1.027.555-1.814s.701-1.469.701-1.515c0-.047-.803.067-1.786.253-.982.185-1.857.256-1.944.157-.088-.1-.365-.715-.618-1.367-.252-.652-.858-1.729-1.345-2.393-1.293-1.76-5.285-5.526-7.272-6.858-3.826-2.564-4.96-3.855-4.667-5.316.08-.402.692-1.574 1.359-2.606 1.65-2.551 2.51-4.472 2.512-5.62.002-.571-.364-1.69-.901-2.758l-.905-1.796.706-.532c1.936-1.46 4.649-4.916 4.205-5.36-.06-.06-.846.72-1.745 1.732-3.553 3.997-7.814 6.463-16.014 9.27-5.324 1.823-5.853 2.06-7.183 3.228-1.555 1.365-1.962 2.502-2.531 7.063-.284 2.275-.706 4.79-.937 5.591-.231.8-.403 2.17-.382 3.043.032 1.346-.157 2.06-1.248 4.698-1.498 3.622-1.068 3.708-4.138-.827l-2.036-3.008.747-.784c.411-.43 1.075-.978 1.475-1.216.955-.568.919-.922-.236-2.331-.53-.647-.917-1.209-.86-1.25s.43-.277.83-.526c1.788-1.12 2.7-4.727 2.987-11.822.214-5.274.595-6.46 2.195-6.83 6.634-1.535 7.58-1.98 8.618-4.066.926-1.858.9-3.701-.121-8.475-.87-4.072-1.047-7.21-.516-9.223.606-2.303 3.759-7.433 5.667-9.221.376-.353.684-.729.684-.835 0-.254-3.325-2.697-4.448-3.268-.482-.245-1.455-.45-2.163-.456-3.892-.03-6.628 1.877-8.722 6.08-.603 1.212-1.582 2.73-2.176 3.374-2.733 2.965-8.602 4.09-12.666 2.43l-.913-.374 1.323-.05c1.422-.054 3.498-.94 3.944-1.683.414-.69.076-.79-1.06-.314-1.443.605-4.075.597-5.039-.015-1.259-.8-2.23-1.81-2.795-2.908l-.535-1.042 1.243 1.095c1.51 1.328 2.691 1.752 4.425 1.585 1.506-.145 2.523-.851 1.65-1.147-3.195-1.08-5.834-3.078-7.07-5.35-.809-1.485-1.513-3.982-1.504-5.334l.006-.936.42.854c.232.47.941 1.333 1.576 1.918l1.155 1.064 2.189-.012 2.188-.011-1.012-.535c-.975-.514-3.353-2.766-3.353-3.175 0-.11.506.079 1.124.418 1.282.703 3.888 1.32 4.21.996.12-.118-.204-.612-.718-1.097-.513-.484-1.17-1.344-1.46-1.911l-.525-1.03 1.174.895c2.02 1.542 3.883 1.506 6.342-.123.69-.457 1.218-.863 1.175-.903s-.989.227-2.103.594c-1.87.618-2.11.64-3.151.305-1.284-.415-2.023-1.273-2.25-2.613l-.158-.926.486.595c1.07 1.31 2.652 1.255 6.363-.224 1.132-.451 2.892-1.036 3.91-1.3 2.732-.706 1.561-.926-2.298-.43-1.778.228-3.27.376-3.318.329-.047-.047.662-.415 1.575-.818 2.002-.883 4.78-1.152 6.858-.663 1.817.427 2.555.81 4.032 2.087 1.151.997 3.654 2.156 4.605 2.133.595-.015-2.96-3.395-4.552-4.328-1.639-.96-4.11-1.542-6.107-1.438-.92.049-1.627.016-1.571-.073.242-.388 3.44-.825 5.203-.71 4.048.265 6.96 2.546 10.902 8.537 2.553 3.883 4.234 5.67 6.137 6.524l1.092.49 2.215-1.027c4.747-2.2 8.797-2.518 16.097-1.26 2.25.387 4.717.704 5.482.704h1.39l.074 3.203.074 3.203.894-1.113c.88-1.096.894-1.152.846-3.516l-.049-2.402-1.61-1.721c-4.14-4.425-4.335-6.536-1.135-12.213 2.744-4.87 2.704-4.41.813-9.32-.883-2.292-1.696-4.167-1.807-4.167-.339 0-.205 4 .196 5.821.716 3.256.435 4.822-1.006 5.603-.371.2-2.144.33-4.904.36-3.6.036-4.348-.022-4.473-.348-.087-.227.102-.582.451-.845.53-.4.563-.53.274-1.09-.18-.35-.692-1.022-1.137-1.493s-.734-.933-.64-1.026c.093-.094 1.072-.036 2.175.128 3.023.45 3.76.398 4.211-.297.4-.615 2.887-9.725 2.704-9.907-.196-.196-1.55 1.62-2.759 3.7-1.782 3.068-3.14 3.895-6.379 3.889-2.485-.005-5.43-1.098-8.658-3.213-1.439-.943-3.02-1.855-3.514-2.027-1.524-.531-3.75-.392-5.163.324l-1.26.638.567-.603c.892-.95 3.048-2.004 4.432-2.167 1.94-.23 3.3.283 5.786 2.18 2.39 1.823 3.163 2.225 4.28 2.225.6 0 .497-.12-.745-.872-.792-.48-2.416-1.598-3.609-2.486-2.658-1.978-4.119-2.58-5.831-2.4l-1.26.132.926-.39c.667-.281 1.609-.36 3.373-.284 1.346.059 2.448.077 2.448.04 0-.278-2.537-1.455-3.71-1.722-.89-.202-1.231-.365-.884-.421.312-.051 1.86.225 3.44.614 2.564.63 3.167.687 5.602.525 5.536-.369 7.032-1.144 9.218-4.774l1.433-2.382-1.224 1.323c-.673.728-1.779 1.928-2.457 2.666-.677.739-1.53 1.417-1.893 1.508l-.662.165.61-.503c.334-.277 1.088-1.491 1.675-2.698 1.772-3.648 3.228-4.779 6.772-5.257 3.522-.476 4.797-.791 5.421-1.342.332-.293.429-.44.215-.329-.213.112-1.94.277-3.836.367-2.955.14-3.666.263-4.97.86-1.632.749-4.092 2.893-4.996 4.356-.764 1.236-.923.905-.224-.465 1.387-2.718 4.685-4.945 8.366-5.651l1.815-.349-1.058-.235c-.582-.13-1.952-.224-3.043-.209l-1.984.027 1.72-.82c1.427-.682 2.04-.822 3.611-.822 1.607 0 1.86-.06 1.679-.4-.539-1.005-1.377-1.452-2.69-1.432-.769.011-1.156-.067-.937-.19.534-.298 2.168-.34 4.169-.104 1.648.194 1.82.159 3.59-.733 1.023-.515 2.472-1.047 3.22-1.183 1.388-.253 3.607-.04 4.472.429.942.51 1.958 1.825 2.095 2.712.116.746 0 1.052-.671 1.777-.752.813-.811 1.018-.811 2.82 0 1.706-.105 2.127-.85 3.424-.467.814-.973 1.476-1.124 1.473s-.797-.242-1.435-.532c-1.277-.579-1.714-.435-1.988.655-.115.46.045.84.605 1.44.42.448 1.621 2.237 2.671 3.975 1.883 3.116 1.905 3.175 1.585 4.146-.258.78-.258 1.56 0 3.73.179 1.51.253 3.031.166 3.38-.128.509.033.795.805 1.432 1.367 1.126 5.02 2.947 5.914 2.947 1.268 0 1.588.247 1.588 1.227 0 1.057-.642 2.742-1.045 2.742-.153 0-.278-.298-.278-.662 0-.558-.123-.661-.793-.661-.436 0-2.162-.467-3.836-1.036l-3.044-1.036v1.788c0 .984-.077 3.057-.172 4.608l-.173 2.82h3.015l-.133.86c-.073.472-.206 2.11-.295 3.637-.373 6.42-.634 7.203-4.207 12.65-4.119 6.278-4.635 7.984-3.493 11.548.37 1.158.647 2.133.613 2.167-.246.246-2.569-1.19-3.783-2.34-2.616-2.473-2.922-3.975-1.146-5.619.954-.882 1.054-1.087.892-1.828-.417-1.91-.553-1.976-1-.482-.232.777-.693 1.849-1.024 2.382-.526.846-.603 1.318-.603 3.705v2.736l3.175 1.022c1.746.562 3.446 1.028 3.777 1.034.583.012.59-.012.194-.776-.224-.434-.479-1.307-.566-1.939-.208-1.523.53-3.065 3.905-8.159 4.537-6.845 5.478-9.25 5.681-14.513.07-1.82.19-3.93.267-4.692.137-1.353.17-1.398 1.379-1.933 2.27-1.004 4.245-3.717 6.253-8.589.526-1.274.459-1.204-1.891 1.985-1.019 1.382-2.13 2.751-2.47 3.042-.604.516-.603.506.048-.397.938-1.299 1.216-2.144 1.685-5.107.663-4.193 1.699-6.255 4.604-9.16 3.639-3.638 9.47-6.348 13.7-6.365.635-.003 1.201-.155 1.322-.356.117-.192 1.105-.92 2.196-1.615 1.092-.696 2.252-1.511 2.579-1.812.327-.3.66-.48.74-.4.081.081-.038.942-.263 1.914s-.41 1.88-.41 2.016c0 .37 1.393.3 1.992-.102.287-.192 1.296-.62 2.241-.953s1.998-.78 2.338-.994c.34-.215.665-.345.722-.288.302.302-1.982 3.526-2.927 4.132l-1.152.74c-.277.179 1.202 3.732 1.975 4.745.674.882.862 1.347.742 1.825-.089.354.045 1.273.296 2.044.645 1.98 2.913 6.751 3.698 7.779.808 1.06.82 1.416.075 2.363-.32.408-.648 1.225-.728 1.816-.118.879-.279 1.12-.89 1.335-1.457.512-2.298-.449-2.94-3.358-.113-.512-.325-.728-.715-.728-.634 0-.619.099.398 2.514.368.873.572 1.685.453 1.804-.12.119-.679.178-1.244.132-1.006-.082-1.03-.108-1.165-1.29-.11-.958-.407-1.515-1.444-2.716-1.28-1.483-1.523-1.617-3.974-2.186-.436-.102-1.235-.406-1.776-.677l-.981-.491-.311 1.124c-.462 1.668-.381 7.592.14 10.35.244 1.29.926 3.552 1.516 5.027 1.864 4.655 1.933 4.98 1.924 9.031-.006 2.853-.112 3.972-.461 4.87-.25.641-.415 1.204-.367 1.252.047.047 2.935.203 6.419.347 4.2.174 6.786.397 7.679.664 1.433.429 2.955 1.341 3.328 1.995.125.219 1.292 3.718 2.594 7.777 2.56 7.978 2.515 7.613 1.142 9.263-.582.7-.623.918-.458 2.455l.18 1.686-1.685 1.59c-2.476 2.335-2.487 2.338-2.833.702l-.825-3.894c-.497-2.344-.503-2.535-.09-2.844.245-.182.75-.332 1.121-.335 1.259-.007 1.444-.36.672-1.277l-.7-.833.461-1.209c.403-1.054.421-1.428.146-2.924-.856-4.647-3.463-7.755-6.516-7.769-1.198-.006-5.626.726-6.143 1.015-.419.235 1.36 2.035 4.026 4.073 1.954 1.494 2.487 2.265 2.708 3.918.115.858-.031 1.278-.963 2.753-1.122 1.776-2.596 4.941-4.015 8.62-.437 1.133-1.048 2.383-1.358 2.777-.546.695-.623.712-2.434.544-1.51-.14-2.034-.085-2.726.287-.933.503-1.032.488-5.234-.754l-1.852-.547 1.058-.93c2.452-2.155 4.96-4.035 5.375-4.028.245.004.743.417 1.107.919.364.5.74.914.835.918.336.014 2.673-2.777 3.423-4.09.928-1.622 1.429-3.721 1.19-4.992-.414-2.208-2.105-3.2-8.836-5.183-4.604-1.356-5.44-1.637-6.837-2.3-.81-.384-.92-.36-3.047.664-2.593 1.248-5.507 2.251-8.665 2.983-3.304.766-9.686.95-12.988.376-3.227-.562-7.639-2.035-9.626-3.214-.856-.508-1.618-.862-1.693-.787-.15.15 1.12 2.079 1.665 2.53.271.226.239.732-.166 2.586-1.245 5.713-2.66 8.612-7.189 14.73-2.852 3.852-3.402 5.685-2.327 7.762.66 1.274 9.278 9.763 11.016 10.85.797.498 1.576 1.26 1.929 1.889.496.883 2.158 5.275 2.158 5.704 0 .2-1.577.111-2.779-.154m46.76-1.68c-2.98-1.107-5.348-3.111-7.054-5.97-1.025-1.72-2.16-4.428-1.946-4.643.229-.229 3.039.644 4.916 1.527 3.417 1.608 6.275 5.198 6.594 8.283.178 1.723.063 1.76-2.51.803m-70.399.107c-2.923-.4-6.887-2.043-7.56-3.132-.23-.371 1.693-1.772 3.683-2.683 4.119-1.887 9.22-1.779 13.075.277 1.637.873 4.347 2.943 4.307 3.29-.014.122-.895.499-1.957.837-4.06 1.29-8.482 1.831-11.548 1.411m51.264-1.55c-1.687-.66-3.315-1.831-4.87-3.503l-1.323-1.421 2.116-.183c3.467-.298 6.424.354 8.757 1.932 1.096.742 2.753 2.456 2.753 2.848 0 .859-5.46 1.099-7.433.326m38.521-1.26c-3.84-.798-6.966-2.331-9.705-4.761-2.156-1.913-3.179-2.512-5.08-2.978-1.478-.362-3.339-1.249-3.339-1.591 0-.318 2.824-.81 5.689-.991 7.046-.446 13.549 2.741 16.133 7.908.513 1.024.932 2.025.932 2.224 0 .277-.479.354-2.05.33-1.128-.016-2.289-.08-2.58-.14m-61.217-2.076c-1.35-.421-2.52-1.449-3.238-2.845l-.51-.992h1.178c1.479 0 2.46.365 3.42 1.273.65.615 1.762 2.392 1.762 2.817 0 .255-1.426.117-2.612-.253m5.45-1.504c-1.583-1.153-2.396-3.509-1.878-5.442.192-.715.563-.742 1.334-.098 1.18.986 1.673 2.177 1.674 4.051 0 .974-.09 1.826-.2 1.895-.112.068-.53-.114-.93-.406m-26.254-1.075a150 150 0 0 0-3.968-1.97l-2.382-1.138 1.21-.001c2.527-.002 4.928 1.203 6.339 3.185.306.43.52.777.473.77-.046-.007-.799-.388-1.672-.845zm-14.354-3.608c-.764-.264-1.631-.699-1.927-.966-.59-.534-1.695-2.22-1.542-2.352.053-.045.573-.192 1.155-.325 1.324-.303 1.45-.925.662-3.265-.306-.908-.503-1.705-.438-1.77.066-.066.637.018 1.27.187.95.253 1.683.849 4.194 3.411 2.483 2.534 3.286 3.19 4.366 3.566.727.253 1.62.587 1.984.742l.662.28-.662.199c-.779.234-6.102.794-7.42.782-.503-.005-1.54-.225-2.304-.489m104.313-.83c-1.528-.484-4.719-2.704-4.75-3.303-.006-.145.88-.42 1.972-.61 2.368-.414 4.676-.11 6.582.864 1.41.721 3.082 2.35 2.83 2.756-.55.891-4.237 1.054-6.634.294m-56.58-.117c-2.06-.734-3.35-2.65-3.345-4.961.006-2.304.15-2.574 1.279-2.397 1.516.239 3.013.83 3.677 1.455l.609.572 1.523-1.507c.838-.829 1.593-1.507 1.679-1.507.085 0 .362.735.614 1.633.94 3.35-.383 5.974-3.431 6.806-1.302.356-1.35.354-2.605-.094m-75.315-.698c-6.533-.942-11.018-2.967-14.552-6.571-1.972-2.01-3.175-3.81-2.8-4.186.109-.109 1.32-.239 2.693-.29 5.235-.192 9.266 1.449 13.22 5.381 2.097 2.085 5.101 5.853 4.838 6.068-.05.041-1.58-.14-3.4-.402m97.327-1.25c4.267-5.096 8.959-7.442 13.334-6.666.982.174 1.84.405 1.906.513.198.32-1.54 2.713-2.834 3.904-2.314 2.13-5.42 3.148-10.492 3.438l-3.055.175zm17.502-.559c0-.646 1.702-5.318 2.447-6.715 1.472-2.762 4.84-5.965 5.538-5.267.161.161.234 1.18.176 2.481-.114 2.603-.705 4.023-2.51 6.03-1.524 1.695-5.651 4.23-5.651 3.471m8.04-1.157c3.728-2.356 7.725-5.133 8.864-6.158 1.353-1.218 1.403-1.24.984-.43-1.093 2.113-4.85 5.104-7.93 6.31-1.734.68-2.798.834-1.919.278m2.457-4.828c-.243-.511-.443-1.383-.443-1.937 0-1.018.973-3.223 1.5-3.399.368-.123 1.146 1.814 1.146 2.853 0 .855-.78 2.6-1.39 3.105-.298.247-.456.127-.813-.622m11.343.373c-1.157-.135-2.15-.292-2.206-.348-.16-.16 1.966-2.017 3.71-3.24 2.387-1.673 4.54-2.317 7.745-2.316 2.182 0 2.874.104 3.949.596l1.303.595-.907.936c-2.935 3.03-7.986 4.433-13.594 3.777m-135.543-5.98c-3.17-5.953-3.802-11.809-1.769-16.407.766-1.73 2.408-4.033 2.878-4.033.185 0 .7.685 1.142 1.522 2.02 3.82 2.643 8.569 1.708 13.03-.515 2.454-2.383 7.938-2.705 7.938-.089 0-.653-.923-1.254-2.05m131.543-.026c-2.11-1.55-3.023-3.093-3.023-5.108 0-1.215.77-3.056 1.587-3.796.494-.447.574-.438 1.965.243 1.713.838 2.676 1.892 3.072 3.363.464 1.725-.257 3.872-1.791 5.328l-.771.733zm-142.341-2.392c-.955-.434-3.028-2.462-3.028-2.963 0-.106.589-.273 1.309-.372 2.032-.28 3.923.381 5.269 1.84.602.654 1.095 1.295 1.095 1.426 0 .289-1.308.57-2.613.562-.527-.003-1.442-.225-2.032-.493m134.927-3.139c1.218-3.954 1.471-13.59.477-18.203a57 57 0 0 0-1.472-5.291c-1.025-3-1.187-3.508-1.031-3.229.06.11.227.199.369.199s.185-.12.095-.265-.099-.265-.019-.265c.285 0 2.284 4.27 2.94 6.28.942 2.884 1.488 6.584 1.481 10.037-.008 4.205-.63 7.156-2.126 10.088-.577 1.13-.974 1.491-.714.65m15.622-.53c.096-.4.694-1.798 1.33-3.108 1.78-3.673 4.396-6.043 7.61-6.899 2.261-.602 2.412-.555 2.244.699-.39 2.903-3.348 6.413-6.971 8.27-.455.233-1.63.726-2.608 1.094l-1.78.67zm-150.592-3.621c-5.551-2.683-8.865-5.295-11.436-9.013-2.092-3.028-3.72-7.066-3.72-9.231 0-.636.089-.69 1.135-.69 2.913 0 6.796 1.74 9.585 4.296 3.283 3.008 5.033 6.073 6.587 11.534 1.15 4.043 1.263 4.544 1.02 4.54-.111 0-1.539-.647-3.17-1.436m145.075.485c-.092-.241-.309-1.552-.48-2.914-.562-4.443.43-8.183 2.772-10.456.58-.562 1.164-1.022 1.3-1.022.405 0 1.01 1.75 1.186 3.43.324 3.1-.9 6.63-3.421 9.872-.926 1.19-1.226 1.431-1.357 1.09m-6.353-7.675c.34-1.413.908-2.21 1.957-2.745 1.55-.792 1.96-.718 1.754.314-.326 1.628-1.397 2.695-3.034 3.022-.84.168-.856.154-.677-.591m18.432-2.084c-.473-.206-.857-.469-.854-.585.01-.368 1.945-1.592 2.816-1.781.461-.1 1.34-.047 1.952.118l1.114.3-.882.909c-.764.789-2.17 1.45-3.022 1.422-.145-.005-.651-.178-1.124-.383m-4.19-2.014c.437-5.243 1.85-8.992 4.434-11.754 1.589-1.698 4.011-3.172 5.51-3.353.608-.073.669.016.745 1.087.125 1.742-.655 4.812-1.81 7.117-1.233 2.466-3.244 4.75-6.16 7-3.185 2.457-2.932 2.466-2.719-.097M164.535 96.2c.011-.601.996-2.432 1.613-2.997.74-.68 1.86-1.142 2.764-1.142.74 0 .783.213.287 1.402-.328.784-2.05 2.558-2.496 2.573-.105.004-.636.11-1.182.237-.703.163-.99.142-.986-.073M39.38 92.511l-1.19-.287 1.894-.184c2.429-.237 4.211-.836 5.755-1.933 1.705-1.212 2.43-2.3 3.187-4.777.358-1.173 1.027-2.644 1.487-3.27.855-1.16 1.328-1.354.772-.315-.17.317-.42 1.753-.555 3.191s-.371 2.944-.524 3.347c-1.29 3.39-6.255 5.33-10.826 4.228m132.353-3.022c-1.37-3.004-1.722-4.62-1.596-7.322.12-2.584.663-4.209 1.984-5.941l.698-.915.593.689c1.538 1.787 2.37 6.366 1.72 9.457-.375 1.79-1.903 5.61-2.293 5.734-.158.05-.656-.715-1.106-1.702m6.655.323c.094-.582.245-3.618.336-6.747.16-5.514-.097-11.175-.726-16.007-.66-5.078-2.584-11.438-4.788-15.834-.572-1.142-.914-1.998-.76-1.903.154.096.28.02.28-.17 0-.608 1.905 2.465 3.056 4.93 3.19 6.83 5.492 18.482 5.039 25.5-.219 3.379-.79 6.78-1.52 9.04-.672 2.084-1.164 2.722-.917 1.191m-5.129-39.936c0-.065-.119-.19-.264-.28s-.265-.038-.265.116.12.28.265.28.264-.052.264-.116M21.39 87.46c-6.885-6.262-9.634-10.983-10.312-17.71-.218-2.153.098-6.211.514-6.628.377-.377 2.86.757 4.714 2.153 4.287 3.228 7.128 8.67 7.976 15.276.349 2.717.746 9.923.547 9.92-.073-.001-1.62-1.356-3.44-3.01m141.818 1.495c.002-1.223.51-2.654 1.254-3.539.681-.81 2.635-1.902 2.999-1.677.248.154-.193 2.347-.65 3.224-.523 1.007-1.444 1.82-2.616 2.31l-.989.413zm19.715-9.65c.101-.48.414-1.25.694-1.712.53-.872 2.361-1.937 3.331-1.937.515 0 .537.075.29.992-.432 1.599-1.891 2.901-3.749 3.347-.733.176-.746.16-.566-.69m-1.078-4.864c-.434-3.474.426-7.949 2.004-10.427.992-1.557 3.308-3.704 3.996-3.704.79 0 1.023 5.098.34 7.427-.775 2.639-3.22 6.102-5.41 7.661l-.744.53zM27.106 70.74c-.83-2.163.852-9.285 3.442-14.577 3.414-6.977 9.876-14.173 15.518-17.28 1.338-.736 1.306-.696-.732.921-3.554 2.82-6.93 6.51-9.617 10.514-2.78 4.142-4.184 7.582-5.825 14.274-.593 2.419-1.273 4.885-1.512 5.482-.446 1.116-.991 1.401-1.274.666m148.415-4.429c-3.31-1.775-5.714-4.87-6.05-7.787-.123-1.073-.097-1.124.573-1.122 1.742.006 4.537 2.38 5.833 4.954.468.928 1.437 4.572 1.263 4.746-.028.028-.757-.328-1.62-.79M24.465 63.817c-1.392-2.767-2.046-5.175-2.208-8.138-.16-2.924.292-6.48.823-6.48.632 0 2.73 1.536 3.654 2.676 1.65 2.036 2.173 3.325 2.185 5.393.01 1.729-.094 2.069-1.554 5.094-.86 1.782-1.663 3.24-1.783 3.24s-.623-.803-1.117-1.785m155.049-4.47c-.602-3.045-.356-5.571.757-7.767.795-1.57 2.708-3.351 3.137-2.921.187.187.302 1.33.302 3 0 2.617-.03 2.756-1.001 4.573-.551 1.03-1.462 2.322-2.024 2.871l-1.022.998zm-68.432-2.831c0-.451.748-1.115 1.521-1.35.762-.233.743.064-.061.978-.678.77-1.46.969-1.46.372M33.59 54.752c1.046-1.877 3.42-4.082 5.433-5.045 1.457-.699 2.23-.892 3.93-.982 2.15-.115 3.863.18 4.728.812.444.324.393.442-.74 1.701-1.47 1.635-3.438 2.97-5.575 3.778-1.242.47-2.33.63-4.998.735l-3.41.135zm76.965.194c0-.802 1.282-2.19 2.17-2.35.969-.176 1.534.041 1.534.587 0 .382-.305.583-1.245.82-.685.172-1.518.608-1.852.968l-.607.655zm57.018-.605c-.437-.225-.965-.578-1.173-.783-.327-.323-.22-.446.794-.905 1.314-.597 2.774-.659 4.347-.184 1.386.417 1.347.95-.122 1.69-1.377.695-2.73.76-3.846.182m-58.306-1.16c.174-.5.815-1.406 1.424-2.015.918-.918 1.368-1.152 2.637-1.37 1.42-.246 2.024-.224 3.048.107.8.26-.765 1.148-2.022 1.148-1.584 0-2.915.6-4.27 1.928l-1.133 1.109zm65.577-2.87c-.75-1.497-.906-2.129-1.001-4.048-.094-1.886-.02-2.485.431-3.506.3-.677.655-1.231.79-1.231.33 0 1.475 1.777 1.856 2.883.497 1.442.383 4.31-.236 5.965-.3.803-.638 1.517-.75 1.586-.11.069-.602-.673-1.09-1.649m-65.359.239c.662-1.25 2.453-2.918 3.604-3.357 1.384-.53 4.318-.42 5.512.206l.757.397-.576.403c-.45.315-1.084.374-2.904.27-2.854-.163-3.938.155-5.54 1.625-.876.802-1.1.922-.853.456m-79.602-1.036c-1.895-1.894-2.474-3.183-2.62-5.824-.066-1.211-.008-2.314.128-2.45.332-.332 2.019.945 2.831 2.145.348.513.825 1.5 1.06 2.192.47 1.384.581 4.818.164 5.076-.144.089-.848-.423-1.563-1.139m78.698-.58c.528-1.848 2.227-3.934 3.94-4.841 1.648-.872 4.113-.74 7.331.392l2.55.897-.936.614c-.919.602-.967.606-2.55.2-2.732-.698-3.209-.739-5.014-.424-2.025.352-3.826 1.419-4.84 2.865-.543.777-.635.833-.481.297m54.957-.028c-.619-.306-1.125-.665-1.125-.797 0-.133.387-.477.86-.765 1.455-.887 4.475-.65 6.244.49l.621.401-1.15.602c-1.547.81-3.894.84-5.45.07m-113.51-5.029c-.621-.307-1.376-.872-1.677-1.255l-.548-.696.883-.372c2.07-.872 5.296-.261 6.675 1.263.498.55.494.556-.662 1.08-1.52.69-3.253.682-4.672-.02m69.126-.293c-2.905-1.128-5.647-1.179-7.871-.147-.837.388-1.522.665-1.522.615 0-.292 2.738-1.751 3.95-2.106 1.796-.525 4.726-.535 6.634-.023 1.759.472 3.564.489 4.61.043.696-.298.59-.32-1.07-.226-1.83.103-1.852.096-3.683-1.16-1.013-.694-2.318-1.413-2.9-1.596l-1.058-.333.988-.018c.544-.01 2.135.28 3.535.644 2.6.675 4.605.856 4.605.415 0-.347-1.479-1.36-2.616-1.791-.935-.355-.915-.361.9-.261 2.1.115 3.862.79 4.957 1.899.72.729.727.73.727.13 0-.934-1.81-2.484-3.47-2.973-1.732-.51-.9-.598.957-.102 2.68.716 5.39 2.515 6.21 4.124.295.578.537 1.15.537 1.273 0 .122-1.102.361-2.448.532s-3.511.671-4.812 1.112c-3.03 1.027-4.41 1.017-7.16-.05m-83.06-2.246c-.331-4.672.95-8.655 3.622-11.257l1.343-1.308.418.754c.31.56.419 1.506.419 3.664 0 2.803-.036 2.984-.958 4.895-.887 1.84-3.687 5.524-4.365 5.745-.197.064-.358-.772-.48-2.493m125.87-.33c-.464-.283-1.05-.829-1.301-1.212-.556-.848-.22-1.17 1.221-1.176 1.652-.007 4.104 1.78 3.588 2.615-.3.486-2.579.34-3.507-.227m-104.922-.902c-1.831-.683-4.166-2.965-3.74-3.655.203-.328 3.603-.26 4.628.093.494.17 1.341.6 1.882.955 1.055.692 2.477 2.374 2.223 2.628-.352.353-4.033.337-4.993-.021m.993-5.296c-.727-.191-2.034-.56-2.902-.82l-1.58-.473.898-.75c2.53-2.112 6.92-3.595 9.62-3.25 1.876.239 3.85 1.003 4.937 1.91l.907.758-1.14.825c-1.943 1.409-3.805 1.977-6.771 2.068-1.607.05-3.165-.056-3.969-.268" style="fill:teal;stroke-width:.264583"></path></svg>
`)}`;
var BiatecWallet = class extends WalletConnect {
  static defaultMetadata = {
    name: "BiatecWallet",
    icon: ICON2
  };
};

// src/wallets/custom.ts
var ICON3 = `data:image/svg+xml;base64,${btoa(`
<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
  <rect width="24" height="24" fill="#525252" />
</svg>
`)}`;
var CustomWallet = class extends BaseWallet {
  provider;
  store;
  constructor({
    id,
    store,
    subscribe,
    getAlgodClient,
    options,
    metadata = {}
  }) {
    super({ id, metadata, getAlgodClient, store, subscribe });
    if (!options?.provider) {
      this.logger.error("Missing required option: provider");
      throw new Error("Missing required option: provider");
    }
    this.provider = options.provider;
    this.store = store;
  }
  static defaultMetadata = {
    name: "Custom",
    icon: ICON3
  };
  connect = async (args) => {
    this.logger.info("Connecting...");
    try {
      if (!this.provider.connect) {
        this.logger.error("Method not supported: connect");
        throw new Error("Method not supported: connect");
      }
      const walletAccounts = await this.provider.connect(args);
      if (walletAccounts.length === 0) {
        this.logger.error("No accounts found!");
        throw new Error("No accounts found!");
      }
      const activeAccount = walletAccounts[0];
      const walletState = {
        accounts: walletAccounts,
        activeAccount
      };
      addWallet(this.store, {
        walletId: this.id,
        wallet: walletState
      });
      this.logger.info("\u2705 Connected.", walletState);
      return walletAccounts;
    } catch (error) {
      this.logger.error("Error connecting:", error.message || error);
      throw error;
    }
  };
  disconnect = async () => {
    this.logger.info("Disconnecting...");
    this.onDisconnect();
    await this.provider.disconnect?.();
  };
  resumeSession = async () => {
    try {
      const state = this.store.state;
      const walletState = state.wallets[this.id];
      if (!walletState) {
        this.logger.info("No session to resume");
        return;
      }
      this.logger.info("Resuming session...");
      const result = await this.provider.resumeSession?.();
      if (Array.isArray(result)) {
        const walletAccounts = result;
        if (walletAccounts.length === 0) {
          this.logger.error("No accounts found!");
          throw new Error("No accounts found!");
        }
        const match = compareAccounts(walletAccounts, walletState.accounts);
        if (!match) {
          this.logger.warn("Session accounts mismatch, updating accounts", {
            prev: walletState.accounts,
            current: walletAccounts
          });
          setAccounts(this.store, {
            walletId: this.id,
            accounts: walletAccounts
          });
        }
      }
      this.logger.info("Session resumed.");
    } catch (error) {
      this.logger.error("Error resuming session:", error.message);
      throw error;
    }
  };
  signTransactions = async (txnGroup, indexesToSign) => {
    if (!this.provider.signTransactions) {
      this.logger.error("Method not supported: signTransactions");
      throw new Error("Method not supported: signTransactions");
    }
    this.logger.debug("Signing transactions...", { txnGroup, indexesToSign });
    return await this.provider.signTransactions(txnGroup, indexesToSign);
  };
  transactionSigner = async (txnGroup, indexesToSign) => {
    if (!this.provider.transactionSigner) {
      this.logger.error("Method not supported: transactionSigner");
      throw new Error("Method not supported: transactionSigner");
    }
    this.logger.debug("Transaction signer called...", { txnGroup, indexesToSign });
    return await this.provider.transactionSigner(txnGroup, indexesToSign);
  };
};

// src/wallets/defly.ts
import algosdk3 from "algosdk";
var ICON4 = `data:image/svg+xml;base64,${btoa(`
<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg">
  <rect width="1024" height="1024" />
  <path fill="#FFFFFF" d="M779.9,684.4L512,230L244.1,684.4L512,529.5L779.9,684.4z" />
  <path fill="#FFFFFF" d="M733.1,730L512,613.5L290.9,730L512,658L733.1,730z" />
</svg>
`)}`;
var DeflyWallet = class extends BaseWallet {
  client = null;
  options;
  store;
  constructor({
    id,
    store,
    subscribe,
    getAlgodClient,
    options = {},
    metadata = {}
  }) {
    super({ id, metadata, getAlgodClient, store, subscribe });
    this.options = options;
    this.store = store;
  }
  static defaultMetadata = {
    name: "Defly",
    icon: ICON4
  };
  async initializeClient() {
    this.logger.info("Initializing client...");
    const { DeflyWalletConnect } = await import("@blockshake/defly-connect");
    const client = new DeflyWalletConnect(this.options);
    this.client = client;
    this.logger.info("Client initialized");
    return client;
  }
  connect = async () => {
    this.logger.info("Connecting...");
    const currentActiveWallet = this.store.state.activeWallet;
    if (currentActiveWallet && currentActiveWallet !== this.id) {
      this.manageWalletConnectSession("backup", currentActiveWallet);
    }
    const client = this.client || await this.initializeClient();
    const accounts = await client.connect();
    client.connector?.on("disconnect", this.onDisconnect);
    if (accounts.length === 0) {
      this.logger.error("No accounts found!");
      throw new Error("No accounts found!");
    }
    const walletAccounts = accounts.map((address, idx) => ({
      name: `${this.metadata.name} Account ${idx + 1}`,
      address
    }));
    const activeAccount = walletAccounts[0];
    const walletState = {
      accounts: walletAccounts,
      activeAccount
    };
    addWallet(this.store, {
      walletId: this.id,
      wallet: walletState
    });
    this.logger.info("\u2705 Connected.", walletState);
    return walletAccounts;
  };
  disconnect = async () => {
    this.logger.info("Disconnecting...");
    const client = this.client || await this.initializeClient();
    const currentActiveWallet = this.store.state.activeWallet;
    if (currentActiveWallet && currentActiveWallet !== this.id) {
      this.manageWalletConnectSession("backup", currentActiveWallet);
      this.manageWalletConnectSession("restore", this.id);
      await client.disconnect();
      await new Promise((resolve) => setTimeout(resolve, 500));
      this.manageWalletConnectSession("restore", currentActiveWallet);
    } else {
      await client.disconnect();
    }
    this.onDisconnect();
    this.logger.info("Disconnected");
  };
  setActive = () => {
    this.logger.info(`Set active wallet: ${this.id}`);
    const currentActiveWallet = this.store.state.activeWallet;
    if (currentActiveWallet && currentActiveWallet === "pera" /* PERA */) {
      this.manageWalletConnectSession("backup", currentActiveWallet);
    }
    this.manageWalletConnectSession("restore");
    setActiveWallet(this.store, { walletId: this.id });
  };
  resumeSession = async () => {
    try {
      const state = this.store.state;
      const walletState = state.wallets[this.id];
      if (!walletState) {
        this.logger.info("No session to resume");
        return;
      }
      if (state.activeWallet === "pera" /* PERA */) {
        this.logger.info("Skipping reconnectSession for Defly (inactive)");
        return;
      }
      this.logger.info("Resuming session...");
      const client = this.client || await this.initializeClient();
      const accounts = await client.reconnectSession();
      if (accounts.length === 0) {
        this.logger.error("No accounts found!");
        throw new Error("No accounts found!");
      }
      const walletAccounts = accounts.map((address, idx) => ({
        name: `${this.metadata.name} Account ${idx + 1}`,
        address
      }));
      const match = compareAccounts(walletAccounts, walletState.accounts);
      if (!match) {
        this.logger.warn("Session accounts mismatch, updating accounts", {
          prev: walletState.accounts,
          current: walletAccounts
        });
        setAccounts(this.store, {
          walletId: this.id,
          accounts: walletAccounts
        });
      }
      this.logger.info("Session resumed");
    } catch (error) {
      this.logger.error("Error resuming session:", error.message);
      this.onDisconnect();
      throw error;
    }
  };
  processTxns(txnGroup, indexesToSign) {
    const txnsToSign = [];
    txnGroup.forEach((txn, index) => {
      const isIndexMatch = !indexesToSign || indexesToSign.includes(index);
      const signer = txn.sender.toString();
      const canSignTxn = this.addresses.includes(signer);
      if (isIndexMatch && canSignTxn) {
        txnsToSign.push({ txn });
      } else {
        txnsToSign.push({ txn, signers: [] });
      }
    });
    return txnsToSign;
  }
  processEncodedTxns(txnGroup, indexesToSign) {
    const txnsToSign = [];
    txnGroup.forEach((txnBuffer, index) => {
      const decodedObj = algosdk3.msgpackRawDecode(txnBuffer);
      const isSigned = isSignedTxn(decodedObj);
      const txn = isSigned ? algosdk3.decodeSignedTransaction(txnBuffer).txn : algosdk3.decodeUnsignedTransaction(txnBuffer);
      const isIndexMatch = !indexesToSign || indexesToSign.includes(index);
      const signer = txn.sender.toString();
      const canSignTxn = !isSigned && this.addresses.includes(signer);
      if (isIndexMatch && canSignTxn) {
        txnsToSign.push({ txn });
      } else {
        txnsToSign.push({ txn, signers: [] });
      }
    });
    return txnsToSign;
  }
  signTransactions = async (txnGroup, indexesToSign) => {
    try {
      this.logger.debug("Signing transactions...", { txnGroup, indexesToSign });
      let txnsToSign = [];
      if (isTransactionArray(txnGroup)) {
        const flatTxns = flattenTxnGroup(txnGroup);
        txnsToSign = this.processTxns(flatTxns, indexesToSign);
      } else {
        const flatTxns = flattenTxnGroup(txnGroup);
        txnsToSign = this.processEncodedTxns(flatTxns, indexesToSign);
      }
      const client = this.client || await this.initializeClient();
      this.logger.debug("Sending processed transactions to wallet...", [txnsToSign]);
      const signedTxns = await client.signTransaction([txnsToSign]);
      this.logger.debug("Received signed transactions from wallet", signedTxns);
      const result = txnsToSign.reduce((acc, txn) => {
        if (txn.signers && txn.signers.length == 0) {
          acc.push(null);
        } else {
          const signedTxn = signedTxns.shift();
          if (signedTxn) {
            acc.push(signedTxn);
          }
        }
        return acc;
      }, []);
      this.logger.debug("Transactions signed successfully", result);
      return result;
    } catch (error) {
      this.logger.error("Error signing transactions:", error.message);
      throw error;
    }
  };
};

// src/wallets/avm-web-provider.ts
import algosdk4 from "algosdk";
function isAVMWebProviderSDKError(error) {
  return typeof error === "object" && "code" in error && "message" in error;
}
var AVMProvider = class extends BaseWallet {
  avmWebClient = null;
  avmWebProviderSDK = null;
  providerId;
  constructor(args) {
    super(args);
    this.providerId = args.providerId;
  }
  async _initializeAVMWebProviderSDK() {
    if (!this.avmWebProviderSDK) {
      this.logger.info("Initializing @agoralabs-sh/avm-web-provider...");
      const module = await import("@agoralabs-sh/avm-web-provider");
      this.avmWebProviderSDK = module.default ? module.default : module;
      if (!this.avmWebProviderSDK) {
        throw new Error(
          "Failed to initialize, the @agoralabs-sh/avm-web-provider SDK was not provided"
        );
      }
      if (!this.avmWebProviderSDK.AVMWebClient) {
        throw new Error(
          "Failed to initialize, AVMWebClient missing from @agoralabs-sh/avm-web-provider SDK"
        );
      }
      this.logger.info("@agoralabs-sh/avm-web-provider SDK initialized");
    }
    return this.avmWebProviderSDK;
  }
  async _initializeAVMWebClient() {
    const avmWebProviderSDK = await this._initializeAVMWebProviderSDK();
    if (!avmWebProviderSDK.AVMWebClient) {
      throw new Error("Failed to initialize, AVMWebClient not found");
    }
    if (!this.avmWebClient) {
      this.logger.info("Initializing new AVM Web Client...");
      this.avmWebClient = avmWebProviderSDK.AVMWebClient.init();
      this.logger.info("AVM Web Client initialized");
    }
    return this.avmWebClient;
  }
  async _getGenesisHash() {
    const network = this.activeNetworkConfig;
    if (network.genesisHash) {
      return network.genesisHash;
    }
    const algodClient = this.getAlgodClient();
    const version = await algodClient.versionsCheck().do();
    return algosdk4.bytesToBase64(version.genesisHashB64);
  }
  _mapAVMWebProviderAccountToWalletAccounts(accounts) {
    return accounts.map(({ address, name }, idx) => ({
      name: name || `[${this.metadata.name}] Account ${idx + 1}`,
      address
    }));
  }
  processTxns(txnGroup, indexesToSign) {
    const txnsToSign = [];
    txnGroup.forEach((txn, index) => {
      const isIndexMatch = !indexesToSign || indexesToSign.includes(index);
      const signer = txn.sender.toString();
      const canSignTxn = this.addresses.includes(signer);
      const txnString = byteArrayToBase64(txn.toByte());
      if (isIndexMatch && canSignTxn) {
        txnsToSign.push({ txn: txnString });
      } else {
        txnsToSign.push({ txn: txnString, signers: [] });
      }
    });
    return txnsToSign;
  }
  processEncodedTxns(txnGroup, indexesToSign) {
    const txnsToSign = [];
    txnGroup.forEach((txnBuffer, index) => {
      const decodedObj = algosdk4.msgpackRawDecode(txnBuffer);
      const isSigned = isSignedTxn(decodedObj);
      const txn = isSigned ? algosdk4.decodeSignedTransaction(txnBuffer).txn : algosdk4.decodeUnsignedTransaction(txnBuffer);
      const isIndexMatch = !indexesToSign || indexesToSign.includes(index);
      const signer = txn.sender.toString();
      const canSignTxn = !isSigned && this.addresses.includes(signer);
      const txnString = byteArrayToBase64(txn.toByte());
      if (isIndexMatch && canSignTxn) {
        txnsToSign.push({ txn: txnString });
      } else {
        txnsToSign.push({ txn: txnString, signers: [] });
      }
    });
    return txnsToSign;
  }
  /**
   * Common methods
   * These methods can be overridden by specific wallet providers if needed
   */
  async connect() {
    try {
      this.logger.info("Connecting...");
      const result = await this._enable();
      this.logger.info(`Successfully connected on network "${result.genesisId}"`);
      const walletAccounts = this._mapAVMWebProviderAccountToWalletAccounts(result.accounts);
      const walletState = {
        accounts: walletAccounts,
        activeAccount: walletAccounts[0]
      };
      addWallet(this.store, {
        walletId: this.id,
        wallet: walletState
      });
      this.logger.info("\u2705 Connected.", walletState);
      return walletAccounts;
    } catch (error) {
      this.logger.error(
        "Error connecting: ",
        isAVMWebProviderSDKError(error) ? `${error.message} (code: ${error.code})` : error.message
      );
      throw error;
    }
  }
  async disconnect() {
    try {
      this.logger.info("Disconnecting...");
      this.onDisconnect();
      const result = await this._disable();
      this.logger.info(
        `Successfully disconnected${result.sessionIds && result.sessionIds.length ? ` sessions [${result.sessionIds.join(",")}]` : ""} on network "${result.genesisId}"`
      );
    } catch (error) {
      this.logger.error(
        "Error disconnecting: ",
        isAVMWebProviderSDKError(error) ? `${error.message} (code: ${error.code})` : error.message
      );
      throw error;
    }
  }
  async resumeSession() {
    const state = this.store.state;
    const walletState = state.wallets[this.id];
    if (!walletState) {
      this.logger.info("No session to resume");
      return;
    }
    try {
      this.logger.info("Resuming session...");
      const result = await this._enable();
      if (result.accounts.length === 0) {
        throw new Error("No accounts found!");
      }
      const walletAccounts = this._mapAVMWebProviderAccountToWalletAccounts(result.accounts);
      const match = compareAccounts(walletAccounts, walletState.accounts);
      if (!match) {
        this.logger.warn("Session accounts mismatch, updating accounts", {
          prev: walletState.accounts,
          current: walletAccounts
        });
        setAccounts(this.store, {
          walletId: this.id,
          accounts: walletAccounts
        });
      }
      this.logger.info("Session resumed successfully");
    } catch (error) {
      this.logger.error(
        "Error resuming session: ",
        isAVMWebProviderSDKError(error) ? `${error.message} (code: ${error.code})` : error.message
      );
      this.onDisconnect();
      throw error;
    }
  }
  async signTransactions(txnGroup, indexesToSign) {
    try {
      this.logger.debug("Signing transactions...", { txnGroup, indexesToSign });
      let txnsToSign = [];
      if (isTransactionArray(txnGroup)) {
        const flatTxns = flattenTxnGroup(txnGroup);
        txnsToSign = this.processTxns(flatTxns, indexesToSign);
      } else {
        const flatTxns = flattenTxnGroup(txnGroup);
        txnsToSign = this.processEncodedTxns(flatTxns, indexesToSign);
      }
      this.logger.debug("Sending processed transactions to wallet...", txnsToSign);
      const signTxnsResult = await this._signTransactions(txnsToSign);
      this.logger.debug("Received signed transactions from wallet", signTxnsResult);
      const result = signTxnsResult.stxns.map((value) => {
        if (value === null) {
          return null;
        }
        return base64ToByteArray(value);
      });
      this.logger.debug("Transactions signed successfully", result);
      return result;
    } catch (error) {
      this.logger.error(
        "Error signing transactions: ",
        isAVMWebProviderSDKError(error) ? `${error.message} (code: ${error.code})` : error.message
      );
      throw error;
    }
  }
};

// src/wallets/defly-web.ts
var DEFLY_WEB_PROVIDER_ID = "95426e60-5f2e-49e9-b912-c488577be962";
var ICON5 = `data:image/svg+xml;base64,${btoa(`
<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg">
  <rect width="1024" height="1024" />
  <path fill="#FFFFFF" d="M779.9,684.4L512,230L244.1,684.4L512,529.5L779.9,684.4z" />
  <path fill="#FFFFFF" d="M733.1,730L512,613.5L290.9,730L512,658L733.1,730z" />
</svg>
`)}`;
var DeflyWebWallet = class extends AVMProvider {
  constructor({
    id,
    store,
    subscribe,
    getAlgodClient,
    metadata = {}
  }) {
    super({
      id,
      metadata,
      getAlgodClient,
      store,
      subscribe,
      providerId: DEFLY_WEB_PROVIDER_ID
    });
  }
  static defaultMetadata = {
    name: "Defly Web Wallet",
    icon: ICON5
  };
  /**
   * Calls the "enable" method on the provider. This method will timeout after 3 minutes.
   * @returns {Promise<AVMWebProviderSDK.IEnableResult>} a promise that resolves to the result.
   * @protected
   * @throws {MethodCanceledError} if the method was cancelled by the user.
   * @throws {MethodNotSupportedError} if the method is not supported for the configured network.
   * @throws {MethodTimedOutError} if the method timed out by lack of response (>= 3 minutes).
   * @throws {NetworkNotSupportedError} if the network is not supported for the configured network.
   * @throws {UnknownError} if the response result is empty.
   */
  async _enable() {
    const {
      ARC0027MethodEnum,
      ARC0027MethodTimedOutError,
      ARC0027UnknownError,
      DEFAULT_REQUEST_TIMEOUT
    } = await this._initializeAVMWebProviderSDK();
    const avmWebClient = await this._initializeAVMWebClient();
    const genesisHash = await this._getGenesisHash();
    return new Promise((resolve, reject) => {
      const timerId = window.setTimeout(() => {
        avmWebClient.removeListener(listenerId);
        reject(
          new ARC0027MethodTimedOutError({
            method: ARC0027MethodEnum.Enable,
            message: `no response from provider "${this.metadata.name}"`,
            providerId: DEFLY_WEB_PROVIDER_ID
          })
        );
      }, DEFAULT_REQUEST_TIMEOUT);
      const listenerId = avmWebClient.onEnable(({ error, method, result }) => {
        avmWebClient.removeListener(listenerId);
        window.clearTimeout(timerId);
        if (error) {
          return reject(error);
        }
        if (!result) {
          return reject(
            new ARC0027UnknownError({
              message: `received response, but "${method}" request details were empty for provider "${this.metadata.name}"`,
              providerId: DEFLY_WEB_PROVIDER_ID
            })
          );
        }
        return resolve(result);
      });
      avmWebClient.enable({
        genesisHash,
        providerId: DEFLY_WEB_PROVIDER_ID
      });
    });
  }
  /**
   * Calls the "disable" method on the provider. This method will timeout after 0.75 seconds.
   * @returns {Promise<AVMWebProviderSDK.IDisableResult>} a promise that resolves to the result.
   * @protected
   * @throws {MethodNotSupportedError} if the method is not supported for the configured network.
   * @throws {MethodTimedOutError} if the method timed out by lack of response (>= 3 minutes).
   * @throws {NetworkNotSupportedError} if the network is not supported for the configured network.
   * @throws {UnknownError} if the response result is empty.
   */
  async _disable() {
    const {
      ARC0027MethodEnum,
      ARC0027MethodTimedOutError,
      ARC0027UnknownError,
      LOWER_REQUEST_TIMEOUT
    } = await this._initializeAVMWebProviderSDK();
    const avmWebClient = await this._initializeAVMWebClient();
    const genesisHash = await this._getGenesisHash();
    return new Promise((resolve, reject) => {
      const timerId = window.setTimeout(() => {
        avmWebClient.removeListener(listenerId);
        reject(
          new ARC0027MethodTimedOutError({
            method: ARC0027MethodEnum.Disable,
            message: `no response from provider "${this.metadata.name}"`,
            providerId: DEFLY_WEB_PROVIDER_ID
          })
        );
      }, LOWER_REQUEST_TIMEOUT);
      const listenerId = avmWebClient.onDisable(({ error, method, result }) => {
        avmWebClient.removeListener(listenerId);
        window.clearTimeout(timerId);
        if (error) {
          return reject(error);
        }
        if (!result) {
          return reject(
            new ARC0027UnknownError({
              message: `received response, but "${method}" request details were empty for provider "${this.metadata.name}"`,
              providerId: DEFLY_WEB_PROVIDER_ID
            })
          );
        }
        this.logger.debug("Disable successful", { result });
        return resolve(result);
      });
      this.logger.debug("Sending disable request...", { genesisHash });
      avmWebClient.disable({
        genesisHash,
        providerId: DEFLY_WEB_PROVIDER_ID
      });
    });
  }
  /**
   * Calls the "signTransactions" method to sign the supplied ARC-0001 transactions. This method will timeout after 3
   * minutes.
   * @returns {Promise<AVMWebProviderSDK.ISignTransactionsResult>} a promise that resolves to the result.
   * @protected
   * @throws {InvalidInputError} if computed group ID for the txns does not match the assigned group ID.
   * @throws {InvalidGroupIdError} if the unsigned txns is malformed or not conforming to ARC-0001.
   * @throws {MethodCanceledError} if the method was cancelled by the user.
   * @throws {MethodNotSupportedError} if the method is not supported for the configured network.
   * @throws {MethodTimedOutError} if the method timed out by lack of response (>= 3 minutes).
   * @throws {NetworkNotSupportedError} if the network is not supported for the configured network.
   * @throws {UnauthorizedSignerError} if a signer in the request is not authorized by the provider.
   * @throws {UnknownError} if the response result is empty.
   */
  async _signTransactions(txns) {
    const {
      ARC0027MethodEnum,
      ARC0027MethodTimedOutError,
      ARC0027UnknownError,
      DEFAULT_REQUEST_TIMEOUT
    } = await this._initializeAVMWebProviderSDK();
    const avmWebClient = await this._initializeAVMWebClient();
    return new Promise((resolve, reject) => {
      const timerId = window.setTimeout(() => {
        avmWebClient.removeListener(listenerId);
        reject(
          new ARC0027MethodTimedOutError({
            method: ARC0027MethodEnum.SignTransactions,
            message: `no response from provider "${this.metadata.name}"`,
            providerId: DEFLY_WEB_PROVIDER_ID
          })
        );
      }, DEFAULT_REQUEST_TIMEOUT);
      const listenerId = avmWebClient.onSignTransactions(({ error, method, result }) => {
        avmWebClient.removeListener(listenerId);
        window.clearTimeout(timerId);
        if (error) {
          return reject(error);
        }
        if (!result) {
          return reject(
            new ARC0027UnknownError({
              message: `received response, but "${method}" request details were empty for provider "${this.metadata.name}"`,
              providerId: DEFLY_WEB_PROVIDER_ID
            })
          );
        }
        this.logger.debug("Sign transactions successful", { result });
        return resolve(result);
      });
      this.logger.debug("Sending sign transactions request...", { txns });
      avmWebClient.signTransactions({
        txns,
        providerId: DEFLY_WEB_PROVIDER_ID
      });
    });
  }
};

// src/wallets/exodus.ts
import algosdk5 from "algosdk";
var ICON6 = `data:image/svg+xml;base64,${btoa(`
<svg viewBox="0 0 300 300" xmlns="http://www.w3.org/2000/svg">
  <linearGradient id="grad1" gradientUnits="userSpaceOnUse" x1="246.603" y1="9.2212" x2="174.158" y2="308.5426" gradientTransform="matrix(1 0 0 -1 0 302)">
    <stop offset="0" stop-color="#0B46F9" />
    <stop offset="1" stop-color="#BBFBE0" />
  </linearGradient>
  <path fill="url(#grad1)" d="M274.7,93.9L166.6,23v39.6l69.4,45.1l-8.2,25.8h-61.2v32.9h61.2l8.2,25.8l-69.4,45.1V277l108.2-70.7L257,150.1L274.7,93.9z" />
  
  <linearGradient id="grad2" gradientUnits="userSpaceOnUse" x1="129.3516" y1="-19.1573" x2="56.9066" y2="280.1641" gradientTransform="matrix(1 0 0 -1 0 302)">
    <stop offset="0" stop-color="#0B46F9" />
    <stop offset="1" stop-color="#BBFBE0" />
  </linearGradient>
  <path fill="url(#grad2)" d="M72.5,166.4h61v-32.9H72.2l-7.9-25.8l69.2-45.1V23L25.3,93.9L43,150.1l-17.7,56.2L133.7,277v-39.6l-69.4-45.1L72.5,166.4z" />
  
  <mask id="mask1" maskUnits="userSpaceOnUse" x="25.4" y="23" width="247.6" height="254">
    <path fill="url(#grad1)" d="M274.7,93.9L166.6,23v39.6l69.4,45.1l-8.2,25.8h-61.2v32.9h61.2l8.2,25.8l-69.4,45.1V277l108.2-70.7L257,150.1L274.7,93.9z" />
    <path fill="url(#grad2)" d="M72.5,166.4h61v-32.9H72.2l-7.9-25.8l69.2-45.1V23L25.3,93.9L43,150.1l-17.7,56.2L133.7,277v-39.6l-69.4-45.1L72.5,166.4z" />
  </mask>
  
  <linearGradient id="grad3" gradientUnits="userSpaceOnUse" x1="46.4662" y1="228.7554" x2="171.8638" y2="135.1039" gradientTransform="matrix(1 0 0 -1 0 302)">
    <stop offset="0.1198" stop-color="#8952FF" stop-opacity="0.87" />
    <stop offset="1" stop-color="#DABDFF" stop-opacity="0" />
  </linearGradient>
  <rect x="25.4" y="23" width="247.6" height="254" fill="url(#grad3)" mask="url(#mask1)" />
</svg>
`)}`;
var ExodusWallet = class extends BaseWallet {
  client = null;
  options;
  store;
  constructor({
    id,
    store,
    subscribe,
    getAlgodClient,
    options = {},
    metadata = {}
  }) {
    super({ id, metadata, getAlgodClient, store, subscribe });
    this.options = options;
    this.store = store;
  }
  static defaultMetadata = {
    name: "Exodus",
    icon: ICON6
  };
  async initializeClient() {
    this.logger.info("Initializing client...");
    if (typeof window === "undefined" || window.algorand === void 0) {
      this.logger.error("Exodus is not available.");
      throw new Error("Exodus is not available.");
    }
    const client = window.algorand;
    this.client = client;
    this.logger.info("Client initialized");
    return client;
  }
  connect = async () => {
    this.logger.info("Connecting...");
    const client = this.client || await this.initializeClient();
    const { accounts } = await client.enable(this.options);
    if (accounts.length === 0) {
      this.logger.error("No accounts found!");
      throw new Error("No accounts found!");
    }
    const walletAccounts = accounts.map((address, idx) => ({
      name: `${this.metadata.name} Account ${idx + 1}`,
      address
    }));
    const activeAccount = walletAccounts[0];
    const walletState = {
      accounts: walletAccounts,
      activeAccount
    };
    addWallet(this.store, {
      walletId: this.id,
      wallet: walletState
    });
    this.logger.info("\u2705 Connected.", walletState);
    return walletAccounts;
  };
  disconnect = async () => {
    this.logger.info("Disconnecting...");
    this.onDisconnect();
    this.logger.info("Disconnected.");
  };
  resumeSession = async () => {
    try {
      const state = this.store.state;
      const walletState = state.wallets[this.id];
      if (!walletState) {
        this.logger.info("No session to resume");
        return;
      }
      this.logger.info("Resuming session...");
      const client = await this.initializeClient();
      if (!client.isConnected) {
        this.logger.error("Exodus is not connected.");
        throw new Error("Exodus is not connected.");
      }
      this.logger.info("Session resumed");
    } catch (error) {
      this.logger.error("Error resuming session:", error.message);
      this.onDisconnect();
      throw error;
    }
  };
  processTxns(txnGroup, indexesToSign) {
    const txnsToSign = [];
    txnGroup.forEach((txn, index) => {
      const isIndexMatch = !indexesToSign || indexesToSign.includes(index);
      const signer = txn.sender.toString();
      const canSignTxn = this.addresses.includes(signer);
      const txnString = byteArrayToBase64(txn.toByte());
      if (isIndexMatch && canSignTxn) {
        txnsToSign.push({ txn: txnString });
      } else {
        txnsToSign.push({ txn: txnString, signers: [] });
      }
    });
    return txnsToSign;
  }
  processEncodedTxns(txnGroup, indexesToSign) {
    const txnsToSign = [];
    txnGroup.forEach((txnBuffer, index) => {
      const decodedObj = algosdk5.msgpackRawDecode(txnBuffer);
      const isSigned = isSignedTxn(decodedObj);
      const txn = isSigned ? algosdk5.decodeSignedTransaction(txnBuffer).txn : algosdk5.decodeUnsignedTransaction(txnBuffer);
      const isIndexMatch = !indexesToSign || indexesToSign.includes(index);
      const signer = txn.sender.toString();
      const canSignTxn = !isSigned && this.addresses.includes(signer);
      const txnString = byteArrayToBase64(txn.toByte());
      if (isIndexMatch && canSignTxn) {
        txnsToSign.push({ txn: txnString });
      } else {
        txnsToSign.push({ txn: txnString, signers: [] });
      }
    });
    return txnsToSign;
  }
  signTransactions = async (txnGroup, indexesToSign) => {
    try {
      this.logger.debug("Signing transactions...", { txnGroup, indexesToSign });
      let txnsToSign = [];
      if (isTransactionArray(txnGroup)) {
        const flatTxns = flattenTxnGroup(txnGroup);
        txnsToSign = this.processTxns(flatTxns, indexesToSign);
      } else {
        const flatTxns = flattenTxnGroup(txnGroup);
        txnsToSign = this.processEncodedTxns(flatTxns, indexesToSign);
      }
      const client = this.client || await this.initializeClient();
      this.logger.debug("Sending processed transactions to wallet...", txnsToSign);
      const signTxnsResult = await client.signTxns(txnsToSign);
      this.logger.debug("Received signed transactions from wallet", signTxnsResult);
      const result = signTxnsResult.map((value) => {
        if (value === null) {
          return null;
        }
        return base64ToByteArray(value);
      });
      this.logger.debug("Transactions signed successfully", result);
      return result;
    } catch (error) {
      this.logger.error("Error signing transactions:", error.message);
      throw error;
    }
  };
};

// src/wallets/kibisis.ts
var KIBISIS_AVM_WEB_PROVIDER_ID = "f6d1c86b-4493-42fb-b88d-a62407b4cdf6";
var ICON7 = `data:image/svg+xml;base64,${btoa(`
<svg viewBox="0 0 480 480" xmlns="http://www.w3.org/2000/svg">
  <rect fill="#801C96" width="480" height="480" />
  <path fill="#FFFFFF" d="M393.5,223.2c0-7.3-0.6-14.6-1.6-21.6c-0.9-6.5-2.3-12.8-4-18.9c-18-64.9-77.4-112.5-148-112.5c-70.6,0-130,47.6-148,112.5c-1.7,6.2-3,12.5-4,19c-1,7.1-1.6,14.3-1.6,21.6h0v85.5h19.7v-85.5c0-7.2,0.6-14.4,1.8-21.4c14,1.1,27.6,4.3,40.5,9.5c15.9,6.4,30.3,15.6,42.6,27.3c12.3,11.7,22,25.4,28.7,40.6c6.9,15.6,10.5,32.2,10.5,49.2v81.4h0.1h19.6h0.1v-81.5c0.1-17.1,3.6-33.7,10.5-49.2c6.7-15.2,16.4-28.8,28.7-40.6c4.2-4,8.6-7.7,13.2-11.1v132.2h19.7V223.2h0c0-2.5-0.1-5-0.4-7.4c3.3-1.6,6.6-3.1,10-4.5c12.9-5.2,26.4-8.4,40.4-9.5c1.2,7,1.7,14.2,1.8,21.4v85.5h19.7L393.5,223.2L393.5,223.2z M240.1,277.3c-11.6-29.3-32.7-54.1-59.8-71c2.9-10,8.2-19.1,15.8-26.6c11.8-11.8,27.4-18.2,44-18.2s32.3,6.5,44,18.2c4.1,4.1,7.5,8.7,10.3,13.6c5.6-3.4,11.4-6.4,17.4-9.2c-14-25.2-40.9-42.3-71.8-42.3c-35.9,0-66.3,23-77.5,55.1c-15.5-7.1-32.5-11.8-50.4-13.5c1.3-4,2.7-7.9,4.3-11.8c6.7-15.9,16.4-30.3,28.7-42.6s26.6-22,42.6-28.7c16.5-7,34-10.5,52.1-10.5s35.6,3.5,52.1,10.5c15.9,6.7,30.3,16.4,42.6,28.7s22,26.6,28.7,42.6c1.6,3.9,3.1,7.8,4.3,11.8C309,189.2,260.1,226.5,240.1,277.3z" />
  <path fill="#FFFFFF" d="M158.1,359.8h19.7V245.5c-6.1-5.4-12.7-10-19.7-14V359.8z" />
</svg>
`)}`;
var KibisisWallet = class extends AVMProvider {
  constructor({
    id,
    store,
    subscribe,
    getAlgodClient,
    metadata = {}
  }) {
    super({
      id,
      metadata,
      getAlgodClient,
      store,
      subscribe,
      providerId: KIBISIS_AVM_WEB_PROVIDER_ID
    });
  }
  static defaultMetadata = {
    name: "Kibisis",
    icon: ICON7
  };
  /**
   * Calls the "enable" method on the provider. This method will timeout after 3 minutes.
   * @returns {Promise<AVMWebProviderSDK.IEnableResult>} a promise that resolves to the result.
   * @protected
   * @throws {MethodCanceledError} if the method was cancelled by the user.
   * @throws {MethodNotSupportedError} if the method is not supported for the configured network.
   * @throws {MethodTimedOutError} if the method timed out by lack of response (>= 3 minutes).
   * @throws {NetworkNotSupportedError} if the network is not supported for the configured network.
   * @throws {UnknownError} if the response result is empty.
   */
  async _enable() {
    const {
      ARC0027MethodEnum,
      ARC0027MethodTimedOutError,
      ARC0027UnknownError,
      DEFAULT_REQUEST_TIMEOUT
    } = await this._initializeAVMWebProviderSDK();
    const avmWebClient = await this._initializeAVMWebClient();
    const genesisHash = await this._getGenesisHash();
    return new Promise((resolve, reject) => {
      const timerId = window.setTimeout(() => {
        avmWebClient.removeListener(listenerId);
        reject(
          new ARC0027MethodTimedOutError({
            method: ARC0027MethodEnum.Enable,
            message: `no response from provider "${this.metadata.name}"`,
            providerId: KIBISIS_AVM_WEB_PROVIDER_ID
          })
        );
      }, DEFAULT_REQUEST_TIMEOUT);
      const listenerId = avmWebClient.onEnable(({ error, method, result }) => {
        avmWebClient.removeListener(listenerId);
        window.clearTimeout(timerId);
        if (error) {
          return reject(error);
        }
        if (!result) {
          return reject(
            new ARC0027UnknownError({
              message: `received response, but "${method}" request details were empty for provider "${this.metadata.name}"`,
              providerId: KIBISIS_AVM_WEB_PROVIDER_ID
            })
          );
        }
        return resolve(result);
      });
      avmWebClient.enable({
        genesisHash,
        providerId: KIBISIS_AVM_WEB_PROVIDER_ID
      });
    });
  }
  /**
   * Calls the "disable" method on the provider. This method will timeout after 0.75 seconds.
   * @returns {Promise<AVMWebProviderSDK.IDisableResult>} a promise that resolves to the result.
   * @protected
   * @throws {MethodNotSupportedError} if the method is not supported for the configured network.
   * @throws {MethodTimedOutError} if the method timed out by lack of response (>= 3 minutes).
   * @throws {NetworkNotSupportedError} if the network is not supported for the configured network.
   * @throws {UnknownError} if the response result is empty.
   */
  async _disable() {
    const {
      ARC0027MethodEnum,
      ARC0027MethodTimedOutError,
      ARC0027UnknownError,
      LOWER_REQUEST_TIMEOUT
    } = await this._initializeAVMWebProviderSDK();
    const avmWebClient = await this._initializeAVMWebClient();
    const genesisHash = await this._getGenesisHash();
    return new Promise((resolve, reject) => {
      const timerId = window.setTimeout(() => {
        avmWebClient.removeListener(listenerId);
        reject(
          new ARC0027MethodTimedOutError({
            method: ARC0027MethodEnum.Disable,
            message: `no response from provider "${this.metadata.name}"`,
            providerId: KIBISIS_AVM_WEB_PROVIDER_ID
          })
        );
      }, LOWER_REQUEST_TIMEOUT);
      const listenerId = avmWebClient.onDisable(({ error, method, result }) => {
        avmWebClient.removeListener(listenerId);
        window.clearTimeout(timerId);
        if (error) {
          return reject(error);
        }
        if (!result) {
          return reject(
            new ARC0027UnknownError({
              message: `received response, but "${method}" request details were empty for provider "${this.metadata.name}"`,
              providerId: KIBISIS_AVM_WEB_PROVIDER_ID
            })
          );
        }
        this.logger.debug("Disable successful", { result });
        return resolve(result);
      });
      this.logger.debug("Sending disable request...", { genesisHash });
      avmWebClient.disable({
        genesisHash,
        providerId: KIBISIS_AVM_WEB_PROVIDER_ID
      });
    });
  }
  /**
   * Calls the "signTransactions" method to sign the supplied ARC-0001 transactions. This method will timeout after 3
   * minutes.
   * @returns {Promise<AVMWebProviderSDK.ISignTransactionsResult>} a promise that resolves to the result.
   * @protected
   * @throws {InvalidInputError} if computed group ID for the txns does not match the assigned group ID.
   * @throws {InvalidGroupIdError} if the unsigned txns is malformed or not conforming to ARC-0001.
   * @throws {MethodCanceledError} if the method was cancelled by the user.
   * @throws {MethodNotSupportedError} if the method is not supported for the configured network.
   * @throws {MethodTimedOutError} if the method timed out by lack of response (>= 3 minutes).
   * @throws {NetworkNotSupportedError} if the network is not supported for the configured network.
   * @throws {UnauthorizedSignerError} if a signer in the request is not authorized by the provider.
   * @throws {UnknownError} if the response result is empty.
   */
  async _signTransactions(txns) {
    const {
      ARC0027MethodEnum,
      ARC0027MethodTimedOutError,
      ARC0027UnknownError,
      DEFAULT_REQUEST_TIMEOUT
    } = await this._initializeAVMWebProviderSDK();
    const avmWebClient = await this._initializeAVMWebClient();
    return new Promise((resolve, reject) => {
      const timerId = window.setTimeout(() => {
        avmWebClient.removeListener(listenerId);
        reject(
          new ARC0027MethodTimedOutError({
            method: ARC0027MethodEnum.SignTransactions,
            message: `no response from provider "${this.metadata.name}"`,
            providerId: KIBISIS_AVM_WEB_PROVIDER_ID
          })
        );
      }, DEFAULT_REQUEST_TIMEOUT);
      const listenerId = avmWebClient.onSignTransactions(({ error, method, result }) => {
        avmWebClient.removeListener(listenerId);
        window.clearTimeout(timerId);
        if (error) {
          return reject(error);
        }
        if (!result) {
          return reject(
            new ARC0027UnknownError({
              message: `received response, but "${method}" request details were empty for provider "${this.metadata.name}"`,
              providerId: KIBISIS_AVM_WEB_PROVIDER_ID
            })
          );
        }
        this.logger.debug("Sign transactions successful", { result });
        return resolve(result);
      });
      this.logger.debug("Sending sign transactions request...", { txns });
      avmWebClient.signTransactions({
        txns,
        providerId: KIBISIS_AVM_WEB_PROVIDER_ID
      });
    });
  }
};

// src/wallets/kmd.ts
import algosdk6 from "algosdk";
var ICON8 = `data:image/svg+xml;base64,${btoa(`
<svg viewBox="0 0 400 400" xmlns="http://www.w3.org/2000/svg">
  <linearGradient id="algokitGradient" gradientUnits="userSpaceOnUse" x1="0" y1="400" x2="400" y2="0">
    <stop offset="0" style="stop-color:#31D8EE"/>
    <stop offset="1" style="stop-color:#01DC94"/>
  </linearGradient>
  <rect fill="url(#algokitGradient)" width="400" height="400" />
  <path fill="#FFFFFF" d="M309.2,309.3H275l-22.2-82.7l-47.9,82.7h-38.3l73.9-128l-11.9-44.5l-99.6,172.6H90.8L217.1,90.6 h33.5l14.7,54.3h34.6l-23.6,41L309.2,309.3z" />
</svg>
`)}`;
var KmdWallet = class extends BaseWallet {
  client = null;
  options;
  walletName;
  walletId = "";
  password = null;
  store;
  constructor({
    id,
    store,
    subscribe,
    getAlgodClient,
    options,
    metadata = {}
  }) {
    super({ id, metadata, getAlgodClient, store, subscribe });
    const {
      token = "a".repeat(64),
      baseServer = "http://127.0.0.1",
      port = 4002,
      wallet = "unencrypted-default-wallet",
      promptForPassword = () => Promise.resolve(prompt("KMD password") || "")
    } = options || {};
    this.options = { token, baseServer, port, promptForPassword };
    this.walletName = wallet;
    this.store = store;
  }
  static defaultMetadata = {
    name: "KMD",
    icon: ICON8
  };
  async initializeClient() {
    this.logger.info("Initializing client...");
    const { token, baseServer, port } = this.options;
    const client = new algosdk6.Kmd(token, baseServer, port);
    this.client = client;
    this.logger.info("Client initialized");
    return client;
  }
  connect = async () => {
    this.logger.info("Connecting...");
    if (!this.client) {
      await this.initializeClient();
    }
    try {
      const token = await this.fetchToken();
      const accounts = await this.fetchAccounts(token);
      if (accounts.length === 0) {
        throw new Error("No accounts found!");
      }
      const walletAccounts = accounts.map((address, idx) => ({
        name: `${this.metadata.name} Account ${idx + 1}`,
        address
      }));
      const activeAccount = walletAccounts[0];
      const walletState = {
        accounts: walletAccounts,
        activeAccount
      };
      addWallet(this.store, {
        walletId: this.id,
        wallet: walletState
      });
      await this.releaseToken(token);
      this.logger.info("\u2705 Connected.", walletState);
      return walletAccounts;
    } catch (error) {
      this.logger.error("Error connecting:", error.message);
      throw error;
    }
  };
  disconnect = async () => {
    this.logger.info("Disconnecting...");
    this.onDisconnect();
    this.logger.info("Disconnected.");
  };
  resumeSession = async () => {
    try {
      const state = this.store.state;
      const walletState = state.wallets[this.id];
      if (!walletState) {
        this.logger.info("No session to resume");
        return;
      }
      this.logger.info("Resuming session...");
      await this.initializeClient();
      this.logger.info("Session resumed");
    } catch (error) {
      this.logger.error("Error resuming session:", error.message);
      this.onDisconnect();
      throw error;
    }
  };
  processTxns(txnGroup, indexesToSign) {
    const txnsToSign = [];
    txnGroup.forEach((txn, index) => {
      const isIndexMatch = !indexesToSign || indexesToSign.includes(index);
      const signer = txn.sender.toString();
      const canSignTxn = this.addresses.includes(signer);
      if (isIndexMatch && canSignTxn) {
        txnsToSign.push(txn);
      }
    });
    return txnsToSign;
  }
  processEncodedTxns(txnGroup, indexesToSign) {
    const txnsToSign = [];
    txnGroup.forEach((txnBuffer, index) => {
      const decodedObj = algosdk6.msgpackRawDecode(txnBuffer);
      const isSigned = isSignedTxn(decodedObj);
      const txn = isSigned ? algosdk6.decodeSignedTransaction(txnBuffer).txn : algosdk6.decodeUnsignedTransaction(txnBuffer);
      const isIndexMatch = !indexesToSign || indexesToSign.includes(index);
      const signer = txn.sender.toString();
      const canSignTxn = !isSigned && this.addresses.includes(signer);
      if (isIndexMatch && canSignTxn) {
        txnsToSign.push(txn);
      }
    });
    return txnsToSign;
  }
  signTransactions = async (txnGroup, indexesToSign) => {
    try {
      this.logger.debug("Signing transactions...", { txnGroup, indexesToSign });
      let txnsToSign = [];
      if (isTransactionArray(txnGroup)) {
        const flatTxns = flattenTxnGroup(txnGroup);
        txnsToSign = this.processTxns(flatTxns, indexesToSign);
      } else {
        const flatTxns = flattenTxnGroup(txnGroup);
        txnsToSign = this.processEncodedTxns(flatTxns, indexesToSign);
      }
      const token = await this.fetchToken();
      const password = await this.getPassword();
      const client = this.client || await this.initializeClient();
      this.logger.debug("Sending processed transactions to wallet...", txnsToSign);
      const signedTxns = await Promise.all(
        txnsToSign.map((txn) => client.signTransaction(token, password, txn))
      );
      this.logger.debug("Received signed transactions from wallet", signedTxns);
      await this.releaseToken(token);
      this.logger.debug("Transactions signed successfully", signedTxns);
      return signedTxns;
    } catch (error) {
      this.logger.error("Error signing transactions:", error.message);
      throw error;
    }
  };
  async fetchWalletId() {
    this.logger.debug("Fetching wallet data...", { walletName: this.walletName });
    const client = this.client || await this.initializeClient();
    const { wallets } = await client.listWallets();
    const wallet = wallets.find((wallet2) => wallet2.name === this.walletName);
    if (!wallet) {
      this.logger.error(`Wallet "${this.walletName}" not found!`);
      throw new Error(`Wallet "${this.walletName}" not found!`);
    }
    this.walletId = wallet.id;
    this.logger.debug("Wallet data fetched successfully", { walletId: this.walletId });
    return wallet.id;
  }
  async fetchToken() {
    this.logger.debug("Fetching token...", { walletId: this.walletId });
    const client = this.client || await this.initializeClient();
    const walletId = this.walletId || await this.fetchWalletId();
    const password = await this.getPassword();
    const { wallet_handle_token } = await client.initWalletHandle(
      walletId,
      password
    );
    this.logger.debug("Token fetched successfully");
    return wallet_handle_token;
  }
  async releaseToken(token) {
    this.logger.debug("Releasing token...");
    const client = this.client || await this.initializeClient();
    await client.releaseWalletHandle(token);
    this.logger.debug("Token released successfully");
  }
  async getPassword() {
    if (this.password !== null) {
      return this.password;
    }
    const password = await this.options.promptForPassword();
    this.password = password;
    return password;
  }
  async fetchAccounts(token) {
    this.logger.debug("Fetching accounts...");
    const client = this.client || await this.initializeClient();
    const { addresses } = await client.listKeys(token);
    this.logger.debug("Accounts fetched successfully", { addresses });
    return addresses;
  }
};

// src/wallets/lute.ts
import algosdk7 from "algosdk";
function isSignTxnsError(error) {
  return error instanceof Error && "code" in error;
}
var ICON9 = `data:image/svg+xml;base64,${btoa(`
<svg viewBox="0 0 400 400" xmlns="http://www.w3.org/2000/svg">
  <path fill="#AB47BC" d="M283.7,263.6c-0.6,0-1.3-0.1-1.8-0.4c-0.6-0.3-1.1-0.8-1.5-1.3c-0.4-0.6-0.7-1.3-0.8-2 c-0.1-0.8-0.1-1.7,0.1-2.5c0.2-0.9,0.6-1.8,1.2-2.6c0.6-0.8,1.4-1.7,2.2-2.3c0.9-0.7,2.1-1.2,3.2-1.6c1.2-0.4,2.7-0.5,4-0.5 c1.4,0,3,0.3,4.4,0.8c1.5,0.5,3.1,1.4,4.3,2.3c1.4,1,2.8,2.4,3.8,3.7c1.1,1.5,2.1,3.3,2.8,5.1c0.7,1.9,1.2,4.1,1.3,6.1 c0.2,2.1,0,4.6-0.4,6.7c-0.5,2.2-1.4,4.7-2.4,6.7c-1.1,2.1-2.8,4.4-4.4,6.2c-1.8,1.9-4.1,3.7-6.3,5c-2.3,1.4-5.2,2.6-7.9,3.3 c-2.8,0.7-6.1,1.1-8.9,1.1c-3,0-6.5-0.6-9.3-1.4c-3-0.9-6.4-2.4-9.1-4c-2.8-1.7-5.8-4.2-8-6.6c-2.3-2.5-4.6-5.8-6.2-8.9 c-1.7-3.2-3.1-7.1-3.8-10.7c-0.8-3.7-1.1-8-0.9-11.8c0.2-3.9,1.1-8.3,2.3-12c1.3-3.8,3.4-8.1,5.7-11.4c2.3-3.5,5.6-7.1,8.8-9.9 c3.3-2.8,7.5-5.6,11.5-7.5c4.1-1.9,9-3.5,13.5-4.3c4.6-0.8,10-1.1,14.6-0.7c4.8,0.4,10.2,1.6,14.7,3.3c4.7,1.7,9.7,4.4,13.8,7.3 c4.2,3,8.5,7,11.7,10.9c3.3,4.1,6.5,9.2,8.7,14c2.2,4.9,4,10.9,4.9,16.3c0.9,5.5,1,11.9,0.4,17.5c-0.6,5.7-2.2,12.1-4.3,17.4 c-2.1,5.5-5.4,11.4-8.9,16.1c-3.6,4.8-8.4,9.8-13.1,13.6c-4.8,3.8-11,7.5-16.6,9.9c-5.8,2.5-12.8,4.5-19.1,5.4 c-6.4,0.9-13.9,1-20.3,0.2c-6.6-0.8-14-2.7-20.1-5.2c-6.3-2.5-13.1-6.4-18.5-10.5c-5.5-4.2-11.2-9.8-15.4-15.3 c-4.3-5.6-8.4-12.7-11.2-19.2c-2.8-6.7-4.9-14.7-5.9-21.9c-0.9-5.9-2.8-12.6-5.2-18.1c-2.3-5.4-5.9-11.2-9.5-15.8 c-3.6-4.5-8.3-9-13-12.4c-4.5-3.3-10.1-6.4-15.3-8.3c-5-1.9-11.1-3.4-16.5-3.9c-5.2-0.5-11.3-0.3-16.5,0.5c-5,0.8-10.7,2.6-15.3,4.7 c-4.5,2.1-9.4,5.1-13.2,8.3c-3.7,3.1-7.5,7.2-10.2,11.1c-2.7,3.8-5.2,8.6-6.7,13c-1.5,4.2-2.6,9.3-3,13.8c-0.3,4.3-0.1,9.4,0.7,13.7 c0.8,4.1,2.3,8.8,4.2,12.5c1.8,3.6,4.4,7.6,7.1,10.6c2.6,2.9,6,5.9,9.3,8.1c3.1,2.1,7.1,4,10.6,5.1c3.4,1.1,7.5,1.9,11.1,2 c3.5,0.2,7.4-0.2,10.8-1c3.2-0.7,6.8-2.1,9.7-3.6c2.8-1.5,5.7-3.6,8-5.8c2.2-2.1,4.3-4.8,5.9-7.4c1.5-2.5,2.8-5.5,3.5-8.3 c0.7-2.6,1.1-5.7,1.1-8.5c0-2.6-0.5-5.5-1.2-8c-0.7-2.3-1.8-4.9-3.1-6.9c-1.2-1.9-2.9-3.9-4.6-5.4c-1.6-1.4-3.6-2.8-5.5-3.7 c-1.8-0.9-4-1.6-5.9-1.9c-1.8-0.3-3.9-0.4-5.8-0.1c-1.7,0.2-3.6,0.7-5.1,1.4c-1.4,0.6-2.9,1.6-4.1,2.6c-1.1,0.9-2.1,2.2-2.9,3.4 c-0.7,1.1-1.2,2.5-1.5,3.7c-0.3,1.1-0.4,2.4-0.3,3.6c0.1,1,0.4,2.2,0.8,3.1c0.4,0.8,1,1.7,1.6,2.3c0.6,0.5,1.3,1,2.1,1.3 c0.6,0.2,1.5,0.4,2.1,0.3c0.6-0.1,1.3-0.3,1.8-0.6c0.5-0.3,1-0.8,1.2-1.4c0.3-0.5,0.7-1,1.2-1.4c0.5-0.3,1.2-0.6,1.8-0.6 c0.7-0.1,1.5,0.1,2.1,0.3c0.7,0.3,1.5,0.8,2.1,1.3c0.6,0.6,1.3,1.5,1.6,2.3c0.4,0.9,0.7,2.1,0.8,3.1c0.1,1.1,0,2.5-0.3,3.6 c-0.3,1.2-0.9,2.6-1.5,3.7c-0.7,1.2-1.8,2.4-2.9,3.4c-1.2,1-2.7,2-4.1,2.6c-1.5,0.7-3.4,1.2-5.1,1.4c-1.8,0.2-4,0.2-5.8-0.1 c-2-0.3-4.1-1-5.9-1.9c-1.9-0.9-4-2.3-5.5-3.7c-1.7-1.5-3.4-3.5-4.6-5.4c-1.3-2-2.4-4.6-3.1-6.9c-0.7-2.5-1.2-5.4-1.2-8 c0-2.7,0.4-5.8,1.1-8.5c0.7-2.8,2-5.8,3.5-8.3c1.5-2.6,3.7-5.3,5.9-7.4c2.3-2.2,5.2-4.3,8-5.8c2.9-1.6,6.5-2.9,9.7-3.6 c3.4-0.8,7.4-1.1,10.8-1c3.6,0.2,7.7,0.9,11.1,2c3.6,1.2,7.5,3.1,10.6,5.1c3.3,2.1,6.7,5.1,9.3,8.1c2.7,3,5.3,7,7.1,10.6 c1.8,3.8,3.4,8.4,4.2,12.5c0.8,4.3,1.1,9.3,0.7,13.7c-0.4,4.5-1.5,9.6-3,13.8c-1.6,4.4-4.1,9.2-6.7,13c-2.8,3.9-6.5,8-10.2,11.1 c-3.8,3.2-8.7,6.2-13.2,8.3c-4.6,2.1-10.3,3.8-15.3,4.7c-5.2,0.9-11.3,1-16.5,0.5c-5.4-0.5-11.5-2-16.5-3.9 c-5.2-2-10.8-5.1-15.3-8.3c-4.6-3.4-9.4-7.9-13-12.4c-3.7-4.6-7.2-10.4-9.5-15.8c-2.4-5.5-4.3-12.2-5.2-18.1 c-0.9-6.1-1-13.2-0.3-19.3c0.7-6.3,2.5-13.4,4.9-19.2c2.4-6,6.1-12.5,10-17.7c4-5.3,9.3-10.7,14.6-14.8c5.3-4.2,12.1-8.1,18.3-10.7 c6.4-2.7,14.1-4.8,21-5.7c7-1,15.2-1,22.2-0.1c7.2,0.9,15.2,3.1,21.9,5.8c5.6,2.2,12.3,3.9,18.3,4.6c5.8,0.7,12.6,0.5,18.4-0.4 c5.6-0.9,12-2.7,17.2-5c5.1-2.3,10.6-5.6,14.9-9.1c4.2-3.4,8.5-8,11.7-12.3c3.1-4.3,6-9.6,7.8-14.5c1.8-4.8,3.1-10.5,3.6-15.6 c0.5-4.9,0.3-10.7-0.6-15.6c-0.8-4.7-2.5-10.1-4.5-14.4c-2-4.2-4.9-8.8-7.9-12.3c-2.9-3.4-6.8-6.9-10.5-9.5 c-3.6-2.5-8.1-4.8-12.2-6.2c-4-1.4-8.7-2.4-12.9-2.7c-4-0.3-8.7,0-12.7,0.8c-3.8,0.8-8.1,2.2-11.6,4c-3.4,1.7-7,4.1-9.7,6.6 c-2.7,2.4-5.4,5.6-7.3,8.6c-1.9,2.9-3.6,6.5-4.6,9.8c-1,3.2-1.6,6.9-1.7,10.2c-0.1,3.2,0.3,6.8,1,9.9c0.7,2.9,2,6.2,3.5,8.8 c1.4,2.5,3.4,5.1,5.4,7.2c1.9,1.9,4.4,3.8,6.8,5.2c2.2,1.3,5,2.4,7.5,3c2.3,0.6,5.1,0.9,7.6,0.8c2.3-0.1,4.9-0.5,7-1.3 c2-0.7,4.2-1.7,6-2.9c1.6-1.1,3.3-2.7,4.6-4.2c1.2-1.4,2.3-3.2,3-4.9c0.7-1.6,1.2-3.5,1.3-5.1c0.2-1.5,0.1-3.3-0.2-4.9 c-0.3-1.4-0.8-2.9-1.5-4.2c-0.6-1.1-1.5-2.3-2.4-3.2c-0.8-0.8-1.9-1.5-3-2c-0.9-0.4-2.1-0.7-3.1-0.8c-0.9-0.1-1.9,0-2.8,0.3 c-0.7,0.2-1.6,0.6-2.2,1.1c-0.5,0.4-1,1.1-1.3,1.7c-0.3,0.6-0.4,1.3-0.4,1.9c0,0.6,0.2,1.2,0.6,1.7c0.3,0.5,0.5,1.2,0.6,1.7 c0,0.6-0.1,1.3-0.4,1.9c-0.3,0.6-0.8,1.3-1.3,1.7c-0.6,0.5-1.4,0.9-2.2,1.1c-0.9,0.3-1.9,0.3-2.8,0.3c-1-0.1-2.2-0.4-3.1-0.8 c-1-0.5-2.1-1.2-3-2c-0.9-0.9-1.8-2.1-2.4-3.2c-0.7-1.2-1.2-2.8-1.5-4.2c-0.3-1.5-0.4-3.3-0.2-4.9c0.2-1.7,0.7-3.6,1.3-5.1 c0.7-1.7,1.8-3.5,3-4.9c1.3-1.5,3-3.1,4.6-4.2c1.8-1.2,4-2.3,6-2.9c2.2-0.7,4.8-1.2,7-1.3c2.4-0.1,5.2,0.2,7.6,0.8 c2.5,0.6,5.3,1.7,7.5,3c2.4,1.3,4.9,3.2,6.8,5.2c2,2,4,4.7,5.4,7.2c1.5,2.6,2.7,5.9,3.5,8.8c0.8,3.1,1.1,6.7,1,9.9 c-0.1,3.3-0.7,7.1-1.7,10.2c-1,3.3-2.7,6.9-4.6,9.8c-1.9,3-4.7,6.2-7.3,8.6c-2.8,2.5-6.4,5-9.7,6.6c-3.5,1.8-7.8,3.2-11.6,4 c-4,0.8-8.7,1.1-12.7,0.8c-4.2-0.3-9-1.3-12.9-2.7c-4.1-1.4-8.6-3.7-12.2-6.2c-3.7-2.6-7.6-6.1-10.5-9.5c-3-3.6-5.9-8.1-7.9-12.3 c-2-4.4-3.7-9.7-4.5-14.4c-0.8-4.9-1.1-10.6-0.6-15.6c0.5-5.1,1.8-10.8,3.6-15.6c1.8-4.9,4.7-10.3,7.8-14.5 c3.2-4.4,7.5-8.9,11.7-12.3c4.3-3.5,9.8-6.9,14.9-9.1c5.2-2.3,11.6-4.2,17.2-5c5.8-0.9,12.6-1,18.4-0.4c6,0.7,12.7,2.4,18.3,4.6 c5.7,2.3,12,5.7,16.9,9.4c5.1,3.8,10.3,8.9,14.2,13.8c4,5.1,7.8,11.5,10.3,17.5c2.6,6.1,4.6,13.5,5.5,20c0.9,6.7,1,14.5,0.1,21.2 c-0.9,6.9-2.9,14.6-5.5,21c-2.7,6.5-6.8,13.6-11,19.3c-4.4,5.7-10.3,11.7-16,16c-4.7,3.7-9.5,8.7-13.1,13.6 c-3.5,4.7-6.8,10.7-8.9,16.1c-2.1,5.3-3.6,11.7-4.3,17.4c-0.6,5.5-0.4,12,0.4,17.5c0.9,5.3,2.6,11.3,4.9,16.3c2.2,4.8,5.4,10,8.7,14 c3.2,3.9,7.6,8,11.7,10.9c4,2.9,9.1,5.6,13.8,7.3c4.5,1.7,9.9,2.9,14.7,3.3c4.6,0.4,10,0.2,14.6-0.7c4.4-0.8,9.4-2.4,13.5-4.3 c3.9-1.9,8.2-4.6,11.5-7.5c3.2-2.7,6.4-6.4,8.8-9.9c2.3-3.4,4.4-7.6,5.7-11.4c1.2-3.7,2.1-8.1,2.3-12c0.2-3.7-0.1-8.1-0.9-11.8 c-0.8-3.5-2.2-7.5-3.8-10.7c-1.6-3.1-3.9-6.3-6.2-8.9c-2.2-2.4-5.2-4.9-8-6.6c-2.7-1.7-6-3.2-9.1-4c-2.9-0.8-6.3-1.4-9.3-1.4 c-2.9,0-6.2,0.4-8.9,1.1c-2.6,0.7-5.5,1.9-7.9,3.3c-2.2,1.3-4.5,3.2-6.3,5c-1.7,1.8-3.3,4-4.4,6.2c-1.1,2-2,4.5-2.4,6.7 c-0.4,2.1-0.6,4.5-0.4,6.7c0.2,2,0.6,4.2,1.3,6.1c0.6,1.7,1.7,3.6,2.8,5.1c1,1.3,2.4,2.7,3.8,3.7c1.3,0.9,2.8,1.8,4.3,2.3 c1.3,0.5,2.9,0.8,4.4,0.8c1.3,0,2.7-0.1,4-0.5c1.1-0.3,2.3-0.9,3.2-1.6c0.8-0.6,1.7-1.4,2.2-2.3c0.5-0.7,0.9-1.7,1.2-2.6 c0.2-0.8,0.2-1.7,0.1-2.5c-0.1-0.7-0.4-1.4-0.8-2c-0.4-0.5-0.9-1-1.5-1.3C285,263.7,284.3,263.6,283.7,263.6L283.7,263.6z" />
</svg>
`)}`;
var LuteWallet = class extends BaseWallet {
  client = null;
  options;
  store;
  constructor({
    id,
    store,
    subscribe,
    getAlgodClient,
    options = {},
    metadata = {}
  }) {
    super({ id, metadata, getAlgodClient, store, subscribe });
    this.options = options;
    this.store = store;
  }
  static defaultMetadata = {
    name: "Lute",
    icon: ICON9
  };
  async initializeClient() {
    this.logger.info("Initializing client...");
    const module = await import("lute-connect");
    const LuteConnect = module.default;
    const client = new LuteConnect(this.options?.siteName);
    this.client = client;
    this.logger.info("Client initialized");
    return client;
  }
  async getGenesisId() {
    const network = this.activeNetworkConfig;
    if (network.genesisId) {
      return network.genesisId;
    }
    const algodClient = this.getAlgodClient();
    const genesisStr = await algodClient.genesis().do();
    const genesis = algosdk7.parseJSON(genesisStr, {
      intDecoding: algosdk7.IntDecoding.MIXED
    });
    return `${genesis.network}-${genesis.id}`;
  }
  connect = async () => {
    this.logger.info("Connecting...");
    const client = this.client || await this.initializeClient();
    const genesisId = await this.getGenesisId();
    const accounts = await client.connect(genesisId);
    if (accounts.length === 0) {
      this.logger.error("No accounts found!");
      throw new Error("No accounts found!");
    }
    const walletAccounts = accounts.map((address, idx) => ({
      name: `${this.metadata.name} Account ${idx + 1}`,
      address
    }));
    const activeAccount = walletAccounts[0];
    const walletState = {
      accounts: walletAccounts,
      activeAccount
    };
    addWallet(this.store, {
      walletId: this.id,
      wallet: walletState
    });
    this.logger.info("Connected successfully", walletState);
    return walletAccounts;
  };
  disconnect = async () => {
    this.onDisconnect();
    this.logger.info("Disconnected");
  };
  resumeSession = async () => {
    try {
      const state = this.store.state;
      const walletState = state.wallets[this.id];
      if (!walletState) {
        this.logger.info("No session to resume");
        return;
      }
      this.logger.info("Resuming session...");
      await this.initializeClient();
      this.logger.info("Session resumed successfully");
    } catch (error) {
      this.logger.error("Error resuming session:", error.message);
      this.onDisconnect();
      throw error;
    }
  };
  processTxns(txnGroup, indexesToSign) {
    const txnsToSign = [];
    txnGroup.forEach((txn, index) => {
      const isIndexMatch = !indexesToSign || indexesToSign.includes(index);
      const signer = txn.sender.toString();
      const canSignTxn = this.addresses.includes(signer);
      const txnString = byteArrayToBase64(txn.toByte());
      if (isIndexMatch && canSignTxn) {
        txnsToSign.push({ txn: txnString });
      } else {
        txnsToSign.push({ txn: txnString, signers: [] });
      }
    });
    return txnsToSign;
  }
  processEncodedTxns(txnGroup, indexesToSign) {
    const txnsToSign = [];
    txnGroup.forEach((txnBuffer, index) => {
      const decodedObj = algosdk7.msgpackRawDecode(txnBuffer);
      const isSigned = isSignedTxn(decodedObj);
      const txn = isSigned ? algosdk7.decodeSignedTransaction(txnBuffer).txn : algosdk7.decodeUnsignedTransaction(txnBuffer);
      const isIndexMatch = !indexesToSign || indexesToSign.includes(index);
      const signer = txn.sender.toString();
      const canSignTxn = !isSigned && this.addresses.includes(signer);
      const txnString = byteArrayToBase64(txn.toByte());
      if (isIndexMatch && canSignTxn) {
        txnsToSign.push({ txn: txnString });
      } else {
        txnsToSign.push({ txn: txnString, signers: [] });
      }
    });
    return txnsToSign;
  }
  signTransactions = async (txnGroup, indexesToSign) => {
    try {
      this.logger.debug("Signing transactions...", { txnGroup, indexesToSign });
      let txnsToSign = [];
      if (isTransactionArray(txnGroup)) {
        const flatTxns = flattenTxnGroup(txnGroup);
        txnsToSign = this.processTxns(flatTxns, indexesToSign);
      } else {
        const flatTxns = flattenTxnGroup(txnGroup);
        txnsToSign = this.processEncodedTxns(flatTxns, indexesToSign);
      }
      const client = this.client || await this.initializeClient();
      this.logger.debug("Sending processed transactions to wallet...", txnsToSign);
      const signTxnsResult = await client.signTxns(txnsToSign);
      this.logger.debug("Transactions signed successfully", signTxnsResult);
      return signTxnsResult;
    } catch (error) {
      if (isSignTxnsError(error)) {
        this.logger.error("Error signing transactions:", error.message, `(code: ${error.code})`);
        throw new SignTxnsError(error.message, error.code);
      }
      this.logger.error("Unknown error signing transactions:", error);
      throw error;
    }
  };
};

// src/wallets/magic.ts
import algosdk8 from "algosdk";
var ICON10 = `data:image/svg+xml;base64,${btoa(`
<svg viewBox="0 0 47 47" xmlns="http://www.w3.org/2000/svg">
  <path fill="#6851FF" d="M 23.960861 1.80769 C 25.835077 4.103153 27.902216 6.23489 30.137539 8.178169 C 28.647968 13.009323 27.846092 18.142094 27.846092 23.462154 C 27.846092 28.782307 28.648062 33.915169 30.13763 38.746368 C 27.902216 40.689724 25.835077 42.821476 23.960861 45.116985 C 22.086554 42.821476 20.019415 40.689632 17.783998 38.746368 C 19.273476 33.915169 20.075445 28.7824 20.075445 23.462337 C 20.075445 18.142277 19.273476 13.009506 17.783998 8.178318 C 20.019415 6.235001 22.086554 4.10321 23.960861 1.80769 Z M 13.511427 35.406403 C 11.145139 33.747814 8.633816 32.282063 6.000269 31.031937 C 6.730776 28.637476 7.123754 26.095783 7.123754 23.462429 C 7.123754 20.828892 6.730762 18.287201 6.000235 15.892738 C 8.633816 14.642616 11.145175 13.176861 13.511501 11.518276 C 14.416311 15.352554 14.895074 19.351414 14.895074 23.462154 C 14.895074 27.572985 14.416283 31.571938 13.511427 35.406403 Z M 33.027046 23.462337 C 33.027046 27.572985 33.505753 31.571846 34.410553 35.406124 C 36.776859 33.747631 39.288094 32.281876 41.921539 31.031845 C 41.191017 28.637384 40.798061 26.095692 40.798061 23.462246 C 40.798061 20.8288 41.191017 18.287201 41.921539 15.89283 C 39.288094 14.642708 36.776768 13.177048 34.410553 11.518555 C 33.505753 15.352831 33.027046 19.351692 33.027046 23.462337 Z" />
</svg>
`)}`;
var MagicAuth = class extends BaseWallet {
  client = null;
  options;
  store;
  userInfo = null;
  constructor({
    id,
    store,
    subscribe,
    getAlgodClient,
    options,
    metadata = {}
  }) {
    super({ id, metadata, getAlgodClient, store, subscribe });
    if (!options?.apiKey) {
      this.logger.error("Missing required option: apiKey");
      throw new Error("Missing required option: apiKey");
    }
    this.options = options;
    this.store = store;
  }
  static defaultMetadata = {
    name: "Magic",
    icon: ICON10
  };
  async initializeClient() {
    this.logger.info("Initializing client...");
    const Magic = (await Promise.resolve().then(() => (init_es4(), es_exports))).Magic;
    const AlgorandExtension = (await Promise.resolve().then(() => (init_es5(), es_exports2))).AlgorandExtension;
    const client = new Magic(this.options.apiKey, {
      extensions: {
        algorand: new AlgorandExtension({
          rpcUrl: ""
        })
      }
    });
    this.client = client;
    this.logger.info("Client initialized");
    return client;
  }
  connect = async (args) => {
    this.logger.info("Connecting...");
    if (!args?.email || typeof args.email !== "string") {
      this.logger.error("Magic Link provider requires an email (string) to connect");
      throw new Error("Magic Link provider requires an email (string) to connect");
    }
    const { email } = args;
    const client = this.client || await this.initializeClient();
    this.logger.info(`Logging in ${email}...`);
    await client.auth.loginWithMagicLink({ email });
    const userInfo = await client.user.getInfo();
    if (!userInfo) {
      this.logger.error("User info not found!");
      throw new Error("User info not found!");
    }
    if (!userInfo.publicAddress) {
      this.logger.error("No account found!");
      throw new Error("No account found!");
    }
    this.userInfo = userInfo;
    this.logger.info("Login successful", userInfo);
    const walletAccount = {
      name: userInfo.email ?? "Magic Wallet 1",
      address: userInfo.publicAddress
    };
    const walletState = {
      accounts: [walletAccount],
      activeAccount: walletAccount
    };
    addWallet(this.store, {
      walletId: this.id,
      wallet: walletState
    });
    this.logger.info("Connected successfully", walletState);
    return [walletAccount];
  };
  disconnect = async () => {
    this.logger.info("Disconnecting...");
    this.onDisconnect();
    const client = this.client || await this.initializeClient();
    this.logger.info(`Logging out ${this.userInfo?.email || "user"}...`);
    await client.user.logout();
    this.logger.info("Disconnected");
  };
  resumeSession = async () => {
    try {
      const state = this.store.state;
      const walletState = state.wallets[this.id];
      if (!walletState) {
        this.logger.info("No session to resume");
        return;
      }
      this.logger.info("Resuming session...");
      const client = this.client || await this.initializeClient();
      const isLoggedIn = await client.user.isLoggedIn();
      if (!isLoggedIn) {
        this.logger.warn("Not logged in, please reconnect...");
        this.onDisconnect();
        return;
      }
      const userInfo = await client.user.getInfo();
      if (!userInfo) {
        await client.user.logout();
        this.logger.error("User info not found!");
        throw new Error("User info not found!");
      }
      if (!userInfo.publicAddress) {
        await client.user.logout();
        this.logger.error("No account found!");
        throw new Error("No account found!");
      }
      this.userInfo = userInfo;
      const walletAccount = {
        name: userInfo.email ?? `${this.metadata.name} Account 1`,
        address: userInfo.publicAddress
      };
      const storedAccount = walletState.accounts[0];
      const { name, address } = walletAccount;
      const { name: storedName, address: storedAddress } = storedAccount;
      const match = name === storedName && address === storedAddress;
      if (!match) {
        this.logger.warn("Session account mismatch, updating account", {
          prev: storedAccount,
          current: walletAccount
        });
        setAccounts(this.store, {
          walletId: this.id,
          accounts: [walletAccount]
        });
      }
      this.logger.info("Session resumed successfully");
    } catch (error) {
      this.logger.error("Error resuming session:", error.message);
      this.onDisconnect();
      throw error;
    }
  };
  processTxns(txnGroup, indexesToSign) {
    const txnsToSign = [];
    txnGroup.forEach((txn, index) => {
      const isIndexMatch = !indexesToSign || indexesToSign.includes(index);
      const signer = txn.sender.toString();
      const canSignTxn = this.addresses.includes(signer);
      const txnString = byteArrayToBase64(txn.toByte());
      if (isIndexMatch && canSignTxn) {
        txnsToSign.push({ txn: txnString });
      } else {
        txnsToSign.push({ txn: txnString, signers: [] });
      }
    });
    return txnsToSign;
  }
  processEncodedTxns(txnGroup, indexesToSign) {
    const txnsToSign = [];
    txnGroup.forEach((txnBuffer, index) => {
      const decodedObj = algosdk8.msgpackRawDecode(txnBuffer);
      const isSigned = isSignedTxn(decodedObj);
      const txn = isSigned ? algosdk8.decodeSignedTransaction(txnBuffer).txn : algosdk8.decodeUnsignedTransaction(txnBuffer);
      const isIndexMatch = !indexesToSign || indexesToSign.includes(index);
      const signer = txn.sender.toString();
      const canSignTxn = !isSigned && this.addresses.includes(signer);
      const txnString = byteArrayToBase64(txn.toByte());
      if (isIndexMatch && canSignTxn) {
        txnsToSign.push({ txn: txnString });
      } else {
        txnsToSign.push({ txn: txnString, signers: [] });
      }
    });
    return txnsToSign;
  }
  signTransactions = async (txnGroup, indexesToSign) => {
    try {
      this.logger.debug("Signing transactions...", { txnGroup, indexesToSign });
      let txnsToSign = [];
      if (isTransactionArray(txnGroup)) {
        const flatTxns = flattenTxnGroup(txnGroup);
        txnsToSign = this.processTxns(flatTxns, indexesToSign);
      } else {
        const flatTxns = flattenTxnGroup(txnGroup);
        txnsToSign = this.processEncodedTxns(flatTxns, indexesToSign);
      }
      const client = this.client || await this.initializeClient();
      this.logger.debug("Sending processed transactions to wallet...", txnsToSign);
      const signTxnsResult = await client.algorand.signGroupTransactionV2(
        txnsToSign
      );
      this.logger.debug("Received signed transactions from wallet", signTxnsResult);
      const result = signTxnsResult.map((value) => {
        if (value === void 0) {
          return null;
        }
        return base64ToByteArray(value);
      });
      this.logger.debug("Transactions signed successfully", result);
      return result;
    } catch (error) {
      this.logger.error("Error signing transactions:", error.message);
      throw error;
    }
  };
};

// src/wallets/mnemonic.ts
import algosdk9 from "algosdk";
var LOCAL_STORAGE_MNEMONIC_KEY = `${LOCAL_STORAGE_KEY}_mnemonic`;
var ICON11 = `data:image/svg+xml;base64,${btoa(`
<svg viewBox="0 0 400 400" xmlns="http://www.w3.org/2000/svg">
  <rect fill="#525252" width="400" height="400" />
  <path fill="#FFFFFF" d="M309.2,309.3H275l-22.2-82.7l-47.9,82.7h-38.3l73.9-128l-11.9-44.5l-99.6,172.6H90.8L217.1,90.6 h33.5l14.7,54.3h34.6l-23.6,41L309.2,309.3z" />
</svg>
`)}`;
var MnemonicWallet = class extends BaseWallet {
  account = null;
  options;
  store;
  constructor({
    id,
    store,
    subscribe,
    getAlgodClient,
    options,
    metadata = {}
  }) {
    super({ id, metadata, getAlgodClient, store, subscribe });
    const {
      persistToStorage = false,
      promptForMnemonic = () => Promise.resolve(prompt("Enter 25-word mnemonic passphrase:"))
    } = options || {};
    this.options = { persistToStorage, promptForMnemonic };
    this.store = store;
    if (this.options.persistToStorage) {
      this.logger.warn(
        "Persisting mnemonics to storage is insecure. Any private key mnemonics used should never hold real Algos (i.e., on MainNet). Use with caution!"
      );
    }
  }
  static defaultMetadata = {
    name: "Mnemonic",
    icon: ICON11
  };
  loadMnemonicFromStorage() {
    return StorageAdapter.getItem(LOCAL_STORAGE_MNEMONIC_KEY);
  }
  saveMnemonicToStorage(mnemonic) {
    StorageAdapter.setItem(LOCAL_STORAGE_MNEMONIC_KEY, mnemonic);
  }
  removeMnemonicFromStorage() {
    StorageAdapter.removeItem(LOCAL_STORAGE_MNEMONIC_KEY);
  }
  checkMainnet() {
    try {
      const network = this.activeNetworkConfig;
      if (!network.isTestnet) {
        this.logger.warn(
          "The Mnemonic wallet provider is insecure and intended for testing only. Any private key mnemonics used should never hold real Algos (i.e., on MainNet)."
        );
        throw new Error("Production network detected. Aborting.");
      }
    } catch (error) {
      this.disconnect();
      throw error;
    }
  }
  async initializeAccount() {
    let mnemonic = this.loadMnemonicFromStorage();
    if (!mnemonic) {
      mnemonic = await this.options.promptForMnemonic();
      if (!mnemonic) {
        this.account = null;
        this.logger.error("No mnemonic provided");
        throw new Error("No mnemonic provided");
      }
      if (this.options.persistToStorage) {
        this.logger.warn("Mnemonic saved to localStorage.");
        this.saveMnemonicToStorage(mnemonic);
      }
    }
    const account = algosdk9.mnemonicToSecretKey(mnemonic);
    this.account = account;
    return account;
  }
  connect = async () => {
    this.checkMainnet();
    this.logger.info("Connecting...");
    const account = await this.initializeAccount();
    const walletAccount = {
      name: `${this.metadata.name} Account`,
      address: account.addr.toString()
    };
    const walletState = {
      accounts: [walletAccount],
      activeAccount: walletAccount
    };
    addWallet(this.store, {
      walletId: this.id,
      wallet: walletState
    });
    this.logger.info("Connected successfully", walletState);
    return [walletAccount];
  };
  disconnect = async () => {
    this.logger.info("Disconnecting...");
    this.onDisconnect();
    this.account = null;
    this.removeMnemonicFromStorage();
    this.logger.info("Disconnected");
  };
  resumeSession = async () => {
    this.checkMainnet();
    const state = this.store.state;
    const walletState = state.wallets[this.id];
    if (!walletState) {
      this.logger.info("No session to resume");
      return;
    }
    this.logger.info("Resuming session...");
    if (this.options.persistToStorage) {
      try {
        await this.initializeAccount();
        this.logger.info("Session resumed successfully");
      } catch (error) {
        this.logger.error("Error resuming session:", error.message);
        this.disconnect();
        throw error;
      }
    } else {
      this.logger.info("No session to resume, disconnecting...");
      this.disconnect();
    }
  };
  processTxns(txnGroup, indexesToSign) {
    const txnsToSign = [];
    txnGroup.forEach((txn, index) => {
      const isIndexMatch = !indexesToSign || indexesToSign.includes(index);
      const signer = txn.sender.toString();
      const canSignTxn = signer === this.account.addr.toString();
      if (isIndexMatch && canSignTxn) {
        txnsToSign.push(txn);
      }
    });
    return txnsToSign;
  }
  processEncodedTxns(txnGroup, indexesToSign) {
    const txnsToSign = [];
    txnGroup.forEach((txnBuffer, index) => {
      const decodedObj = algosdk9.msgpackRawDecode(txnBuffer);
      const isSigned = isSignedTxn(decodedObj);
      const txn = isSigned ? algosdk9.decodeSignedTransaction(txnBuffer).txn : algosdk9.decodeUnsignedTransaction(txnBuffer);
      const isIndexMatch = !indexesToSign || indexesToSign.includes(index);
      const signer = txn.sender.toString();
      const canSignTxn = !isSigned && signer === this.account.addr.toString();
      if (isIndexMatch && canSignTxn) {
        txnsToSign.push(txn);
      }
    });
    return txnsToSign;
  }
  signTransactions = async (txnGroup, indexesToSign) => {
    this.checkMainnet();
    try {
      this.logger.debug("Signing transactions...", { txnGroup, indexesToSign });
      let txnsToSign = [];
      if (isTransactionArray(txnGroup)) {
        const flatTxns = flattenTxnGroup(txnGroup);
        txnsToSign = this.processTxns(flatTxns, indexesToSign);
      } else {
        const flatTxns = flattenTxnGroup(txnGroup);
        txnsToSign = this.processEncodedTxns(flatTxns, indexesToSign);
      }
      const signedTxns = txnsToSign.map((txn) => txn.signTxn(this.account.sk));
      this.logger.debug("Transactions signed successfully", { signedTxns });
      return signedTxns;
    } catch (error) {
      this.logger.error("Error signing transactions:", error.message);
      throw error;
    }
  };
};

// src/wallets/pera.ts
import algosdk10 from "algosdk";
var ICON12 = `data:image/svg+xml;base64,${btoa(`
<svg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
  <rect fill="#FFEE55" width="200" height="200" />
  <path fill="#1C1C1C" d="M106.1,64.3c2.2,9.1,1.5,17-1.7,17.8c-3.1,0.8-7.4-6-9.6-15c-2.2-9.1-1.5-17,1.7-17.8 C99.6,48.5,103.9,55.2,106.1,64.3z" />
  <path fill="#1C1C1C" d="M142.2,72.1c-4.8-5.1-14.5-3.7-21.6,3.1c-7,6.9-8.8,16.6-4,21.7c4.8,5.1,14.5,3.7,21.6-3.1 C145.3,86.9,147.1,77.2,142.2,72.1z" />
  <path fill="#1C1C1C" d="M103.7,150.8c3.1-0.8,3.7-9.2,1.4-18.8c-2.3-9.6-6.7-16.8-9.8-16c-3.1,0.8-3.7,9.2-1.4,18.8 C96.2,144.3,100.6,151.5,103.7,150.8z" />
  <path fill="#1C1C1C" d="M72.1,76.8c9,2.6,15.5,7.3,14.6,10.3c-0.9,3.1-8.9,3.4-17.8,0.8s-15.5-7.3-14.6-10.3 C55.1,74.5,63.1,74.1,72.1,76.8z" />
  <path fill="#1C1C1C" d="M130.2,111.5c9.5,2.8,16.5,7.6,15.6,10.6c-0.9,3.1-9.3,3.3-18.8,0.5c-9.5-2.8-16.5-7.6-15.6-10.6 C112.2,108.9,120.7,108.7,130.2,111.5z" />
  <path fill="#1C1C1C" d="M82.1,105c-2.2-2.3-9.5,1-16.3,7.5c-6.8,6.4-10.4,13.5-8.2,15.8c2.2,2.3,9.5-1,16.3-7.5 C80.7,114.4,84.3,107.3,82.1,105z" />
</svg>
`)}`;
var PeraWallet = class extends BaseWallet {
  client = null;
  options;
  store;
  constructor({
    id,
    store,
    subscribe,
    getAlgodClient,
    options = {},
    metadata = {}
  }) {
    super({ id, metadata, getAlgodClient, store, subscribe });
    this.options = options;
    this.store = store;
  }
  static defaultMetadata = {
    name: "Pera",
    icon: ICON12
  };
  async initializeClient() {
    this.logger.info("Initializing client...");
    const { PeraWalletConnect } = await import("@perawallet/connect");
    const client = new PeraWalletConnect(this.options);
    this.client = client;
    this.logger.info("Client initialized");
    return client;
  }
  connect = async () => {
    this.logger.info("Connecting...");
    const currentActiveWallet = this.store.state.activeWallet;
    if (currentActiveWallet && currentActiveWallet !== this.id) {
      this.manageWalletConnectSession("backup", currentActiveWallet);
    }
    const client = this.client || await this.initializeClient();
    const accounts = await client.connect();
    client.connector?.on("disconnect", this.onDisconnect);
    if (accounts.length === 0) {
      this.logger.error("No accounts found!");
      throw new Error("No accounts found!");
    }
    const walletAccounts = accounts.map((address, idx) => ({
      name: `${this.metadata.name} Account ${idx + 1}`,
      address
    }));
    const activeAccount = walletAccounts[0];
    const walletState = {
      accounts: walletAccounts,
      activeAccount
    };
    addWallet(this.store, {
      walletId: this.id,
      wallet: walletState
    });
    this.logger.info("Connected successfully", walletState);
    return walletAccounts;
  };
  disconnect = async () => {
    this.logger.info("Disconnecting...");
    const client = this.client || await this.initializeClient();
    const currentActiveWallet = this.store.state.activeWallet;
    if (currentActiveWallet && currentActiveWallet !== this.id) {
      this.manageWalletConnectSession("backup", currentActiveWallet);
      this.manageWalletConnectSession("restore", this.id);
      await client.disconnect();
      await new Promise((resolve) => setTimeout(resolve, 500));
      this.manageWalletConnectSession("restore", currentActiveWallet);
    } else {
      await client.disconnect();
    }
    this.onDisconnect();
    this.logger.info("Disconnected");
  };
  setActive = () => {
    this.logger.info(`Set active wallet: ${this.id}`);
    const currentActiveWallet = this.store.state.activeWallet;
    if (currentActiveWallet && currentActiveWallet === "defly" /* DEFLY */) {
      this.manageWalletConnectSession("backup", currentActiveWallet);
    }
    this.manageWalletConnectSession("restore");
    setActiveWallet(this.store, { walletId: this.id });
  };
  resumeSession = async () => {
    try {
      const state = this.store.state;
      const walletState = state.wallets[this.id];
      if (typeof window !== "undefined" && window.navigator) {
        const isPeraDiscover = window.navigator.userAgent.includes("pera");
        if (isPeraDiscover && !walletState && !state.activeWallet) {
          this.logger.info("Pera Discover browser detected, attempting auto-connect...");
          try {
            await this.connect();
            this.logger.info("Auto-connect successful");
            return;
          } catch (error) {
            this.logger.warn("Auto-connect failed:", error.message);
          }
        }
      }
      if (!walletState) {
        this.logger.info("No session to resume");
        return;
      }
      if (state.activeWallet === "defly" /* DEFLY */) {
        this.logger.info("Skipping reconnectSession for Pera (inactive)");
        return;
      }
      this.logger.info("Resuming session...");
      const client = this.client || await this.initializeClient();
      const accounts = await client.reconnectSession();
      if (accounts.length === 0) {
        this.logger.error("No accounts found!");
        throw new Error("No accounts found!");
      }
      const walletAccounts = accounts.map((address, idx) => ({
        name: `${this.metadata.name} Account ${idx + 1}`,
        address
      }));
      const match = compareAccounts(walletAccounts, walletState.accounts);
      if (!match) {
        this.logger.warn("Session accounts mismatch, updating accounts", {
          prev: walletState.accounts,
          current: walletAccounts
        });
        setAccounts(this.store, {
          walletId: this.id,
          accounts: walletAccounts
        });
      }
      this.logger.info("Session resumed successfully");
    } catch (error) {
      this.logger.error("Error resuming session:", error.message);
      this.onDisconnect();
      throw error;
    }
  };
  processTxns(txnGroup, indexesToSign) {
    const txnsToSign = [];
    txnGroup.forEach((txn, index) => {
      const isIndexMatch = !indexesToSign || indexesToSign.includes(index);
      const signer = txn.sender.toString();
      const canSignTxn = this.addresses.includes(signer);
      if (isIndexMatch && canSignTxn) {
        txnsToSign.push({ txn });
      } else {
        txnsToSign.push({ txn, signers: [] });
      }
    });
    return txnsToSign;
  }
  processEncodedTxns(txnGroup, indexesToSign) {
    const txnsToSign = [];
    txnGroup.forEach((txnBuffer, index) => {
      const decodedObj = algosdk10.msgpackRawDecode(txnBuffer);
      const isSigned = isSignedTxn(decodedObj);
      const txn = isSigned ? algosdk10.decodeSignedTransaction(txnBuffer).txn : algosdk10.decodeUnsignedTransaction(txnBuffer);
      const isIndexMatch = !indexesToSign || indexesToSign.includes(index);
      const signer = txn.sender.toString();
      const canSignTxn = !isSigned && this.addresses.includes(signer);
      if (isIndexMatch && canSignTxn) {
        txnsToSign.push({ txn });
      } else {
        txnsToSign.push({ txn, signers: [] });
      }
    });
    return txnsToSign;
  }
  signTransactions = async (txnGroup, indexesToSign) => {
    try {
      this.logger.debug("Signing transactions...", { txnGroup, indexesToSign });
      let txnsToSign = [];
      if (isTransactionArray(txnGroup)) {
        const flatTxns = flattenTxnGroup(txnGroup);
        txnsToSign = this.processTxns(flatTxns, indexesToSign);
      } else {
        const flatTxns = flattenTxnGroup(txnGroup);
        txnsToSign = this.processEncodedTxns(flatTxns, indexesToSign);
      }
      const client = this.client || await this.initializeClient();
      this.logger.debug("Sending processed transactions to wallet...", [txnsToSign]);
      const signedTxns = await client.signTransaction([txnsToSign]);
      this.logger.debug("Received signed transactions from wallet", signedTxns);
      const result = txnsToSign.reduce((acc, txn) => {
        if (txn.signers && txn.signers.length == 0) {
          acc.push(null);
        } else {
          const signedTxn = signedTxns.shift();
          if (signedTxn) {
            acc.push(signedTxn);
          }
        }
        return acc;
      }, []);
      this.logger.debug("Transactions signed successfully", result);
      return result;
    } catch (error) {
      this.logger.error("Error signing transactions:", error.message);
      throw error;
    }
  };
};

// src/utils.ts
function createWalletMap() {
  return {
    ["biatec" /* BIATEC */]: BiatecWallet,
    ["custom" /* CUSTOM */]: CustomWallet,
    ["defly" /* DEFLY */]: DeflyWallet,
    ["defly-web" /* DEFLY_WEB */]: DeflyWebWallet,
    ["exodus" /* EXODUS */]: ExodusWallet,
    ["kibisis" /* KIBISIS */]: KibisisWallet,
    ["kmd" /* KMD */]: KmdWallet,
    ["lute" /* LUTE */]: LuteWallet,
    ["magic" /* MAGIC */]: MagicAuth,
    ["mnemonic" /* MNEMONIC */]: MnemonicWallet,
    ["pera" /* PERA */]: PeraWallet,
    ["walletconnect" /* WALLETCONNECT */]: WalletConnect
  };
}
function compareAccounts(accounts, compareTo) {
  const addresses = new Set(accounts.map((account) => account.address));
  const compareAddresses = new Set(compareTo.map((account) => account.address));
  if (addresses.size !== compareAddresses.size) {
    return false;
  }
  for (const address of addresses) {
    if (!compareAddresses.has(address)) {
      return false;
    }
  }
  return true;
}
function base64ToByteArray(blob) {
  return stringToByteArray(atob(blob));
}
function byteArrayToBase64(array) {
  return btoa(byteArrayToString(array));
}
function stringToByteArray(str) {
  const array = new Uint8Array(str.length);
  for (let i = 0; i < str.length; i++) {
    array[i] = str.charCodeAt(i);
  }
  return array;
}
function byteArrayToString(array) {
  let result = "";
  for (let i = 0; i < array.length; i++) {
    result += String.fromCharCode(array[i]);
  }
  return result;
}
function isSignedTxn(txnObj) {
  if (!txnObj || typeof txnObj !== "object") return false;
  if (!("sig" in txnObj && "txn" in txnObj)) return false;
  if (!(txnObj.sig instanceof Uint8Array)) return false;
  const txn = txnObj.txn;
  if (!txn || typeof txn !== "object") return false;
  const hasRequiredProps = "type" in txn && "snd" in txn;
  return hasRequiredProps;
}
function isTransaction(item) {
  return item && typeof item === "object" && "sender" in item && (item.sender instanceof algosdk11.Address || typeof item.sender === "string");
}
function isTransactionArray(txnGroup) {
  if (!Array.isArray(txnGroup) || txnGroup.length === 0) {
    return false;
  }
  if (isTransaction(txnGroup[0])) {
    return true;
  }
  if (Array.isArray(txnGroup[0]) && txnGroup[0].length > 0 && isTransaction(txnGroup[0][0])) {
    return true;
  }
  return false;
}
function flattenTxnGroup(txnGroup) {
  if (!Array.isArray(txnGroup[0])) {
    return txnGroup;
  }
  return txnGroup.flat();
}
function getPayloadId() {
  const date = Date.now() * Math.pow(10, 3);
  const extra = Math.floor(Math.random() * Math.pow(10, 3));
  return date + extra;
}
function formatJsonRpcRequest(method, params) {
  return {
    id: getPayloadId(),
    jsonrpc: "2.0",
    method,
    params
  };
}

// src/manager.ts
var WalletManager = class {
  _clients = /* @__PURE__ */ new Map();
  baseNetworkConfig;
  store;
  subscribe;
  options;
  logger;
  constructor({
    wallets = [],
    networks,
    defaultNetwork = "testnet",
    options = {}
  } = {}) {
    this.logger = this.initializeLogger(options);
    this.logger.debug("Initializing WalletManager with config:", {
      wallets,
      networks,
      defaultNetwork,
      options
    });
    const persistedState = this.loadPersistedState();
    this.baseNetworkConfig = networks || createNetworkConfig();
    const networkConfig = this.initNetworkConfig(this.baseNetworkConfig, persistedState);
    this.options = { resetNetwork: options.resetNetwork || false };
    const activeNetwork = this.options.resetNetwork ? defaultNetwork : persistedState?.activeNetwork || defaultNetwork;
    if (!networkConfig[activeNetwork]) {
      throw new Error(`Network "${activeNetwork}" not found in network configuration`);
    }
    const algodClient = this.createAlgodClient(networkConfig[activeNetwork].algod);
    const initialState = {
      ...DEFAULT_STATE,
      ...persistedState,
      networkConfig,
      activeNetwork,
      algodClient
    };
    this.store = new Store(initialState, {
      onUpdate: () => this.savePersistedState()
    });
    this.savePersistedState();
    this.subscribe = (callback) => {
      const unsubscribe = this.store.subscribe(() => {
        callback(this.store.state);
      });
      return unsubscribe;
    };
    this.initializeWallets(wallets);
  }
  // ---------- Logging ----------------------------------------------- //
  initializeLogger(options) {
    const logLevel = this.determineLogLevel(options);
    Logger.setLevel(logLevel);
    return logger.createScopedLogger("WalletManager");
  }
  determineLogLevel(options) {
    if (options?.debug) {
      return 0 /* DEBUG */;
    }
    return options?.logLevel !== void 0 ? options.logLevel : 2 /* WARN */;
  }
  // ---------- Store ------------------------------------------------- //
  get algodClient() {
    return this.store.state.algodClient;
  }
  set algodClient(algodClient) {
    this.store.setState((state) => ({
      ...state,
      algodClient
    }));
  }
  loadPersistedState() {
    try {
      const serializedState = StorageAdapter.getItem(LOCAL_STORAGE_KEY);
      if (serializedState === null) {
        return null;
      }
      const parsedState = JSON.parse(serializedState);
      if (!isValidPersistedState(parsedState)) {
        this.logger.warn("Parsed state:", parsedState);
        throw new Error("Persisted state is invalid");
      }
      return parsedState;
    } catch (error) {
      this.logger.error(`Could not load state from local storage: ${error.message}`);
      return null;
    }
  }
  savePersistedState() {
    try {
      const { wallets, activeWallet, activeNetwork, networkConfig } = this.store.state;
      const persistedState = {
        wallets,
        activeWallet,
        activeNetwork,
        customNetworkConfigs: {}
      };
      for (const [networkId, currentConfig] of Object.entries(networkConfig)) {
        const baseNetworkConfig = this.baseNetworkConfig[networkId];
        if (!baseNetworkConfig) continue;
        const customizations = {};
        let hasCustomizations = false;
        if (JSON.stringify(currentConfig.algod) !== JSON.stringify(baseNetworkConfig.algod)) {
          customizations.algod = currentConfig.algod;
          hasCustomizations = true;
        }
        if (hasCustomizations) {
          persistedState.customNetworkConfigs = {
            ...persistedState.customNetworkConfigs || {},
            [networkId]: customizations
          };
        }
      }
      const serializedState = JSON.stringify(persistedState);
      StorageAdapter.setItem(LOCAL_STORAGE_KEY, serializedState);
    } catch (error) {
      this.logger.error("Could not save state to local storage:", error);
    }
  }
  // ---------- Status ------------------------------------------------ //
  get status() {
    return this.store.state.managerStatus;
  }
  get isReady() {
    return this.store.state.managerStatus === "ready";
  }
  // ---------- Wallets ----------------------------------------------- //
  initializeWallets(walletsConfig) {
    this.logger.info("Initializing wallets...");
    for (const walletConfig of walletsConfig) {
      let walletId;
      let walletOptions;
      let walletMetadata;
      if (typeof walletConfig === "string") {
        walletId = walletConfig;
      } else {
        const { id, options, metadata } = walletConfig;
        walletId = id;
        walletOptions = options;
        walletMetadata = metadata;
      }
      const walletMap = createWalletMap();
      const WalletClass = walletMap[walletId];
      if (!WalletClass) {
        this.logger.error(`Wallet not found: ${walletId}`);
        continue;
      }
      const walletInstance = new WalletClass({
        id: walletId,
        metadata: walletMetadata,
        options: walletOptions,
        getAlgodClient: this.getAlgodClient,
        store: this.store,
        subscribe: this.subscribe
      });
      this._clients.set(walletId, walletInstance);
      this.logger.info(`\u2705 Initialized ${walletId}`);
    }
    const state = this.store.state;
    const connectedWallets = Object.keys(state.wallets);
    for (const walletId of connectedWallets) {
      if (!this._clients.has(walletId)) {
        this.logger.warn(`Connected wallet not found: ${walletId}`);
        removeWallet(this.store, { walletId });
      }
    }
    if (state.activeWallet && !this._clients.has(state.activeWallet)) {
      this.logger.warn(`Active wallet not found: ${state.activeWallet}`);
      setActiveWallet(this.store, { walletId: null });
    }
  }
  get wallets() {
    return [...this._clients.values()];
  }
  getWallet(walletId) {
    return this._clients.get(walletId);
  }
  async resumeSessions() {
    try {
      const promises = this.wallets.map((wallet) => wallet?.resumeSession());
      await Promise.all(promises);
    } finally {
      this.store.setState((state) => ({
        ...state,
        managerStatus: "ready"
      }));
    }
  }
  async disconnect() {
    const promises = this.wallets.filter((wallet) => wallet.isConnected).map((wallet) => wallet?.disconnect());
    await Promise.all(promises);
  }
  // ---------- Network ----------------------------------------------- //
  initNetworkConfig(baseConfig, persistedState) {
    this.logger.info("Initializing network configuration...");
    const customConfigs = persistedState?.customNetworkConfigs || {};
    const config = {};
    for (const [networkId, baseNetworkConfig] of Object.entries(baseConfig)) {
      const customNetworkConfig = customConfigs[networkId];
      config[networkId] = {
        ...baseNetworkConfig,
        ...customNetworkConfig,
        // Ensure algod config is also deeply merged
        algod: {
          ...baseNetworkConfig.algod,
          ...customNetworkConfig?.algod || {}
        }
      };
    }
    for (const [id, network] of Object.entries(config)) {
      if (!isNetworkConfig(network)) {
        throw new Error(`Invalid network configuration for "${id}"`);
      }
    }
    this.logger.debug("Network configuration:", config);
    return config;
  }
  createAlgodClient(config) {
    this.logger.info(`Creating new Algodv2 client...`);
    const { token = "", baseServer, port = "", headers = {} } = config;
    return new algosdk12.Algodv2(token, baseServer, port, headers);
  }
  getAlgodClient = () => {
    return this.algodClient;
  };
  setActiveNetwork = async (networkId) => {
    if (this.activeNetwork === networkId) {
      return;
    }
    if (!this.networkConfig[networkId]) {
      throw new Error(`Network "${networkId}" not found in network configuration`);
    }
    const algodClient = this.createAlgodClient(this.networkConfig[networkId].algod);
    setActiveNetwork(this.store, { networkId, algodClient });
    this.logger.info(`\u2705 Active network set to ${networkId}`);
  };
  updateAlgodConfig(networkId, algodConfig) {
    if (!this.networkConfig[networkId]) {
      throw new Error(`Network "${networkId}" not found in network configuration`);
    }
    const updatedConfig = {
      ...this.networkConfig[networkId],
      algod: {
        ...this.networkConfig[networkId].algod,
        ...algodConfig
      }
    };
    if (!isNetworkConfig(updatedConfig)) {
      throw new Error("Invalid network configuration");
    }
    this.store.setState((state) => ({
      ...state,
      networkConfig: {
        ...state.networkConfig,
        [networkId]: updatedConfig
      }
    }));
    if (this.activeNetwork === networkId) {
      this.algodClient = this.createAlgodClient(updatedConfig.algod);
    }
    this.savePersistedState();
    this.logger.info(`\u2705 Updated algod configuration for ${networkId}`);
  }
  resetNetworkConfig(networkId) {
    if (!this.baseNetworkConfig[networkId]) {
      throw new Error(`Network "${networkId}" not found in network configuration`);
    }
    this.store.setState((state) => ({
      ...state,
      networkConfig: {
        ...state.networkConfig,
        [networkId]: { ...this.baseNetworkConfig[networkId] }
      }
    }));
    if (this.activeNetwork === networkId) {
      this.algodClient = this.createAlgodClient(this.baseNetworkConfig[networkId].algod);
    }
    const persistedState = this.loadPersistedState();
    if (persistedState?.customNetworkConfigs) {
      delete persistedState.customNetworkConfigs[networkId];
      StorageAdapter.setItem(LOCAL_STORAGE_KEY, JSON.stringify(persistedState));
    }
    this.logger.info(`\u2705 Reset network configuration for ${networkId}`);
  }
  get activeNetwork() {
    return this.store.state.activeNetwork;
  }
  get networkConfig() {
    return this.store.state.networkConfig;
  }
  get activeNetworkConfig() {
    const { networkConfig, activeNetwork } = this.store.state;
    return networkConfig[activeNetwork];
  }
  // ---------- Active Wallet ----------------------------------------- //
  get activeWallet() {
    const state = this.store.state;
    const activeWallet = this.wallets.find((wallet) => wallet.id === state.activeWallet);
    if (!activeWallet) {
      return null;
    }
    return activeWallet;
  }
  get activeWalletAccounts() {
    if (!this.activeWallet) {
      return null;
    }
    return this.activeWallet.accounts;
  }
  get activeWalletAddresses() {
    if (!this.activeWallet) {
      return null;
    }
    return this.activeWallet.accounts.map((account) => account.address);
  }
  get activeAccount() {
    if (!this.activeWallet) {
      return null;
    }
    return this.activeWallet.activeAccount;
  }
  get activeAddress() {
    if (!this.activeAccount) {
      return null;
    }
    return this.activeAccount.address;
  }
  // ---------- Sign Transactions ------------------------------------- //
  get signTransactions() {
    if (!this.activeWallet) {
      this.logger.error("No active wallet found!");
      throw new Error("No active wallet found!");
    }
    return this.activeWallet.signTransactions;
  }
  get transactionSigner() {
    if (!this.activeWallet) {
      this.logger.error("No active wallet found!");
      throw new Error("No active wallet found!");
    }
    return this.activeWallet.transactionSigner;
  }
};

// src/webpack.ts
var webpackFallback = {
  "@agoralabs-sh/avm-web-provider": false,
  "@blockshake/defly-connect": false,
  "@magic-ext/algorand": false,
  "@perawallet/connect": false,
  "@walletconnect/modal": false,
  "@walletconnect/sign-client": false,
  "lute-connect": false,
  "magic-sdk": false
};
export {
  BaseWallet,
  CustomWallet,
  DEFAULT_NETWORK_CONFIG,
  DEFAULT_STATE,
  DeflyWallet,
  ExodusWallet,
  ICON7 as ICON,
  KIBISIS_AVM_WEB_PROVIDER_ID,
  KibisisWallet,
  KmdWallet,
  LOCAL_STORAGE_MNEMONIC_KEY,
  LogLevel,
  MagicAuth,
  MnemonicWallet,
  NetworkConfigBuilder,
  NetworkId,
  PeraWallet,
  SessionError,
  SignTxnsError,
  StorageAdapter,
  WalletConnect,
  WalletId,
  WalletManager,
  webpackFallback
};
//# sourceMappingURL=index.js.map